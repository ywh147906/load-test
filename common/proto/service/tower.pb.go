// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/service/tower.proto

package service

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	models "github.com/ywh147906/load-test/common/proto/models"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TowerErrorCode int32

const (
	TowerErrorCode_ErrTowerNotLevelID               TowerErrorCode = 0
	TowerErrorCode_ErrTowerNoData                   TowerErrorCode = 1
	TowerErrorCode_ErrTowerConfig                   TowerErrorCode = 2
	TowerErrorCode_ErrTowerNoFindType               TowerErrorCode = 3
	TowerErrorCode_ErrTowerMeditationTimesNotEnough TowerErrorCode = 4
	TowerErrorCode_ErrTowerChallengeTimesNotEnough  TowerErrorCode = 5
	TowerErrorCode_ErrTowerIsMaxLevel               TowerErrorCode = 6
	TowerErrorCode_ErrTowerBattleStart              TowerErrorCode = 7
	TowerErrorCode_ErrTowerBattleLevel              TowerErrorCode = 8
	TowerErrorCode_ErrTowerLevelPassed              TowerErrorCode = 9
)

var TowerErrorCode_name = map[int32]string{
	0: "ErrTowerNotLevelID",
	1: "ErrTowerNoData",
	2: "ErrTowerConfig",
	3: "ErrTowerNoFindType",
	4: "ErrTowerMeditationTimesNotEnough",
	5: "ErrTowerChallengeTimesNotEnough",
	6: "ErrTowerIsMaxLevel",
	7: "ErrTowerBattleStart",
	8: "ErrTowerBattleLevel",
	9: "ErrTowerLevelPassed",
}

var TowerErrorCode_value = map[string]int32{
	"ErrTowerNotLevelID":               0,
	"ErrTowerNoData":                   1,
	"ErrTowerConfig":                   2,
	"ErrTowerNoFindType":               3,
	"ErrTowerMeditationTimesNotEnough": 4,
	"ErrTowerChallengeTimesNotEnough":  5,
	"ErrTowerIsMaxLevel":               6,
	"ErrTowerBattleStart":              7,
	"ErrTowerBattleLevel":              8,
	"ErrTowerLevelPassed":              9,
}

func (TowerErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0}
}

type Tower struct {
}

func (m *Tower) Reset()      { *m = Tower{} }
func (*Tower) ProtoMessage() {}
func (*Tower) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0}
}
func (m *Tower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower.Merge(m, src)
}
func (m *Tower) XXX_Size() int {
	return m.Size()
}
func (m *Tower) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower.DiscardUnknown(m)
}

var xxx_messageInfo_Tower proto.InternalMessageInfo

func (*Tower) XXX_MessageName() string {
	return "service.Tower"
}

// 历史通关奖励查询
type Tower_GetTowerRewardInfoRequest struct {
	Type models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
}

func (m *Tower_GetTowerRewardInfoRequest) Reset()      { *m = Tower_GetTowerRewardInfoRequest{} }
func (*Tower_GetTowerRewardInfoRequest) ProtoMessage() {}
func (*Tower_GetTowerRewardInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 0}
}
func (m *Tower_GetTowerRewardInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_GetTowerRewardInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_GetTowerRewardInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_GetTowerRewardInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_GetTowerRewardInfoRequest.Merge(m, src)
}
func (m *Tower_GetTowerRewardInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_GetTowerRewardInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_GetTowerRewardInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_GetTowerRewardInfoRequest proto.InternalMessageInfo

func (m *Tower_GetTowerRewardInfoRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (*Tower_GetTowerRewardInfoRequest) XXX_MessageName() string {
	return "service.Tower.GetTowerRewardInfoRequest"
}

type Tower_GetTowerRewardInfoResponse struct {
	Type    models.TowerType                `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	DataMap map[int64]*models.TowerPassData `protobuf:"bytes,2,rep,name=data_map,json=dataMap,proto3" json:"data_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Tower_GetTowerRewardInfoResponse) Reset()      { *m = Tower_GetTowerRewardInfoResponse{} }
func (*Tower_GetTowerRewardInfoResponse) ProtoMessage() {}
func (*Tower_GetTowerRewardInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 1}
}
func (m *Tower_GetTowerRewardInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_GetTowerRewardInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_GetTowerRewardInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_GetTowerRewardInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_GetTowerRewardInfoResponse.Merge(m, src)
}
func (m *Tower_GetTowerRewardInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_GetTowerRewardInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_GetTowerRewardInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_GetTowerRewardInfoResponse proto.InternalMessageInfo

func (m *Tower_GetTowerRewardInfoResponse) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_GetTowerRewardInfoResponse) GetDataMap() map[int64]*models.TowerPassData {
	if m != nil {
		return m.DataMap
	}
	return nil
}

func (*Tower_GetTowerRewardInfoResponse) XXX_MessageName() string {
	return "service.Tower.GetTowerRewardInfoResponse"
}

// 获取当前挑战关卡id
type Tower_GetNextChallengeDataRequest struct {
	Type models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
}

func (m *Tower_GetNextChallengeDataRequest) Reset()      { *m = Tower_GetNextChallengeDataRequest{} }
func (*Tower_GetNextChallengeDataRequest) ProtoMessage() {}
func (*Tower_GetNextChallengeDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 2}
}
func (m *Tower_GetNextChallengeDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_GetNextChallengeDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_GetNextChallengeDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_GetNextChallengeDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_GetNextChallengeDataRequest.Merge(m, src)
}
func (m *Tower_GetNextChallengeDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_GetNextChallengeDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_GetNextChallengeDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_GetNextChallengeDataRequest proto.InternalMessageInfo

func (m *Tower_GetNextChallengeDataRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (*Tower_GetNextChallengeDataRequest) XXX_MessageName() string {
	return "service.Tower.GetNextChallengeDataRequest"
}

type Tower_GetNextChallengeDataResponse struct {
	Type models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	Data *models.Tower    `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Tower_GetNextChallengeDataResponse) Reset()      { *m = Tower_GetNextChallengeDataResponse{} }
func (*Tower_GetNextChallengeDataResponse) ProtoMessage() {}
func (*Tower_GetNextChallengeDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 3}
}
func (m *Tower_GetNextChallengeDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_GetNextChallengeDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_GetNextChallengeDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_GetNextChallengeDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_GetNextChallengeDataResponse.Merge(m, src)
}
func (m *Tower_GetNextChallengeDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_GetNextChallengeDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_GetNextChallengeDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_GetNextChallengeDataResponse proto.InternalMessageInfo

func (m *Tower_GetNextChallengeDataResponse) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_GetNextChallengeDataResponse) GetData() *models.Tower {
	if m != nil {
		return m.Data
	}
	return nil
}

func (*Tower_GetNextChallengeDataResponse) XXX_MessageName() string {
	return "service.Tower.GetNextChallengeDataResponse"
}

// 查询 挂机奖励
type Tower_TowerAccumulateInfoRequest struct {
	Type models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
}

func (m *Tower_TowerAccumulateInfoRequest) Reset()      { *m = Tower_TowerAccumulateInfoRequest{} }
func (*Tower_TowerAccumulateInfoRequest) ProtoMessage() {}
func (*Tower_TowerAccumulateInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 4}
}
func (m *Tower_TowerAccumulateInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerAccumulateInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerAccumulateInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerAccumulateInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerAccumulateInfoRequest.Merge(m, src)
}
func (m *Tower_TowerAccumulateInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerAccumulateInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerAccumulateInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerAccumulateInfoRequest proto.InternalMessageInfo

func (m *Tower_TowerAccumulateInfoRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (*Tower_TowerAccumulateInfoRequest) XXX_MessageName() string {
	return "service.Tower.TowerAccumulateInfoRequest"
}

type Tower_TowerAccumulateInfoResponse struct {
	Type models.TowerType                   `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	Info *models.TowerAccumulateHarvestInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *Tower_TowerAccumulateInfoResponse) Reset()      { *m = Tower_TowerAccumulateInfoResponse{} }
func (*Tower_TowerAccumulateInfoResponse) ProtoMessage() {}
func (*Tower_TowerAccumulateInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 5}
}
func (m *Tower_TowerAccumulateInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerAccumulateInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerAccumulateInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerAccumulateInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerAccumulateInfoResponse.Merge(m, src)
}
func (m *Tower_TowerAccumulateInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerAccumulateInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerAccumulateInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerAccumulateInfoResponse proto.InternalMessageInfo

func (m *Tower_TowerAccumulateInfoResponse) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerAccumulateInfoResponse) GetInfo() *models.TowerAccumulateHarvestInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (*Tower_TowerAccumulateInfoResponse) XXX_MessageName() string {
	return "service.Tower.TowerAccumulateInfoResponse"
}

// 收割 挂机奖励
type Tower_TowerAccumulateHarvestRequest struct {
	Type        models.TowerType             `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	HarvestType models.AccumulateHarvestType `protobuf:"varint,2,opt,name=harvest_type,json=harvestType,proto3,enum=models.AccumulateHarvestType" json:"harvest_type,omitempty"`
}

func (m *Tower_TowerAccumulateHarvestRequest) Reset()      { *m = Tower_TowerAccumulateHarvestRequest{} }
func (*Tower_TowerAccumulateHarvestRequest) ProtoMessage() {}
func (*Tower_TowerAccumulateHarvestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 6}
}
func (m *Tower_TowerAccumulateHarvestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerAccumulateHarvestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerAccumulateHarvestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerAccumulateHarvestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerAccumulateHarvestRequest.Merge(m, src)
}
func (m *Tower_TowerAccumulateHarvestRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerAccumulateHarvestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerAccumulateHarvestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerAccumulateHarvestRequest proto.InternalMessageInfo

func (m *Tower_TowerAccumulateHarvestRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerAccumulateHarvestRequest) GetHarvestType() models.AccumulateHarvestType {
	if m != nil {
		return m.HarvestType
	}
	return models.AccumulateHarvestType_AT_None
}

func (*Tower_TowerAccumulateHarvestRequest) XXX_MessageName() string {
	return "service.Tower.TowerAccumulateHarvestRequest"
}

type Tower_TowerAccumulateHarvestResponse struct {
	Type    models.TowerType                   `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	Info    *models.TowerAccumulateHarvestInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	Rewards []*models.Item                     `protobuf:"bytes,3,rep,name=rewards,proto3" json:"rewards,omitempty"`
}

func (m *Tower_TowerAccumulateHarvestResponse) Reset()      { *m = Tower_TowerAccumulateHarvestResponse{} }
func (*Tower_TowerAccumulateHarvestResponse) ProtoMessage() {}
func (*Tower_TowerAccumulateHarvestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 7}
}
func (m *Tower_TowerAccumulateHarvestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerAccumulateHarvestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerAccumulateHarvestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerAccumulateHarvestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerAccumulateHarvestResponse.Merge(m, src)
}
func (m *Tower_TowerAccumulateHarvestResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerAccumulateHarvestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerAccumulateHarvestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerAccumulateHarvestResponse proto.InternalMessageInfo

func (m *Tower_TowerAccumulateHarvestResponse) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerAccumulateHarvestResponse) GetInfo() *models.TowerAccumulateHarvestInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Tower_TowerAccumulateHarvestResponse) GetRewards() []*models.Item {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (*Tower_TowerAccumulateHarvestResponse) XXX_MessageName() string {
	return "service.Tower.TowerAccumulateHarvestResponse"
}

type Tower_TowerBattleInfoRequest struct {
	Type              models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	CurrentTowerLevel int64            `protobuf:"varint,2,opt,name=current_tower_level,json=currentTowerLevel,proto3" json:"current_tower_level,omitempty"`
	BattleId          int64            `protobuf:"varint,100,opt,name=battle_id,json=battleId,proto3" json:"battle_id,omitempty"`
}

func (m *Tower_TowerBattleInfoRequest) Reset()      { *m = Tower_TowerBattleInfoRequest{} }
func (*Tower_TowerBattleInfoRequest) ProtoMessage() {}
func (*Tower_TowerBattleInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 8}
}
func (m *Tower_TowerBattleInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerBattleInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerBattleInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerBattleInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerBattleInfoRequest.Merge(m, src)
}
func (m *Tower_TowerBattleInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerBattleInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerBattleInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerBattleInfoRequest proto.InternalMessageInfo

func (m *Tower_TowerBattleInfoRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerBattleInfoRequest) GetCurrentTowerLevel() int64 {
	if m != nil {
		return m.CurrentTowerLevel
	}
	return 0
}

func (m *Tower_TowerBattleInfoRequest) GetBattleId() int64 {
	if m != nil {
		return m.BattleId
	}
	return 0
}

func (*Tower_TowerBattleInfoRequest) XXX_MessageName() string {
	return "service.Tower.TowerBattleInfoRequest"
}

type Tower_TowerBattleInfoResponse struct {
	Data              *models.SingleBattleParam `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	CurrentTowerLevel int64                     `protobuf:"varint,2,opt,name=current_tower_level,json=currentTowerLevel,proto3" json:"current_tower_level,omitempty"`
	BattleId          int64                     `protobuf:"varint,100,opt,name=battle_id,json=battleId,proto3" json:"battle_id,omitempty"`
}

func (m *Tower_TowerBattleInfoResponse) Reset()      { *m = Tower_TowerBattleInfoResponse{} }
func (*Tower_TowerBattleInfoResponse) ProtoMessage() {}
func (*Tower_TowerBattleInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 9}
}
func (m *Tower_TowerBattleInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerBattleInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerBattleInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerBattleInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerBattleInfoResponse.Merge(m, src)
}
func (m *Tower_TowerBattleInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerBattleInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerBattleInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerBattleInfoResponse proto.InternalMessageInfo

func (m *Tower_TowerBattleInfoResponse) GetData() *models.SingleBattleParam {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Tower_TowerBattleInfoResponse) GetCurrentTowerLevel() int64 {
	if m != nil {
		return m.CurrentTowerLevel
	}
	return 0
}

func (m *Tower_TowerBattleInfoResponse) GetBattleId() int64 {
	if m != nil {
		return m.BattleId
	}
	return 0
}

func (*Tower_TowerBattleInfoResponse) XXX_MessageName() string {
	return "service.Tower.TowerBattleInfoResponse"
}

type Tower_TowerChallengeResultPrcRequest struct {
	Type      models.TowerType    `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	WinType   models.TowerWinType `protobuf:"varint,2,opt,name=win_type,json=winType,proto3,enum=models.TowerWinType" json:"win_type,omitempty"`
	PassLevel int64               `protobuf:"varint,3,opt,name=pass_level,json=passLevel,proto3" json:"pass_level,omitempty"`
	IsWin     bool                `protobuf:"varint,4,opt,name=is_win,json=isWin,proto3" json:"is_win,omitempty"`
}

func (m *Tower_TowerChallengeResultPrcRequest) Reset()      { *m = Tower_TowerChallengeResultPrcRequest{} }
func (*Tower_TowerChallengeResultPrcRequest) ProtoMessage() {}
func (*Tower_TowerChallengeResultPrcRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 10}
}
func (m *Tower_TowerChallengeResultPrcRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerChallengeResultPrcRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerChallengeResultPrcRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerChallengeResultPrcRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerChallengeResultPrcRequest.Merge(m, src)
}
func (m *Tower_TowerChallengeResultPrcRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerChallengeResultPrcRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerChallengeResultPrcRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerChallengeResultPrcRequest proto.InternalMessageInfo

func (m *Tower_TowerChallengeResultPrcRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerChallengeResultPrcRequest) GetWinType() models.TowerWinType {
	if m != nil {
		return m.WinType
	}
	return models.TowerWinType_TW_None
}

func (m *Tower_TowerChallengeResultPrcRequest) GetPassLevel() int64 {
	if m != nil {
		return m.PassLevel
	}
	return 0
}

func (m *Tower_TowerChallengeResultPrcRequest) GetIsWin() bool {
	if m != nil {
		return m.IsWin
	}
	return false
}

func (*Tower_TowerChallengeResultPrcRequest) XXX_MessageName() string {
	return "service.Tower.TowerChallengeResultPrcRequest"
}

type Tower_TowerChallengeResultPrcResponse struct {
	Type    models.TowerType    `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	Rewards []*models.Item      `protobuf:"bytes,2,rep,name=rewards,proto3" json:"rewards,omitempty"`
	WinType models.TowerWinType `protobuf:"varint,3,opt,name=win_type,json=winType,proto3,enum=models.TowerWinType" json:"win_type,omitempty"`
	Data    *models.Tower       `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Tower_TowerChallengeResultPrcResponse) Reset()      { *m = Tower_TowerChallengeResultPrcResponse{} }
func (*Tower_TowerChallengeResultPrcResponse) ProtoMessage() {}
func (*Tower_TowerChallengeResultPrcResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 11}
}
func (m *Tower_TowerChallengeResultPrcResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerChallengeResultPrcResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerChallengeResultPrcResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerChallengeResultPrcResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerChallengeResultPrcResponse.Merge(m, src)
}
func (m *Tower_TowerChallengeResultPrcResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerChallengeResultPrcResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerChallengeResultPrcResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerChallengeResultPrcResponse proto.InternalMessageInfo

func (m *Tower_TowerChallengeResultPrcResponse) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerChallengeResultPrcResponse) GetRewards() []*models.Item {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *Tower_TowerChallengeResultPrcResponse) GetWinType() models.TowerWinType {
	if m != nil {
		return m.WinType
	}
	return models.TowerWinType_TW_None
}

func (m *Tower_TowerChallengeResultPrcResponse) GetData() *models.Tower {
	if m != nil {
		return m.Data
	}
	return nil
}

func (*Tower_TowerChallengeResultPrcResponse) XXX_MessageName() string {
	return "service.Tower.TowerChallengeResultPrcResponse"
}

type Tower_TowerChallengeSoomCalculationRequest struct {
	Type              models.TowerType   `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	CurrentTowerLevel int64              `protobuf:"varint,2,opt,name=current_tower_level,json=currentTowerLevel,proto3" json:"current_tower_level,omitempty"`
	Heroes            []*models.HeroInfo `protobuf:"bytes,3,rep,name=heroes,proto3" json:"heroes,omitempty"`
	MonsterHpRatio    float32            `protobuf:"fixed32,4,opt,name=monster_hp_ratio,json=monsterHpRatio,proto3" json:"monster_hp_ratio,omitempty"`
}

func (m *Tower_TowerChallengeSoomCalculationRequest) Reset() {
	*m = Tower_TowerChallengeSoomCalculationRequest{}
}
func (*Tower_TowerChallengeSoomCalculationRequest) ProtoMessage() {}
func (*Tower_TowerChallengeSoomCalculationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 12}
}
func (m *Tower_TowerChallengeSoomCalculationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerChallengeSoomCalculationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerChallengeSoomCalculationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerChallengeSoomCalculationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerChallengeSoomCalculationRequest.Merge(m, src)
}
func (m *Tower_TowerChallengeSoomCalculationRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerChallengeSoomCalculationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerChallengeSoomCalculationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerChallengeSoomCalculationRequest proto.InternalMessageInfo

func (m *Tower_TowerChallengeSoomCalculationRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerChallengeSoomCalculationRequest) GetCurrentTowerLevel() int64 {
	if m != nil {
		return m.CurrentTowerLevel
	}
	return 0
}

func (m *Tower_TowerChallengeSoomCalculationRequest) GetHeroes() []*models.HeroInfo {
	if m != nil {
		return m.Heroes
	}
	return nil
}

func (m *Tower_TowerChallengeSoomCalculationRequest) GetMonsterHpRatio() float32 {
	if m != nil {
		return m.MonsterHpRatio
	}
	return 0
}

func (*Tower_TowerChallengeSoomCalculationRequest) XXX_MessageName() string {
	return "service.Tower.TowerChallengeSoomCalculationRequest"
}

type Tower_TowerChallengeSoomCalculationResponse struct {
	Type  models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	IsWin bool             `protobuf:"varint,2,opt,name=is_win,json=isWin,proto3" json:"is_win,omitempty"`
}

func (m *Tower_TowerChallengeSoomCalculationResponse) Reset() {
	*m = Tower_TowerChallengeSoomCalculationResponse{}
}
func (*Tower_TowerChallengeSoomCalculationResponse) ProtoMessage() {}
func (*Tower_TowerChallengeSoomCalculationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 13}
}
func (m *Tower_TowerChallengeSoomCalculationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_TowerChallengeSoomCalculationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_TowerChallengeSoomCalculationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_TowerChallengeSoomCalculationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_TowerChallengeSoomCalculationResponse.Merge(m, src)
}
func (m *Tower_TowerChallengeSoomCalculationResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_TowerChallengeSoomCalculationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_TowerChallengeSoomCalculationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_TowerChallengeSoomCalculationResponse proto.InternalMessageInfo

func (m *Tower_TowerChallengeSoomCalculationResponse) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_TowerChallengeSoomCalculationResponse) GetIsWin() bool {
	if m != nil {
		return m.IsWin
	}
	return false
}

func (*Tower_TowerChallengeSoomCalculationResponse) XXX_MessageName() string {
	return "service.Tower.TowerChallengeSoomCalculationResponse"
}

type Tower_CheatTowerGmSetlevelRequest struct {
	Type         models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	CurrentLevel int64            `protobuf:"varint,2,opt,name=current_level,json=currentLevel,proto3" json:"current_level,omitempty"`
}

func (m *Tower_CheatTowerGmSetlevelRequest) Reset()      { *m = Tower_CheatTowerGmSetlevelRequest{} }
func (*Tower_CheatTowerGmSetlevelRequest) ProtoMessage() {}
func (*Tower_CheatTowerGmSetlevelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 14}
}
func (m *Tower_CheatTowerGmSetlevelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_CheatTowerGmSetlevelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_CheatTowerGmSetlevelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_CheatTowerGmSetlevelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_CheatTowerGmSetlevelRequest.Merge(m, src)
}
func (m *Tower_CheatTowerGmSetlevelRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_CheatTowerGmSetlevelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_CheatTowerGmSetlevelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_CheatTowerGmSetlevelRequest proto.InternalMessageInfo

func (m *Tower_CheatTowerGmSetlevelRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (m *Tower_CheatTowerGmSetlevelRequest) GetCurrentLevel() int64 {
	if m != nil {
		return m.CurrentLevel
	}
	return 0
}

func (*Tower_CheatTowerGmSetlevelRequest) XXX_MessageName() string {
	return "service.Tower.CheatTowerGmSetlevelRequest"
}

type Tower_CheatTowerGmSetlevelResponse struct {
}

func (m *Tower_CheatTowerGmSetlevelResponse) Reset()      { *m = Tower_CheatTowerGmSetlevelResponse{} }
func (*Tower_CheatTowerGmSetlevelResponse) ProtoMessage() {}
func (*Tower_CheatTowerGmSetlevelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 15}
}
func (m *Tower_CheatTowerGmSetlevelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_CheatTowerGmSetlevelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_CheatTowerGmSetlevelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_CheatTowerGmSetlevelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_CheatTowerGmSetlevelResponse.Merge(m, src)
}
func (m *Tower_CheatTowerGmSetlevelResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_CheatTowerGmSetlevelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_CheatTowerGmSetlevelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_CheatTowerGmSetlevelResponse proto.InternalMessageInfo

func (*Tower_CheatTowerGmSetlevelResponse) XXX_MessageName() string {
	return "service.Tower.CheatTowerGmSetlevelResponse"
}

type Tower_CheatTowerGmRefreshMeditationTimesRequest struct {
	Type models.TowerType `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) Reset() {
	*m = Tower_CheatTowerGmRefreshMeditationTimesRequest{}
}
func (*Tower_CheatTowerGmRefreshMeditationTimesRequest) ProtoMessage() {}
func (*Tower_CheatTowerGmRefreshMeditationTimesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 16}
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesRequest.Merge(m, src)
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesRequest proto.InternalMessageInfo

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) GetType() models.TowerType {
	if m != nil {
		return m.Type
	}
	return models.TowerType_TT_None
}

func (*Tower_CheatTowerGmRefreshMeditationTimesRequest) XXX_MessageName() string {
	return "service.Tower.CheatTowerGmRefreshMeditationTimesRequest"
}

type Tower_CheatTowerGmRefreshMeditationTimesResponse struct {
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) Reset() {
	*m = Tower_CheatTowerGmRefreshMeditationTimesResponse{}
}
func (*Tower_CheatTowerGmRefreshMeditationTimesResponse) ProtoMessage() {}
func (*Tower_CheatTowerGmRefreshMeditationTimesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 17}
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesResponse.Merge(m, src)
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_CheatTowerGmRefreshMeditationTimesResponse proto.InternalMessageInfo

func (*Tower_CheatTowerGmRefreshMeditationTimesResponse) XXX_MessageName() string {
	return "service.Tower.CheatTowerGmRefreshMeditationTimesResponse"
}

type Tower_SingleBattleRequest struct {
	Id       int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	BattleId int64 `protobuf:"varint,100,opt,name=battle_id,json=battleId,proto3" json:"battle_id,omitempty"`
}

func (m *Tower_SingleBattleRequest) Reset()      { *m = Tower_SingleBattleRequest{} }
func (*Tower_SingleBattleRequest) ProtoMessage() {}
func (*Tower_SingleBattleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 18}
}
func (m *Tower_SingleBattleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_SingleBattleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_SingleBattleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_SingleBattleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_SingleBattleRequest.Merge(m, src)
}
func (m *Tower_SingleBattleRequest) XXX_Size() int {
	return m.Size()
}
func (m *Tower_SingleBattleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_SingleBattleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_SingleBattleRequest proto.InternalMessageInfo

func (m *Tower_SingleBattleRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Tower_SingleBattleRequest) GetBattleId() int64 {
	if m != nil {
		return m.BattleId
	}
	return 0
}

func (*Tower_SingleBattleRequest) XXX_MessageName() string {
	return "service.Tower.SingleBattleRequest"
}

type Tower_SingleBattleResponse struct {
	Data     *models.SingleBattleParam `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	BattleId int64                     `protobuf:"varint,100,opt,name=battle_id,json=battleId,proto3" json:"battle_id,omitempty"`
}

func (m *Tower_SingleBattleResponse) Reset()      { *m = Tower_SingleBattleResponse{} }
func (*Tower_SingleBattleResponse) ProtoMessage() {}
func (*Tower_SingleBattleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_178671f91171526d, []int{0, 19}
}
func (m *Tower_SingleBattleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower_SingleBattleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower_SingleBattleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower_SingleBattleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower_SingleBattleResponse.Merge(m, src)
}
func (m *Tower_SingleBattleResponse) XXX_Size() int {
	return m.Size()
}
func (m *Tower_SingleBattleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower_SingleBattleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_Tower_SingleBattleResponse proto.InternalMessageInfo

func (m *Tower_SingleBattleResponse) GetData() *models.SingleBattleParam {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Tower_SingleBattleResponse) GetBattleId() int64 {
	if m != nil {
		return m.BattleId
	}
	return 0
}

func (*Tower_SingleBattleResponse) XXX_MessageName() string {
	return "service.Tower.SingleBattleResponse"
}
func init() {
	proto.RegisterEnum("service.TowerErrorCode", TowerErrorCode_name, TowerErrorCode_value)
	proto.RegisterType((*Tower)(nil), "service.Tower")
	proto.RegisterType((*Tower_GetTowerRewardInfoRequest)(nil), "service.Tower.GetTowerRewardInfoRequest")
	proto.RegisterType((*Tower_GetTowerRewardInfoResponse)(nil), "service.Tower.GetTowerRewardInfoResponse")
	proto.RegisterMapType((map[int64]*models.TowerPassData)(nil), "service.Tower.GetTowerRewardInfoResponse.DataMapEntry")
	proto.RegisterType((*Tower_GetNextChallengeDataRequest)(nil), "service.Tower.GetNextChallengeDataRequest")
	proto.RegisterType((*Tower_GetNextChallengeDataResponse)(nil), "service.Tower.GetNextChallengeDataResponse")
	proto.RegisterType((*Tower_TowerAccumulateInfoRequest)(nil), "service.Tower.TowerAccumulateInfoRequest")
	proto.RegisterType((*Tower_TowerAccumulateInfoResponse)(nil), "service.Tower.TowerAccumulateInfoResponse")
	proto.RegisterType((*Tower_TowerAccumulateHarvestRequest)(nil), "service.Tower.TowerAccumulateHarvestRequest")
	proto.RegisterType((*Tower_TowerAccumulateHarvestResponse)(nil), "service.Tower.TowerAccumulateHarvestResponse")
	proto.RegisterType((*Tower_TowerBattleInfoRequest)(nil), "service.Tower.TowerBattleInfoRequest")
	proto.RegisterType((*Tower_TowerBattleInfoResponse)(nil), "service.Tower.TowerBattleInfoResponse")
	proto.RegisterType((*Tower_TowerChallengeResultPrcRequest)(nil), "service.Tower.TowerChallengeResultPrcRequest")
	proto.RegisterType((*Tower_TowerChallengeResultPrcResponse)(nil), "service.Tower.TowerChallengeResultPrcResponse")
	proto.RegisterType((*Tower_TowerChallengeSoomCalculationRequest)(nil), "service.Tower.TowerChallengeSoomCalculationRequest")
	proto.RegisterType((*Tower_TowerChallengeSoomCalculationResponse)(nil), "service.Tower.TowerChallengeSoomCalculationResponse")
	proto.RegisterType((*Tower_CheatTowerGmSetlevelRequest)(nil), "service.Tower.CheatTowerGmSetlevelRequest")
	proto.RegisterType((*Tower_CheatTowerGmSetlevelResponse)(nil), "service.Tower.CheatTowerGmSetlevelResponse")
	proto.RegisterType((*Tower_CheatTowerGmRefreshMeditationTimesRequest)(nil), "service.Tower.CheatTowerGmRefreshMeditationTimesRequest")
	proto.RegisterType((*Tower_CheatTowerGmRefreshMeditationTimesResponse)(nil), "service.Tower.CheatTowerGmRefreshMeditationTimesResponse")
	proto.RegisterType((*Tower_SingleBattleRequest)(nil), "service.Tower.SingleBattleRequest")
	proto.RegisterType((*Tower_SingleBattleResponse)(nil), "service.Tower.SingleBattleResponse")
}

func init() { proto.RegisterFile("proto/service/tower.proto", fileDescriptor_178671f91171526d) }

var fileDescriptor_178671f91171526d = []byte{
	// 1227 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdd, 0x4f, 0x1c, 0x55,
	0x14, 0xdf, 0xd9, 0x5d, 0x3e, 0x7a, 0x4b, 0x71, 0xb9, 0xe5, 0x63, 0x18, 0xca, 0x74, 0xad, 0xd6,
	0x6c, 0x6b, 0x59, 0x12, 0x48, 0x1a, 0x63, 0xa2, 0x51, 0x16, 0x84, 0x4d, 0x84, 0xd0, 0x81, 0xa4,
	0x89, 0x2f, 0x9b, 0xcb, 0xce, 0x85, 0x9d, 0x38, 0x3b, 0xb3, 0xde, 0xb9, 0x0b, 0x25, 0xf1, 0xa1,
	0xa9, 0xc1, 0x20, 0x2d, 0xf1, 0x23, 0x45, 0xab, 0x69, 0x34, 0x24, 0x36, 0x35, 0x0d, 0xa1, 0x7c,
	0x84, 0x62, 0x6c, 0xe5, 0xc9, 0x87, 0x3e, 0xd6, 0xb7, 0x3e, 0xea, 0xe2, 0xec, 0xc2, 0x8b, 0xf1,
	0x4f, 0x30, 0x73, 0x67, 0x86, 0xdd, 0xa1, 0x0b, 0xb2, 0x8d, 0xfa, 0x36, 0x73, 0xce, 0xef, 0x9c,
	0xf3, 0x3b, 0xbf, 0x7b, 0xee, 0xd9, 0x59, 0xd0, 0x9a, 0x21, 0x3a, 0xd5, 0x3b, 0x0d, 0x4c, 0x26,
	0x95, 0x24, 0xee, 0xa4, 0xfa, 0x14, 0x26, 0x51, 0x66, 0x83, 0x35, 0x8e, 0x51, 0xe0, 0x6d, 0x4c,
	0x5a, 0x97, 0xb1, 0x6a, 0x94, 0x42, 0x84, 0x16, 0x8f, 0x67, 0x0c, 0x19, 0xd8, 0x71, 0xb4, 0x7a,
	0x1c, 0x04, 0xab, 0x4a, 0xd2, 0x28, 0xeb, 0xa2, 0x48, 0xc5, 0x1a, 0x75, 0x5c, 0xcd, 0xfb, 0xd2,
	0x4d, 0x94, 0x2d, 0x93, 0x35, 0xf6, 0xea, 0x7b, 0x73, 0xa5, 0x30, 0x92, 0x0f, 0x70, 0x8d, 0x21,
	0x4a, 0x55, 0x87, 0xdc, 0x99, 0x3f, 0x21, 0xa8, 0x1a, 0xb5, 0xba, 0x10, 0x7a, 0x40, 0x6b, 0x3f,
	0xa6, 0xec, 0x59, 0xc2, 0x53, 0x88, 0xc8, 0x71, 0x6d, 0x5c, 0x97, 0xf0, 0x07, 0x59, 0x6c, 0x50,
	0x78, 0x16, 0x04, 0xe9, 0x74, 0x06, 0xf3, 0x5c, 0x98, 0x8b, 0xd4, 0x77, 0x35, 0x44, 0xed, 0x54,
	0x51, 0x86, 0x1e, 0x9d, 0xce, 0x60, 0x89, 0xb9, 0x85, 0x5d, 0x0e, 0x08, 0xe5, 0x92, 0x18, 0x19,
	0x5d, 0x33, 0xf0, 0x11, 0xb3, 0xc0, 0x4b, 0xa0, 0x56, 0x46, 0x14, 0x25, 0xd2, 0x28, 0xc3, 0xfb,
	0xc3, 0x81, 0xc8, 0xf1, 0xae, 0x8b, 0x51, 0x47, 0x7f, 0x1b, 0x1b, 0x3d, 0xb8, 0x46, 0xb4, 0x17,
	0x51, 0x34, 0x88, 0x32, 0x7d, 0x1a, 0x25, 0xd3, 0x52, 0x8d, 0x6c, 0xbf, 0x09, 0x97, 0x40, 0x5d,
	0xa9, 0x03, 0x86, 0x40, 0xe0, 0x7d, 0x3c, 0xcd, 0x88, 0x04, 0x24, 0xeb, 0x11, 0xbe, 0x0a, 0xaa,
	0x26, 0x91, 0x9a, 0xc5, 0xbc, 0x3f, 0xcc, 0x45, 0x8e, 0x77, 0x35, 0x79, 0xc8, 0x0d, 0x23, 0xc3,
	0xb0, 0xe2, 0x25, 0x1b, 0xf3, 0xba, 0xff, 0x35, 0x4e, 0xe8, 0x05, 0x6d, 0xfd, 0x98, 0x0e, 0xe1,
	0x2b, 0x34, 0x96, 0x42, 0xaa, 0x8a, 0xb5, 0x09, 0xcc, 0x20, 0x95, 0x29, 0x96, 0x02, 0xa7, 0xca,
	0x67, 0xa9, 0x4c, 0xb2, 0x17, 0x41, 0xd0, 0x6a, 0xd5, 0x21, 0x7f, 0xc2, 0x03, 0x93, 0x98, 0x4b,
	0x88, 0x01, 0x81, 0xbd, 0xbe, 0x9d, 0x4c, 0x66, 0xd3, 0x59, 0x15, 0x51, 0xfc, 0x1c, 0x07, 0xfc,
	0x21, 0x68, 0x2b, 0x9b, 0xa4, 0x32, 0xb6, 0x17, 0x41, 0x50, 0xd1, 0xc6, 0x75, 0x87, 0xed, 0x19,
	0x0f, 0xac, 0x98, 0x79, 0x00, 0x91, 0x49, 0x6c, 0x50, 0x56, 0x80, 0xe1, 0x85, 0x59, 0x0e, 0xb4,
	0x97, 0x07, 0x55, 0xd6, 0x06, 0x7c, 0x0b, 0xd4, 0xa5, 0xec, 0xc0, 0x04, 0x83, 0xfb, 0x19, 0xbc,
	0xdd, 0x85, 0x3f, 0x93, 0x9e, 0x85, 0x1e, 0x4f, 0x15, 0x5f, 0x84, 0xbb, 0x1c, 0x10, 0x0f, 0xa2,
	0xf2, 0xbf, 0x88, 0x01, 0x5f, 0x01, 0x35, 0x84, 0x8d, 0xbf, 0xc1, 0x07, 0xd8, 0x25, 0xa9, 0x73,
	0x43, 0xe3, 0x14, 0xa7, 0x25, 0xd7, 0x29, 0xdc, 0xe0, 0x40, 0x33, 0x4b, 0xd6, 0xc3, 0xee, 0x7d,
	0xe5, 0x87, 0x0e, 0xa3, 0xe0, 0x64, 0x32, 0x4b, 0x08, 0xd6, 0x68, 0x82, 0x2d, 0xbc, 0x84, 0x8a,
	0x27, 0xb1, 0xca, 0x08, 0x07, 0xa4, 0x06, 0xc7, 0xc5, 0x82, 0xde, 0xb5, 0x1c, 0xb0, 0x0d, 0x1c,
	0xb3, 0x77, 0x4c, 0x42, 0x91, 0x79, 0x99, 0xa1, 0x6a, 0x6d, 0x43, 0x5c, 0x16, 0x16, 0x38, 0xd0,
	0xf2, 0x0c, 0x1d, 0x47, 0xb1, 0x0e, 0x67, 0x8a, 0x39, 0x26, 0x45, 0xab, 0xcb, 0x67, 0x44, 0xd1,
	0x26, 0x54, 0x6c, 0xe3, 0x87, 0x11, 0x41, 0x69, 0x7b, 0xa2, 0xff, 0x5d, 0x5e, 0xcb, 0xee, 0x81,
	0xee, 0xdd, 0x43, 0x09, 0x1b, 0x59, 0x95, 0x0e, 0x93, 0x64, 0x85, 0x72, 0x75, 0x82, 0xda, 0x29,
	0x45, 0x2b, 0x1d, 0xac, 0x46, 0x0f, 0xf4, 0xb2, 0xa2, 0x31, 0x74, 0xcd, 0x94, 0xfd, 0x00, 0xdb,
	0x01, 0xc8, 0x20, 0xc3, 0x70, 0xe8, 0x07, 0x18, 0xb1, 0x63, 0x96, 0xc5, 0xa6, 0xdd, 0x04, 0xaa,
	0x15, 0x23, 0x31, 0xa5, 0x68, 0x7c, 0x30, 0xcc, 0x45, 0x6a, 0xa5, 0x2a, 0xc5, 0xb8, 0xac, 0x68,
	0xc2, 0x2f, 0x1c, 0x38, 0x7d, 0x20, 0xe1, 0xca, 0x46, 0xb0, 0x64, 0x94, 0xfc, 0x87, 0x8c, 0x92,
	0xa7, 0xb3, 0xc0, 0x51, 0x3a, 0x73, 0xd7, 0x52, 0xf0, 0xe0, 0xb5, 0xf4, 0x2b, 0x07, 0x5e, 0xf6,
	0xb6, 0x31, 0xa2, 0xeb, 0xe9, 0x18, 0x52, 0x93, 0xd6, 0xdc, 0x2b, 0xba, 0xf6, 0x1f, 0x0f, 0x6b,
	0x04, 0x54, 0xa7, 0x30, 0xd1, 0xb1, 0x7b, 0x8b, 0x42, 0x6e, 0xe2, 0x01, 0x4c, 0x74, 0x36, 0x9d,
	0x8e, 0x1f, 0x46, 0x40, 0x28, 0xad, 0x6b, 0x06, 0xc5, 0x24, 0x91, 0xca, 0x24, 0x88, 0x45, 0x8e,
	0x35, 0xe6, 0x97, 0xea, 0x1d, 0xfb, 0x40, 0x46, 0xb2, 0xac, 0x02, 0x06, 0x67, 0xff, 0xa1, 0xa5,
	0xca, 0xce, 0xa7, 0x38, 0x01, 0xfe, 0xd2, 0x09, 0x50, 0x40, 0x5b, 0x2c, 0x85, 0x91, 0xdd, 0x4d,
	0x7f, 0x7a, 0x04, 0x53, 0xd6, 0x6b, 0x85, 0x82, 0xbd, 0x04, 0x4e, 0xb8, 0x82, 0x95, 0x4a, 0x55,
	0xe7, 0x18, 0x99, 0x4a, 0x82, 0x08, 0x4e, 0x95, 0x2f, 0x65, 0x37, 0x22, 0x48, 0xe0, 0x5c, 0xa9,
	0x5f, 0xc2, 0xe3, 0x04, 0x1b, 0xa9, 0x41, 0x2c, 0x2b, 0x94, 0x75, 0x3c, 0xaa, 0xa4, 0xb1, 0x51,
	0xe1, 0x6f, 0xcd, 0x05, 0x70, 0xfe, 0x28, 0x39, 0x1d, 0x06, 0x3d, 0xe0, 0x64, 0xe9, 0x9e, 0x70,
	0x6b, 0xd5, 0x03, 0x7f, 0x5c, 0x76, 0x7e, 0xe7, 0xfd, 0x71, 0xf9, 0xf0, 0x1d, 0x30, 0x06, 0x1a,
	0xbd, 0x39, 0x9e, 0x6f, 0x2f, 0x1d, 0x56, 0xe3, 0xfc, 0x17, 0x41, 0x50, 0xcf, 0x3a, 0xea, 0x23,
	0x44, 0x27, 0x31, 0x5d, 0xb6, 0x16, 0x06, 0xec, 0x23, 0x84, 0x19, 0x87, 0x74, 0x5b, 0xf0, 0x78,
	0x6f, 0xc8, 0x27, 0xb4, 0xcc, 0x6d, 0xf0, 0x27, 0x61, 0x43, 0x61, 0x76, 0xc9, 0x5c, 0xbc, 0xc9,
	0xcc, 0xf9, 0xdb, 0xf7, 0x0a, 0xdf, 0xdd, 0x81, 0x17, 0x40, 0x7d, 0x31, 0xc0, 0xfa, 0x5c, 0x08,
	0x71, 0x02, 0x3f, 0xb7, 0xc1, 0x37, 0x42, 0x68, 0x83, 0xf3, 0x0b, 0x2b, 0xf9, 0xf9, 0xe5, 0xc2,
	0xa3, 0x9f, 0xcc, 0xef, 0x57, 0xe1, 0xb9, 0x22, 0x3a, 0xa6, 0x6b, 0xe3, 0xca, 0x44, 0xc8, 0x2f,
	0x34, 0xcd, 0x6d, 0xf0, 0x0d, 0xf0, 0x85, 0xfc, 0xed, 0x7b, 0xf9, 0x4f, 0xb6, 0xcc, 0xd9, 0x95,
	0xdd, 0x99, 0xf9, 0xc2, 0xcf, 0xcb, 0xb0, 0xbb, 0x94, 0xc9, 0x3b, 0x8a, 0x26, 0x5b, 0xc7, 0x11,
	0x0a, 0x08, 0x6d, 0x73, 0x1b, 0x7c, 0x0b, 0x6c, 0xda, 0x83, 0xdb, 0x55, 0x0a, 0xab, 0x0f, 0xcd,
	0x6f, 0xaf, 0xc3, 0x37, 0x41, 0xd8, 0x0d, 0xda, 0x77, 0x38, 0x43, 0x3a, 0xed, 0xd3, 0xf4, 0xec,
	0x44, 0x2a, 0x14, 0x74, 0xf9, 0x99, 0x1f, 0xdf, 0xc9, 0x7f, 0xb4, 0x9e, 0x5f, 0x5a, 0xcc, 0x2f,
	0xac, 0xfc, 0xf1, 0xe3, 0xfc, 0xce, 0x83, 0x75, 0xf8, 0x06, 0x38, 0xbd, 0xc7, 0xcf, 0xbd, 0x30,
	0xfb, 0xc2, 0xab, 0xdc, 0xf0, 0xfc, 0x8d, 0xcf, 0xf3, 0xb3, 0xb7, 0x3c, 0xe1, 0x1d, 0x45, 0xce,
	0x71, 0x63, 0x10, 0x5d, 0x61, 0x42, 0x85, 0xaa, 0xdd, 0x16, 0xcd, 0xcd, 0xb5, 0xc2, 0xc3, 0x4f,
	0x77, 0xb6, 0xb6, 0x76, 0x17, 0x1f, 0x98, 0xab, 0xd7, 0xac, 0xfd, 0xe0, 0xc2, 0xed, 0x93, 0x1b,
	0xa1, 0x88, 0xd0, 0x50, 0xcd, 0x9e, 0x24, 0xb3, 0xb7, 0xf2, 0x5f, 0x7e, 0x65, 0x6e, 0xae, 0x99,
	0x8f, 0xae, 0x9a, 0x77, 0xaf, 0xc3, 0xee, 0xfd, 0x78, 0x3b, 0x7f, 0xad, 0x20, 0xcc, 0x6d, 0xf0,
	0xcd, 0xb0, 0xd1, 0xc1, 0xcf, 0xac, 0x9b, 0xf3, 0x8b, 0x8a, 0xbc, 0x7b, 0xf3, 0xeb, 0x9d, 0xfb,
	0xf7, 0x4b, 0x8b, 0x30, 0xb8, 0xf5, 0xfd, 0x88, 0xe5, 0xd0, 0xb1, 0xa2, 0xee, 0x4b, 0xe6, 0xea,
	0x35, 0x73, 0x73, 0x6d, 0xf7, 0xea, 0x37, 0xe6, 0xcc, 0x7a, 0xcf, 0xd0, 0xd3, 0xdf, 0x45, 0xdf,
	0x0f, 0x39, 0x91, 0x7b, 0x9c, 0x13, 0xb9, 0x27, 0x39, 0x91, 0xfb, 0x2d, 0x27, 0x72, 0x3b, 0x39,
	0xd1, 0xf7, 0x57, 0x4e, 0xe4, 0x3e, 0xdb, 0x16, 0x7d, 0x8f, 0xb7, 0x45, 0xee, 0xc9, 0xb6, 0xe8,
	0x7b, 0xba, 0x2d, 0xfa, 0xde, 0x0b, 0x27, 0x75, 0x45, 0xeb, 0xb0, 0xbe, 0x88, 0x31, 0xe9, 0x4c,
	0xea, 0xe9, 0xb4, 0xae, 0x75, 0x7a, 0xfe, 0xba, 0x8c, 0x55, 0xb3, 0xd7, 0xee, 0xbf, 0x03, 0x00,
	0x00, 0xff, 0xff, 0xae, 0x61, 0xe9, 0xbd, 0xd2, 0x0c, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_GetTowerRewardInfoRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_GetTowerRewardInfoResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_GetNextChallengeDataRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_GetNextChallengeDataResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerAccumulateInfoRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerAccumulateInfoResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerAccumulateHarvestRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerAccumulateHarvestResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerBattleInfoRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerBattleInfoResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerChallengeResultPrcRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerChallengeResultPrcResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerChallengeSoomCalculationRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_TowerChallengeSoomCalculationResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_CheatTowerGmSetlevelRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_CheatTowerGmSetlevelResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_CheatTowerGmRefreshMeditationTimesRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_CheatTowerGmRefreshMeditationTimesResponse.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_SingleBattleRequest.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower_SingleBattleResponse.Get().(proto.Message)
	})
}

var poolTower = &sync.Pool{New: func() interface{} { return &Tower{} }}

func (m *Tower) ReleasePool() { m.Reset(); poolTower.Put(m); m = nil }

var poolTower_GetTowerRewardInfoRequest = &sync.Pool{New: func() interface{} { return &Tower_GetTowerRewardInfoRequest{} }}

func (m *Tower_GetTowerRewardInfoRequest) ReleasePool() {
	m.Reset()
	poolTower_GetTowerRewardInfoRequest.Put(m)
	m = nil
}

var poolTower_GetTowerRewardInfoResponse = &sync.Pool{New: func() interface{} { return &Tower_GetTowerRewardInfoResponse{} }}

func (m *Tower_GetTowerRewardInfoResponse) ReleasePool() {
	m.Reset()
	poolTower_GetTowerRewardInfoResponse.Put(m)
	m = nil
}

var poolTower_GetNextChallengeDataRequest = &sync.Pool{New: func() interface{} { return &Tower_GetNextChallengeDataRequest{} }}

func (m *Tower_GetNextChallengeDataRequest) ReleasePool() {
	m.Reset()
	poolTower_GetNextChallengeDataRequest.Put(m)
	m = nil
}

var poolTower_GetNextChallengeDataResponse = &sync.Pool{New: func() interface{} { return &Tower_GetNextChallengeDataResponse{} }}

func (m *Tower_GetNextChallengeDataResponse) ReleasePool() {
	m.Reset()
	poolTower_GetNextChallengeDataResponse.Put(m)
	m = nil
}

var poolTower_TowerAccumulateInfoRequest = &sync.Pool{New: func() interface{} { return &Tower_TowerAccumulateInfoRequest{} }}

func (m *Tower_TowerAccumulateInfoRequest) ReleasePool() {
	m.Reset()
	poolTower_TowerAccumulateInfoRequest.Put(m)
	m = nil
}

var poolTower_TowerAccumulateInfoResponse = &sync.Pool{New: func() interface{} { return &Tower_TowerAccumulateInfoResponse{} }}

func (m *Tower_TowerAccumulateInfoResponse) ReleasePool() {
	m.Reset()
	poolTower_TowerAccumulateInfoResponse.Put(m)
	m = nil
}

var poolTower_TowerAccumulateHarvestRequest = &sync.Pool{New: func() interface{} { return &Tower_TowerAccumulateHarvestRequest{} }}

func (m *Tower_TowerAccumulateHarvestRequest) ReleasePool() {
	m.Reset()
	poolTower_TowerAccumulateHarvestRequest.Put(m)
	m = nil
}

var poolTower_TowerAccumulateHarvestResponse = &sync.Pool{New: func() interface{} { return &Tower_TowerAccumulateHarvestResponse{} }}

func (m *Tower_TowerAccumulateHarvestResponse) ReleasePool() {
	m.Reset()
	poolTower_TowerAccumulateHarvestResponse.Put(m)
	m = nil
}

var poolTower_TowerBattleInfoRequest = &sync.Pool{New: func() interface{} { return &Tower_TowerBattleInfoRequest{} }}

func (m *Tower_TowerBattleInfoRequest) ReleasePool() {
	m.Reset()
	poolTower_TowerBattleInfoRequest.Put(m)
	m = nil
}

var poolTower_TowerBattleInfoResponse = &sync.Pool{New: func() interface{} { return &Tower_TowerBattleInfoResponse{} }}

func (m *Tower_TowerBattleInfoResponse) ReleasePool() {
	m.Reset()
	poolTower_TowerBattleInfoResponse.Put(m)
	m = nil
}

var poolTower_TowerChallengeResultPrcRequest = &sync.Pool{New: func() interface{} { return &Tower_TowerChallengeResultPrcRequest{} }}

func (m *Tower_TowerChallengeResultPrcRequest) ReleasePool() {
	m.Reset()
	poolTower_TowerChallengeResultPrcRequest.Put(m)
	m = nil
}

var poolTower_TowerChallengeResultPrcResponse = &sync.Pool{New: func() interface{} { return &Tower_TowerChallengeResultPrcResponse{} }}

func (m *Tower_TowerChallengeResultPrcResponse) ReleasePool() {
	m.Reset()
	poolTower_TowerChallengeResultPrcResponse.Put(m)
	m = nil
}

var poolTower_TowerChallengeSoomCalculationRequest = &sync.Pool{New: func() interface{} { return &Tower_TowerChallengeSoomCalculationRequest{} }}

func (m *Tower_TowerChallengeSoomCalculationRequest) ReleasePool() {
	m.Reset()
	poolTower_TowerChallengeSoomCalculationRequest.Put(m)
	m = nil
}

var poolTower_TowerChallengeSoomCalculationResponse = &sync.Pool{New: func() interface{} { return &Tower_TowerChallengeSoomCalculationResponse{} }}

func (m *Tower_TowerChallengeSoomCalculationResponse) ReleasePool() {
	m.Reset()
	poolTower_TowerChallengeSoomCalculationResponse.Put(m)
	m = nil
}

var poolTower_CheatTowerGmSetlevelRequest = &sync.Pool{New: func() interface{} { return &Tower_CheatTowerGmSetlevelRequest{} }}

func (m *Tower_CheatTowerGmSetlevelRequest) ReleasePool() {
	m.Reset()
	poolTower_CheatTowerGmSetlevelRequest.Put(m)
	m = nil
}

var poolTower_CheatTowerGmSetlevelResponse = &sync.Pool{New: func() interface{} { return &Tower_CheatTowerGmSetlevelResponse{} }}

func (m *Tower_CheatTowerGmSetlevelResponse) ReleasePool() {
	m.Reset()
	poolTower_CheatTowerGmSetlevelResponse.Put(m)
	m = nil
}

var poolTower_CheatTowerGmRefreshMeditationTimesRequest = &sync.Pool{New: func() interface{} { return &Tower_CheatTowerGmRefreshMeditationTimesRequest{} }}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) ReleasePool() {
	m.Reset()
	poolTower_CheatTowerGmRefreshMeditationTimesRequest.Put(m)
	m = nil
}

var poolTower_CheatTowerGmRefreshMeditationTimesResponse = &sync.Pool{New: func() interface{} { return &Tower_CheatTowerGmRefreshMeditationTimesResponse{} }}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) ReleasePool() {
	m.Reset()
	poolTower_CheatTowerGmRefreshMeditationTimesResponse.Put(m)
	m = nil
}

var poolTower_SingleBattleRequest = &sync.Pool{New: func() interface{} { return &Tower_SingleBattleRequest{} }}

func (m *Tower_SingleBattleRequest) ReleasePool() {
	m.Reset()
	poolTower_SingleBattleRequest.Put(m)
	m = nil
}

var poolTower_SingleBattleResponse = &sync.Pool{New: func() interface{} { return &Tower_SingleBattleResponse{} }}

func (m *Tower_SingleBattleResponse) ReleasePool() {
	m.Reset()
	poolTower_SingleBattleResponse.Put(m)
	m = nil
}
func (x TowerErrorCode) String() string {
	s, ok := TowerErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Tower) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower)
	if !ok {
		that2, ok := that.(Tower)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Tower_GetTowerRewardInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_GetTowerRewardInfoRequest)
	if !ok {
		that2, ok := that.(Tower_GetTowerRewardInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Tower_GetTowerRewardInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_GetTowerRewardInfoResponse)
	if !ok {
		that2, ok := that.(Tower_GetTowerRewardInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.DataMap) != len(that1.DataMap) {
		return false
	}
	for i := range this.DataMap {
		if !this.DataMap[i].Equal(that1.DataMap[i]) {
			return false
		}
	}
	return true
}
func (this *Tower_GetNextChallengeDataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_GetNextChallengeDataRequest)
	if !ok {
		that2, ok := that.(Tower_GetNextChallengeDataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Tower_GetNextChallengeDataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_GetNextChallengeDataResponse)
	if !ok {
		that2, ok := that.(Tower_GetNextChallengeDataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *Tower_TowerAccumulateInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerAccumulateInfoRequest)
	if !ok {
		that2, ok := that.(Tower_TowerAccumulateInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Tower_TowerAccumulateInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerAccumulateInfoResponse)
	if !ok {
		that2, ok := that.(Tower_TowerAccumulateInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *Tower_TowerAccumulateHarvestRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerAccumulateHarvestRequest)
	if !ok {
		that2, ok := that.(Tower_TowerAccumulateHarvestRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.HarvestType != that1.HarvestType {
		return false
	}
	return true
}
func (this *Tower_TowerAccumulateHarvestResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerAccumulateHarvestResponse)
	if !ok {
		that2, ok := that.(Tower_TowerAccumulateHarvestResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Rewards) != len(that1.Rewards) {
		return false
	}
	for i := range this.Rewards {
		if !this.Rewards[i].Equal(that1.Rewards[i]) {
			return false
		}
	}
	return true
}
func (this *Tower_TowerBattleInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerBattleInfoRequest)
	if !ok {
		that2, ok := that.(Tower_TowerBattleInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.CurrentTowerLevel != that1.CurrentTowerLevel {
		return false
	}
	if this.BattleId != that1.BattleId {
		return false
	}
	return true
}
func (this *Tower_TowerBattleInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerBattleInfoResponse)
	if !ok {
		that2, ok := that.(Tower_TowerBattleInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if this.CurrentTowerLevel != that1.CurrentTowerLevel {
		return false
	}
	if this.BattleId != that1.BattleId {
		return false
	}
	return true
}
func (this *Tower_TowerChallengeResultPrcRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerChallengeResultPrcRequest)
	if !ok {
		that2, ok := that.(Tower_TowerChallengeResultPrcRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.WinType != that1.WinType {
		return false
	}
	if this.PassLevel != that1.PassLevel {
		return false
	}
	if this.IsWin != that1.IsWin {
		return false
	}
	return true
}
func (this *Tower_TowerChallengeResultPrcResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerChallengeResultPrcResponse)
	if !ok {
		that2, ok := that.(Tower_TowerChallengeResultPrcResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Rewards) != len(that1.Rewards) {
		return false
	}
	for i := range this.Rewards {
		if !this.Rewards[i].Equal(that1.Rewards[i]) {
			return false
		}
	}
	if this.WinType != that1.WinType {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *Tower_TowerChallengeSoomCalculationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerChallengeSoomCalculationRequest)
	if !ok {
		that2, ok := that.(Tower_TowerChallengeSoomCalculationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.CurrentTowerLevel != that1.CurrentTowerLevel {
		return false
	}
	if len(this.Heroes) != len(that1.Heroes) {
		return false
	}
	for i := range this.Heroes {
		if !this.Heroes[i].Equal(that1.Heroes[i]) {
			return false
		}
	}
	if this.MonsterHpRatio != that1.MonsterHpRatio {
		return false
	}
	return true
}
func (this *Tower_TowerChallengeSoomCalculationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_TowerChallengeSoomCalculationResponse)
	if !ok {
		that2, ok := that.(Tower_TowerChallengeSoomCalculationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.IsWin != that1.IsWin {
		return false
	}
	return true
}
func (this *Tower_CheatTowerGmSetlevelRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_CheatTowerGmSetlevelRequest)
	if !ok {
		that2, ok := that.(Tower_CheatTowerGmSetlevelRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.CurrentLevel != that1.CurrentLevel {
		return false
	}
	return true
}
func (this *Tower_CheatTowerGmSetlevelResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_CheatTowerGmSetlevelResponse)
	if !ok {
		that2, ok := that.(Tower_CheatTowerGmSetlevelResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Tower_CheatTowerGmRefreshMeditationTimesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_CheatTowerGmRefreshMeditationTimesRequest)
	if !ok {
		that2, ok := that.(Tower_CheatTowerGmRefreshMeditationTimesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Tower_CheatTowerGmRefreshMeditationTimesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_CheatTowerGmRefreshMeditationTimesResponse)
	if !ok {
		that2, ok := that.(Tower_CheatTowerGmRefreshMeditationTimesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Tower_SingleBattleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_SingleBattleRequest)
	if !ok {
		that2, ok := that.(Tower_SingleBattleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.BattleId != that1.BattleId {
		return false
	}
	return true
}
func (this *Tower_SingleBattleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower_SingleBattleResponse)
	if !ok {
		that2, ok := that.(Tower_SingleBattleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if this.BattleId != that1.BattleId {
		return false
	}
	return true
}
func (m *Tower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Tower_GetTowerRewardInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_GetTowerRewardInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_GetTowerRewardInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_GetTowerRewardInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_GetTowerRewardInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_GetTowerRewardInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k := range m.DataMap {
			v := m.DataMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTower(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTower(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTower(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_GetNextChallengeDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_GetNextChallengeDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_GetNextChallengeDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_GetNextChallengeDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_GetNextChallengeDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_GetNextChallengeDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerAccumulateInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerAccumulateInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerAccumulateInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerAccumulateInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerAccumulateInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerAccumulateInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerAccumulateHarvestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerAccumulateHarvestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerAccumulateHarvestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HarvestType != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.HarvestType))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerAccumulateHarvestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerAccumulateHarvestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerAccumulateHarvestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTower(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerBattleInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerBattleInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerBattleInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BattleId != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.BattleId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.CurrentTowerLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentTowerLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerBattleInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerBattleInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerBattleInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BattleId != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.BattleId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.CurrentTowerLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentTowerLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerChallengeResultPrcRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerChallengeResultPrcRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerChallengeResultPrcRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsWin {
		i--
		if m.IsWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PassLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.PassLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.WinType != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.WinType))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerChallengeResultPrcResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerChallengeResultPrcResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerChallengeResultPrcResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.WinType != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.WinType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTower(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerChallengeSoomCalculationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerChallengeSoomCalculationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerChallengeSoomCalculationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonsterHpRatio != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MonsterHpRatio))))
		i--
		dAtA[i] = 0x25
	}
	if len(m.Heroes) > 0 {
		for iNdEx := len(m.Heroes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Heroes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTower(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CurrentTowerLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentTowerLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_TowerChallengeSoomCalculationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_TowerChallengeSoomCalculationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_TowerChallengeSoomCalculationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsWin {
		i--
		if m.IsWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_CheatTowerGmSetlevelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_CheatTowerGmSetlevelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_CheatTowerGmSetlevelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_CheatTowerGmSetlevelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_CheatTowerGmSetlevelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_CheatTowerGmSetlevelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Tower_SingleBattleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_SingleBattleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_SingleBattleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BattleId != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.BattleId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Id != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tower_SingleBattleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower_SingleBattleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower_SingleBattleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BattleId != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.BattleId))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTower(dAtA []byte, offset int, v uint64) int {
	offset -= sovTower(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *Tower) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	w.RawByte('}')

}

func (m *Tower_GetTowerRewardInfoRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_GetTowerRewardInfoResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("data_map")
	w.RawByte('"')
	w.RawByte(':')
	if m.DataMap == nil {
		w.RawString("null")
	} else if len(m.DataMap) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDataMap := len(m.DataMap)
		for k, v := range m.DataMap {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlDataMap--
			if mlDataMap != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_GetNextChallengeDataRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_GetNextChallengeDataResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("data")
	w.RawByte('"')
	w.RawByte(':')
	m.Data.JsonBytes(w)
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerAccumulateInfoRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerAccumulateInfoResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("info")
	w.RawByte('"')
	w.RawByte(':')
	m.Info.JsonBytes(w)
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerAccumulateHarvestRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.HarvestType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("harvest_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.HarvestType))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerAccumulateHarvestResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("info")
	w.RawByte('"')
	w.RawByte(':')
	m.Info.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("rewards")
	w.RawByte('"')
	w.RawByte(':')
	if m.Rewards == nil {
		w.RawString("null")
	} else if len(m.Rewards) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Rewards {
			v.JsonBytes(w)
			if i != len(m.Rewards)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerBattleInfoRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.CurrentTowerLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("current_tower_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurrentTowerLevel))
		needWriteComma = true
	}
	if m.BattleId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerBattleInfoResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("data")
	w.RawByte('"')
	w.RawByte(':')
	m.Data.JsonBytes(w)
	needWriteComma = true
	if m.CurrentTowerLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("current_tower_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurrentTowerLevel))
		needWriteComma = true
	}
	if m.BattleId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerChallengeResultPrcRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.WinType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("win_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.WinType))
		needWriteComma = true
	}
	if m.PassLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("pass_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PassLevel))
		needWriteComma = true
	}
	if m.IsWin {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_win")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsWin)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerChallengeResultPrcResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("rewards")
	w.RawByte('"')
	w.RawByte(':')
	if m.Rewards == nil {
		w.RawString("null")
	} else if len(m.Rewards) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Rewards {
			v.JsonBytes(w)
			if i != len(m.Rewards)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.WinType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("win_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.WinType))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("data")
	w.RawByte('"')
	w.RawByte(':')
	m.Data.JsonBytes(w)
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerChallengeSoomCalculationRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.CurrentTowerLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("current_tower_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurrentTowerLevel))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("heroes")
	w.RawByte('"')
	w.RawByte(':')
	if m.Heroes == nil {
		w.RawString("null")
	} else if len(m.Heroes) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Heroes {
			v.JsonBytes(w)
			if i != len(m.Heroes)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if math.Abs(float64(m.MonsterHpRatio)) > 0.000001 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("monster_hp_ratio")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.MonsterHpRatio))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_TowerChallengeSoomCalculationResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.IsWin {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_win")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsWin)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_CheatTowerGmSetlevelRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.CurrentLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("current_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurrentLevel))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_CheatTowerGmSetlevelResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	w.RawByte('}')

}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	w.RawByte('}')

}

func (m *Tower_SingleBattleRequest) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.BattleId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower_SingleBattleResponse) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("data")
	w.RawByte('"')
	w.RawByte(':')
	m.Data.JsonBytes(w)
	needWriteComma = true
	if m.BattleId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower) GoString() string {
	return m.String()
}

func (m *Tower_GetTowerRewardInfoRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_GetTowerRewardInfoRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_GetTowerRewardInfoRequest) GoString() string {
	return m.String()
}

func (m *Tower_GetTowerRewardInfoResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_GetTowerRewardInfoResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_GetTowerRewardInfoResponse) GoString() string {
	return m.String()
}

func (m *Tower_GetNextChallengeDataRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_GetNextChallengeDataRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_GetNextChallengeDataRequest) GoString() string {
	return m.String()
}

func (m *Tower_GetNextChallengeDataResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_GetNextChallengeDataResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_GetNextChallengeDataResponse) GoString() string {
	return m.String()
}

func (m *Tower_TowerAccumulateInfoRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerAccumulateInfoRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerAccumulateInfoRequest) GoString() string {
	return m.String()
}

func (m *Tower_TowerAccumulateInfoResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerAccumulateInfoResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerAccumulateInfoResponse) GoString() string {
	return m.String()
}

func (m *Tower_TowerAccumulateHarvestRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerAccumulateHarvestRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerAccumulateHarvestRequest) GoString() string {
	return m.String()
}

func (m *Tower_TowerAccumulateHarvestResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerAccumulateHarvestResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerAccumulateHarvestResponse) GoString() string {
	return m.String()
}

func (m *Tower_TowerBattleInfoRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerBattleInfoRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerBattleInfoRequest) GoString() string {
	return m.String()
}

func (m *Tower_TowerBattleInfoResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerBattleInfoResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerBattleInfoResponse) GoString() string {
	return m.String()
}

func (m *Tower_TowerChallengeResultPrcRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerChallengeResultPrcRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerChallengeResultPrcRequest) GoString() string {
	return m.String()
}

func (m *Tower_TowerChallengeResultPrcResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerChallengeResultPrcResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerChallengeResultPrcResponse) GoString() string {
	return m.String()
}

func (m *Tower_TowerChallengeSoomCalculationRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerChallengeSoomCalculationRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerChallengeSoomCalculationRequest) GoString() string {
	return m.String()
}

func (m *Tower_TowerChallengeSoomCalculationResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_TowerChallengeSoomCalculationResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_TowerChallengeSoomCalculationResponse) GoString() string {
	return m.String()
}

func (m *Tower_CheatTowerGmSetlevelRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_CheatTowerGmSetlevelRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_CheatTowerGmSetlevelRequest) GoString() string {
	return m.String()
}

func (m *Tower_CheatTowerGmSetlevelResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_CheatTowerGmSetlevelResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_CheatTowerGmSetlevelResponse) GoString() string {
	return m.String()
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) GoString() string {
	return m.String()
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) GoString() string {
	return m.String()
}

func (m *Tower_SingleBattleRequest) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_SingleBattleRequest) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_SingleBattleRequest) GoString() string {
	return m.String()
}

func (m *Tower_SingleBattleResponse) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower_SingleBattleResponse) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower_SingleBattleResponse) GoString() string {
	return m.String()
}

func (m *Tower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Tower_GetTowerRewardInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	return n
}

func (m *Tower_GetTowerRewardInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if len(m.DataMap) > 0 {
		for k, v := range m.DataMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTower(uint64(l))
			}
			mapEntrySize := 1 + sovTower(uint64(k)) + l
			n += mapEntrySize + 1 + sovTower(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Tower_GetNextChallengeDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	return n
}

func (m *Tower_GetNextChallengeDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	return n
}

func (m *Tower_TowerAccumulateInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	return n
}

func (m *Tower_TowerAccumulateInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	return n
}

func (m *Tower_TowerAccumulateHarvestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.HarvestType != 0 {
		n += 1 + sovTower(uint64(m.HarvestType))
	}
	return n
}

func (m *Tower_TowerAccumulateHarvestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	return n
}

func (m *Tower_TowerBattleInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.CurrentTowerLevel != 0 {
		n += 1 + sovTower(uint64(m.CurrentTowerLevel))
	}
	if m.BattleId != 0 {
		n += 2 + sovTower(uint64(m.BattleId))
	}
	return n
}

func (m *Tower_TowerBattleInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.CurrentTowerLevel != 0 {
		n += 1 + sovTower(uint64(m.CurrentTowerLevel))
	}
	if m.BattleId != 0 {
		n += 2 + sovTower(uint64(m.BattleId))
	}
	return n
}

func (m *Tower_TowerChallengeResultPrcRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.WinType != 0 {
		n += 1 + sovTower(uint64(m.WinType))
	}
	if m.PassLevel != 0 {
		n += 1 + sovTower(uint64(m.PassLevel))
	}
	if m.IsWin {
		n += 2
	}
	return n
}

func (m *Tower_TowerChallengeResultPrcResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.WinType != 0 {
		n += 1 + sovTower(uint64(m.WinType))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	return n
}

func (m *Tower_TowerChallengeSoomCalculationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.CurrentTowerLevel != 0 {
		n += 1 + sovTower(uint64(m.CurrentTowerLevel))
	}
	if len(m.Heroes) > 0 {
		for _, e := range m.Heroes {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.MonsterHpRatio != 0 {
		n += 5
	}
	return n
}

func (m *Tower_TowerChallengeSoomCalculationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.IsWin {
		n += 2
	}
	return n
}

func (m *Tower_CheatTowerGmSetlevelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.CurrentLevel != 0 {
		n += 1 + sovTower(uint64(m.CurrentLevel))
	}
	return n
}

func (m *Tower_CheatTowerGmSetlevelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	return n
}

func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Tower_SingleBattleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTower(uint64(m.Id))
	}
	if m.BattleId != 0 {
		n += 2 + sovTower(uint64(m.BattleId))
	}
	return n
}

func (m *Tower_SingleBattleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.BattleId != 0 {
		n += 2 + sovTower(uint64(m.BattleId))
	}
	return n
}

func sovTower(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTower(x uint64) (n int) {
	return sovTower(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_GetTowerRewardInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTowerRewardInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTowerRewardInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_GetTowerRewardInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTowerRewardInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTowerRewardInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMap == nil {
				m.DataMap = make(map[int64]*models.TowerPassData)
			}
			var mapkey int64
			var mapvalue *models.TowerPassData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTower
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTower
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &models.TowerPassData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTower(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTower
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_GetNextChallengeDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNextChallengeDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNextChallengeDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_GetNextChallengeDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNextChallengeDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNextChallengeDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &models.Tower{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerAccumulateInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerAccumulateInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerAccumulateInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerAccumulateInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerAccumulateInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerAccumulateInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &models.TowerAccumulateHarvestInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerAccumulateHarvestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerAccumulateHarvestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerAccumulateHarvestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HarvestType", wireType)
			}
			m.HarvestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HarvestType |= models.AccumulateHarvestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerAccumulateHarvestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerAccumulateHarvestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerAccumulateHarvestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &models.TowerAccumulateHarvestInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &models.Item{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerBattleInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerBattleInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerBattleInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTowerLevel", wireType)
			}
			m.CurrentTowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTowerLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleId", wireType)
			}
			m.BattleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerBattleInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerBattleInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerBattleInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &models.SingleBattleParam{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTowerLevel", wireType)
			}
			m.CurrentTowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTowerLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleId", wireType)
			}
			m.BattleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerChallengeResultPrcRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerChallengeResultPrcRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerChallengeResultPrcRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinType", wireType)
			}
			m.WinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinType |= models.TowerWinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassLevel", wireType)
			}
			m.PassLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerChallengeResultPrcResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerChallengeResultPrcResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerChallengeResultPrcResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &models.Item{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinType", wireType)
			}
			m.WinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinType |= models.TowerWinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &models.Tower{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerChallengeSoomCalculationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerChallengeSoomCalculationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerChallengeSoomCalculationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTowerLevel", wireType)
			}
			m.CurrentTowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTowerLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heroes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heroes = append(m.Heroes, &models.HeroInfo{})
			if err := m.Heroes[len(m.Heroes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterHpRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MonsterHpRatio = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_TowerChallengeSoomCalculationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerChallengeSoomCalculationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerChallengeSoomCalculationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_CheatTowerGmSetlevelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheatTowerGmSetlevelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheatTowerGmSetlevelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLevel", wireType)
			}
			m.CurrentLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_CheatTowerGmSetlevelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheatTowerGmSetlevelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheatTowerGmSetlevelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheatTowerGmRefreshMeditationTimesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheatTowerGmRefreshMeditationTimesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= models.TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_CheatTowerGmRefreshMeditationTimesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheatTowerGmRefreshMeditationTimesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheatTowerGmRefreshMeditationTimesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_SingleBattleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleBattleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleBattleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleId", wireType)
			}
			m.BattleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower_SingleBattleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleBattleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleBattleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &models.SingleBattleParam{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleId", wireType)
			}
			m.BattleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTower(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTower
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTower
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTower
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTower
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTower
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTower
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTower        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTower          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTower = fmt.Errorf("proto: unexpected end of group")
)
