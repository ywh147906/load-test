// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/models/battle.proto

package models

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/protobuf/types/descriptorpb"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BattleType int32

const (
	BattleType_Unknown_  BattleType = 0
	BattleType_City      BattleType = 1
	BattleType_HangUp    BattleType = 2
	BattleType_Copy      BattleType = 3
	BattleType_Roguelike BattleType = 4
	BattleType_UnionBoss BattleType = 5
	BattleType_BossHall  BattleType = 6
	BattleType_Single    BattleType = 9999
	BattleType_CutScene  BattleType = 10000
)

var BattleType_name = map[int32]string{
	0:     "Unknown_",
	1:     "City",
	2:     "HangUp",
	3:     "Copy",
	4:     "Roguelike",
	5:     "UnionBoss",
	6:     "BossHall",
	9999:  "Single",
	10000: "CutScene",
}

var BattleType_value = map[string]int32{
	"Unknown_":  0,
	"City":      1,
	"HangUp":    2,
	"Copy":      3,
	"Roguelike": 4,
	"UnionBoss": 5,
	"BossHall":  6,
	"Single":    9999,
	"CutScene":  10000,
}

func (BattleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{0}
}

type Vec2 struct {
	X float32 `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y float32 `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Vec2) Reset()      { *m = Vec2{} }
func (*Vec2) ProtoMessage() {}
func (*Vec2) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{0}
}
func (m *Vec2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vec2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vec2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vec2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vec2.Merge(m, src)
}
func (m *Vec2) XXX_Size() int {
	return m.Size()
}
func (m *Vec2) XXX_DiscardUnknown() {
	xxx_messageInfo_Vec2.DiscardUnknown(m)
}

var xxx_messageInfo_Vec2 proto.InternalMessageInfo

func (m *Vec2) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Vec2) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (*Vec2) XXX_MessageName() string {
	return "models.Vec2"
}

type PosAndDir struct {
	Pos *Vec2   `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`
	Dir float32 `protobuf:"fixed32,2,opt,name=dir,proto3" json:"dir,omitempty"`
}

func (m *PosAndDir) Reset()      { *m = PosAndDir{} }
func (*PosAndDir) ProtoMessage() {}
func (*PosAndDir) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{1}
}
func (m *PosAndDir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PosAndDir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PosAndDir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PosAndDir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PosAndDir.Merge(m, src)
}
func (m *PosAndDir) XXX_Size() int {
	return m.Size()
}
func (m *PosAndDir) XXX_DiscardUnknown() {
	xxx_messageInfo_PosAndDir.DiscardUnknown(m)
}

var xxx_messageInfo_PosAndDir proto.InternalMessageInfo

func (m *PosAndDir) GetPos() *Vec2 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *PosAndDir) GetDir() float32 {
	if m != nil {
		return m.Dir
	}
	return 0
}

func (*PosAndDir) XXX_MessageName() string {
	return "models.PosAndDir"
}

type HeroAttrInfo struct {
	ConfigId int64           `protobuf:"varint,1,opt,name=config_id,json=configId,proto3" json:"config_id,omitempty"`
	Attr     map[int64]int64 `protobuf:"bytes,2,rep,name=attr,proto3" json:"attr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *HeroAttrInfo) Reset()      { *m = HeroAttrInfo{} }
func (*HeroAttrInfo) ProtoMessage() {}
func (*HeroAttrInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{2}
}
func (m *HeroAttrInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeroAttrInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeroAttrInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeroAttrInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeroAttrInfo.Merge(m, src)
}
func (m *HeroAttrInfo) XXX_Size() int {
	return m.Size()
}
func (m *HeroAttrInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HeroAttrInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HeroAttrInfo proto.InternalMessageInfo

func (m *HeroAttrInfo) GetConfigId() int64 {
	if m != nil {
		return m.ConfigId
	}
	return 0
}

func (m *HeroAttrInfo) GetAttr() map[int64]int64 {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (*HeroAttrInfo) XXX_MessageName() string {
	return "models.HeroAttrInfo"
}

type HeroForBattle struct {
	ConfigId         int64                `protobuf:"varint,1,opt,name=config_id,json=configId,proto3" json:"config_id,omitempty"`
	Attr             map[int64]int64      `protobuf:"bytes,2,rep,name=attr,proto3" json:"attr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Equip            map[int64]int64      `protobuf:"bytes,3,rep,name=equip,proto3" json:"equip,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	HeroStatus       int64                `protobuf:"varint,4,opt,name=hero_status,json=heroStatus,proto3" json:"hero_status,omitempty"`
	SkillIds         []*HeroSkillAndStone `protobuf:"bytes,5,rep,name=skill_ids,json=skillIds,proto3" json:"skill_ids,omitempty"`
	BuffIds          []int64              `protobuf:"varint,6,rep,packed,name=buff_ids,json=buffIds,proto3" json:"buff_ids,omitempty"`
	TalentBuff       []int64              `protobuf:"varint,7,rep,packed,name=talent_buff,json=talentBuff,proto3" json:"talent_buff,omitempty"`
	EquipLightEffect map[int64]int64      `protobuf:"bytes,8,rep,name=equip_light_effect,json=equipLightEffect,proto3" json:"equip_light_effect,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Fashion          int64                `protobuf:"varint,9,opt,name=fashion,proto3" json:"fashion,omitempty"`
}

func (m *HeroForBattle) Reset()      { *m = HeroForBattle{} }
func (*HeroForBattle) ProtoMessage() {}
func (*HeroForBattle) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{3}
}
func (m *HeroForBattle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeroForBattle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeroForBattle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeroForBattle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeroForBattle.Merge(m, src)
}
func (m *HeroForBattle) XXX_Size() int {
	return m.Size()
}
func (m *HeroForBattle) XXX_DiscardUnknown() {
	xxx_messageInfo_HeroForBattle.DiscardUnknown(m)
}

var xxx_messageInfo_HeroForBattle proto.InternalMessageInfo

func (m *HeroForBattle) GetConfigId() int64 {
	if m != nil {
		return m.ConfigId
	}
	return 0
}

func (m *HeroForBattle) GetAttr() map[int64]int64 {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *HeroForBattle) GetEquip() map[int64]int64 {
	if m != nil {
		return m.Equip
	}
	return nil
}

func (m *HeroForBattle) GetHeroStatus() int64 {
	if m != nil {
		return m.HeroStatus
	}
	return 0
}

func (m *HeroForBattle) GetSkillIds() []*HeroSkillAndStone {
	if m != nil {
		return m.SkillIds
	}
	return nil
}

func (m *HeroForBattle) GetBuffIds() []int64 {
	if m != nil {
		return m.BuffIds
	}
	return nil
}

func (m *HeroForBattle) GetTalentBuff() []int64 {
	if m != nil {
		return m.TalentBuff
	}
	return nil
}

func (m *HeroForBattle) GetEquipLightEffect() map[int64]int64 {
	if m != nil {
		return m.EquipLightEffect
	}
	return nil
}

func (m *HeroForBattle) GetFashion() int64 {
	if m != nil {
		return m.Fashion
	}
	return 0
}

func (*HeroForBattle) XXX_MessageName() string {
	return "models.HeroForBattle"
}

type MedicineInfo struct {
	CdTime   int64 `protobuf:"varint,1,opt,name=cd_time,json=cdTime,proto3" json:"cd_time,omitempty"`
	Open     int64 `protobuf:"varint,2,opt,name=open,proto3" json:"open,omitempty"`
	AutoTake int64 `protobuf:"varint,3,opt,name=auto_take,json=autoTake,proto3" json:"auto_take,omitempty"`
}

func (m *MedicineInfo) Reset()      { *m = MedicineInfo{} }
func (*MedicineInfo) ProtoMessage() {}
func (*MedicineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{4}
}
func (m *MedicineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MedicineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MedicineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MedicineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MedicineInfo.Merge(m, src)
}
func (m *MedicineInfo) XXX_Size() int {
	return m.Size()
}
func (m *MedicineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MedicineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MedicineInfo proto.InternalMessageInfo

func (m *MedicineInfo) GetCdTime() int64 {
	if m != nil {
		return m.CdTime
	}
	return 0
}

func (m *MedicineInfo) GetOpen() int64 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *MedicineInfo) GetAutoTake() int64 {
	if m != nil {
		return m.AutoTake
	}
	return 0
}

func (*MedicineInfo) XXX_MessageName() string {
	return "models.MedicineInfo"
}

// 挂机临时背包
type TempBag struct {
	StartTime    int64           `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	KillMonster  int64           `protobuf:"varint,2,opt,name=kill_monster,json=killMonster,proto3" json:"kill_monster,omitempty"`
	KillBoss     int64           `protobuf:"varint,3,opt,name=kill_boss,json=killBoss,proto3" json:"kill_boss,omitempty"`
	TakeMedicine int64           `protobuf:"varint,4,opt,name=take_medicine,json=takeMedicine,proto3" json:"take_medicine,omitempty"`
	DeadCount    int64           `protobuf:"varint,5,opt,name=dead_count,json=deadCount,proto3" json:"dead_count,omitempty"`
	Items        map[int64]int64 `protobuf:"bytes,6,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ExpProfit    float64         `protobuf:"fixed64,10,opt,name=exp_profit,json=expProfit,proto3" json:"exp_profit,omitempty"`
}

func (m *TempBag) Reset()      { *m = TempBag{} }
func (*TempBag) ProtoMessage() {}
func (*TempBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{5}
}
func (m *TempBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TempBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TempBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TempBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TempBag.Merge(m, src)
}
func (m *TempBag) XXX_Size() int {
	return m.Size()
}
func (m *TempBag) XXX_DiscardUnknown() {
	xxx_messageInfo_TempBag.DiscardUnknown(m)
}

var xxx_messageInfo_TempBag proto.InternalMessageInfo

func (m *TempBag) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *TempBag) GetKillMonster() int64 {
	if m != nil {
		return m.KillMonster
	}
	return 0
}

func (m *TempBag) GetKillBoss() int64 {
	if m != nil {
		return m.KillBoss
	}
	return 0
}

func (m *TempBag) GetTakeMedicine() int64 {
	if m != nil {
		return m.TakeMedicine
	}
	return 0
}

func (m *TempBag) GetDeadCount() int64 {
	if m != nil {
		return m.DeadCount
	}
	return 0
}

func (m *TempBag) GetItems() map[int64]int64 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *TempBag) GetExpProfit() float64 {
	if m != nil {
		return m.ExpProfit
	}
	return 0
}

func (*TempBag) XXX_MessageName() string {
	return "models.TempBag"
}

type RoleTempBag struct {
	RoleId  string   `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	TempBag *TempBag `protobuf:"bytes,2,opt,name=temp_bag,json=tempBag,proto3" json:"temp_bag,omitempty"`
	MapId   int64    `protobuf:"varint,3,opt,name=map_id,json=mapId,proto3" json:"map_id,omitempty"`
}

func (m *RoleTempBag) Reset()      { *m = RoleTempBag{} }
func (*RoleTempBag) ProtoMessage() {}
func (*RoleTempBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{6}
}
func (m *RoleTempBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleTempBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleTempBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleTempBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleTempBag.Merge(m, src)
}
func (m *RoleTempBag) XXX_Size() int {
	return m.Size()
}
func (m *RoleTempBag) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleTempBag.DiscardUnknown(m)
}

var xxx_messageInfo_RoleTempBag proto.InternalMessageInfo

func (m *RoleTempBag) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *RoleTempBag) GetTempBag() *TempBag {
	if m != nil {
		return m.TempBag
	}
	return nil
}

func (m *RoleTempBag) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (*RoleTempBag) XXX_MessageName() string {
	return "models.RoleTempBag"
}

type SinglePlayerInfo struct {
	Role   *Role            `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	Heroes []*HeroForBattle `protobuf:"bytes,2,rep,name=heroes,proto3" json:"heroes,omitempty"`
	Buffs  []*BuffInfo      `protobuf:"bytes,3,rep,name=buffs,proto3" json:"buffs,omitempty"`
}

func (m *SinglePlayerInfo) Reset()      { *m = SinglePlayerInfo{} }
func (*SinglePlayerInfo) ProtoMessage() {}
func (*SinglePlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{7}
}
func (m *SinglePlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SinglePlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SinglePlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SinglePlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SinglePlayerInfo.Merge(m, src)
}
func (m *SinglePlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *SinglePlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SinglePlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SinglePlayerInfo proto.InternalMessageInfo

func (m *SinglePlayerInfo) GetRole() *Role {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *SinglePlayerInfo) GetHeroes() []*HeroForBattle {
	if m != nil {
		return m.Heroes
	}
	return nil
}

func (m *SinglePlayerInfo) GetBuffs() []*BuffInfo {
	if m != nil {
		return m.Buffs
	}
	return nil
}

func (*SinglePlayerInfo) XXX_MessageName() string {
	return "models.SinglePlayerInfo"
}

type BuffInfo struct {
	BuffId  int64 `protobuf:"varint,1,opt,name=buff_id,json=buffId,proto3" json:"buff_id,omitempty"`
	Overlay int32 `protobuf:"varint,2,opt,name=overlay,proto3" json:"overlay,omitempty"`
}

func (m *BuffInfo) Reset()      { *m = BuffInfo{} }
func (*BuffInfo) ProtoMessage() {}
func (*BuffInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{8}
}
func (m *BuffInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuffInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuffInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuffInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuffInfo.Merge(m, src)
}
func (m *BuffInfo) XXX_Size() int {
	return m.Size()
}
func (m *BuffInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BuffInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BuffInfo proto.InternalMessageInfo

func (m *BuffInfo) GetBuffId() int64 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *BuffInfo) GetOverlay() int32 {
	if m != nil {
		return m.Overlay
	}
	return 0
}

func (*BuffInfo) XXX_MessageName() string {
	return "models.BuffInfo"
}

type MonsterInfo struct {
	MonsterId int64           `protobuf:"varint,1,opt,name=monster_id,json=monsterId,proto3" json:"monster_id,omitempty"`
	Attr      map[int64]int64 `protobuf:"bytes,2,rep,name=attr,proto3" json:"attr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AreaId    int64           `protobuf:"varint,3,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
}

func (m *MonsterInfo) Reset()      { *m = MonsterInfo{} }
func (*MonsterInfo) ProtoMessage() {}
func (*MonsterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{9}
}
func (m *MonsterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonsterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonsterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonsterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonsterInfo.Merge(m, src)
}
func (m *MonsterInfo) XXX_Size() int {
	return m.Size()
}
func (m *MonsterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MonsterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MonsterInfo proto.InternalMessageInfo

func (m *MonsterInfo) GetMonsterId() int64 {
	if m != nil {
		return m.MonsterId
	}
	return 0
}

func (m *MonsterInfo) GetAttr() map[int64]int64 {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *MonsterInfo) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (*MonsterInfo) XXX_MessageName() string {
	return "models.MonsterInfo"
}

type SingleBattleParam struct {
	Role             *Role                   `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	Heroes           []*HeroForBattle        `protobuf:"bytes,2,rep,name=heroes,proto3" json:"heroes,omitempty"`
	Medicine         map[int64]*MedicineInfo `protobuf:"bytes,3,rep,name=medicine,proto3" json:"medicine,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MonsterGroupInfo map[int64]int64         `protobuf:"bytes,4,rep,name=monster_group_info,json=monsterGroupInfo,proto3" json:"monster_group_info,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CountDown        int64                   `protobuf:"varint,5,opt,name=count_down,json=countDown,proto3" json:"count_down,omitempty"`
	HostilePlayers   []*SinglePlayerInfo     `protobuf:"bytes,6,rep,name=hostile_players,json=hostilePlayers,proto3" json:"hostile_players,omitempty"`
	Pad              *PosAndDir              `protobuf:"bytes,7,opt,name=pad,proto3" json:"pad,omitempty"`
	OwnBuffs         []*BuffInfo             `protobuf:"bytes,8,rep,name=own_buffs,json=ownBuffs,proto3" json:"own_buffs,omitempty"`
	MonsterBuffs     []*BuffInfo             `protobuf:"bytes,9,rep,name=monster_buffs,json=monsterBuffs,proto3" json:"monster_buffs,omitempty"`
	Monsters         []*MonsterInfo          `protobuf:"bytes,10,rep,name=monsters,proto3" json:"monsters,omitempty"`
	AutoSoulSkill    int64                   `protobuf:"varint,11,opt,name=auto_soul_skill,json=autoSoulSkill,proto3" json:"auto_soul_skill,omitempty"`
}

func (m *SingleBattleParam) Reset()      { *m = SingleBattleParam{} }
func (*SingleBattleParam) ProtoMessage() {}
func (*SingleBattleParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{10}
}
func (m *SingleBattleParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleBattleParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleBattleParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleBattleParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleBattleParam.Merge(m, src)
}
func (m *SingleBattleParam) XXX_Size() int {
	return m.Size()
}
func (m *SingleBattleParam) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleBattleParam.DiscardUnknown(m)
}

var xxx_messageInfo_SingleBattleParam proto.InternalMessageInfo

func (m *SingleBattleParam) GetRole() *Role {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *SingleBattleParam) GetHeroes() []*HeroForBattle {
	if m != nil {
		return m.Heroes
	}
	return nil
}

func (m *SingleBattleParam) GetMedicine() map[int64]*MedicineInfo {
	if m != nil {
		return m.Medicine
	}
	return nil
}

func (m *SingleBattleParam) GetMonsterGroupInfo() map[int64]int64 {
	if m != nil {
		return m.MonsterGroupInfo
	}
	return nil
}

func (m *SingleBattleParam) GetCountDown() int64 {
	if m != nil {
		return m.CountDown
	}
	return 0
}

func (m *SingleBattleParam) GetHostilePlayers() []*SinglePlayerInfo {
	if m != nil {
		return m.HostilePlayers
	}
	return nil
}

func (m *SingleBattleParam) GetPad() *PosAndDir {
	if m != nil {
		return m.Pad
	}
	return nil
}

func (m *SingleBattleParam) GetOwnBuffs() []*BuffInfo {
	if m != nil {
		return m.OwnBuffs
	}
	return nil
}

func (m *SingleBattleParam) GetMonsterBuffs() []*BuffInfo {
	if m != nil {
		return m.MonsterBuffs
	}
	return nil
}

func (m *SingleBattleParam) GetMonsters() []*MonsterInfo {
	if m != nil {
		return m.Monsters
	}
	return nil
}

func (m *SingleBattleParam) GetAutoSoulSkill() int64 {
	if m != nil {
		return m.AutoSoulSkill
	}
	return 0
}

func (*SingleBattleParam) XXX_MessageName() string {
	return "models.SingleBattleParam"
}

type GmSingleBattleMonsterParam struct {
	MonsterId int64       `protobuf:"varint,1,opt,name=monster_id,json=monsterId,proto3" json:"monster_id,omitempty"`
	Pos       *Vec2       `protobuf:"bytes,2,opt,name=pos,proto3" json:"pos,omitempty"`
	Id        string      `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	ToWard    *Vec2       `protobuf:"bytes,4,opt,name=to_ward,json=toWard,proto3" json:"to_ward,omitempty"`
	AddBuffs  []*BuffInfo `protobuf:"bytes,5,rep,name=add_buffs,json=addBuffs,proto3" json:"add_buffs,omitempty"`
}

func (m *GmSingleBattleMonsterParam) Reset()      { *m = GmSingleBattleMonsterParam{} }
func (*GmSingleBattleMonsterParam) ProtoMessage() {}
func (*GmSingleBattleMonsterParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{11}
}
func (m *GmSingleBattleMonsterParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GmSingleBattleMonsterParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GmSingleBattleMonsterParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GmSingleBattleMonsterParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GmSingleBattleMonsterParam.Merge(m, src)
}
func (m *GmSingleBattleMonsterParam) XXX_Size() int {
	return m.Size()
}
func (m *GmSingleBattleMonsterParam) XXX_DiscardUnknown() {
	xxx_messageInfo_GmSingleBattleMonsterParam.DiscardUnknown(m)
}

var xxx_messageInfo_GmSingleBattleMonsterParam proto.InternalMessageInfo

func (m *GmSingleBattleMonsterParam) GetMonsterId() int64 {
	if m != nil {
		return m.MonsterId
	}
	return 0
}

func (m *GmSingleBattleMonsterParam) GetPos() *Vec2 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *GmSingleBattleMonsterParam) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GmSingleBattleMonsterParam) GetToWard() *Vec2 {
	if m != nil {
		return m.ToWard
	}
	return nil
}

func (m *GmSingleBattleMonsterParam) GetAddBuffs() []*BuffInfo {
	if m != nil {
		return m.AddBuffs
	}
	return nil
}

func (*GmSingleBattleMonsterParam) XXX_MessageName() string {
	return "models.GmSingleBattleMonsterParam"
}

type GmSingleBattleAddBuff struct {
	ObjectId string      `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	AddBuffs []*BuffInfo `protobuf:"bytes,2,rep,name=add_buffs,json=addBuffs,proto3" json:"add_buffs,omitempty"`
}

func (m *GmSingleBattleAddBuff) Reset()      { *m = GmSingleBattleAddBuff{} }
func (*GmSingleBattleAddBuff) ProtoMessage() {}
func (*GmSingleBattleAddBuff) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{12}
}
func (m *GmSingleBattleAddBuff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GmSingleBattleAddBuff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GmSingleBattleAddBuff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GmSingleBattleAddBuff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GmSingleBattleAddBuff.Merge(m, src)
}
func (m *GmSingleBattleAddBuff) XXX_Size() int {
	return m.Size()
}
func (m *GmSingleBattleAddBuff) XXX_DiscardUnknown() {
	xxx_messageInfo_GmSingleBattleAddBuff.DiscardUnknown(m)
}

var xxx_messageInfo_GmSingleBattleAddBuff proto.InternalMessageInfo

func (m *GmSingleBattleAddBuff) GetObjectId() string {
	if m != nil {
		return m.ObjectId
	}
	return ""
}

func (m *GmSingleBattleAddBuff) GetAddBuffs() []*BuffInfo {
	if m != nil {
		return m.AddBuffs
	}
	return nil
}

func (*GmSingleBattleAddBuff) XXX_MessageName() string {
	return "models.GmSingleBattleAddBuff"
}

// 机器人信息
type Bot struct {
	RoleId   string `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	Nickname string `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	RobotId  int64  `protobuf:"varint,3,opt,name=robot_id,json=robotId,proto3" json:"robot_id,omitempty"`
}

func (m *Bot) Reset()      { *m = Bot{} }
func (*Bot) ProtoMessage() {}
func (*Bot) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{13}
}
func (m *Bot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bot.Merge(m, src)
}
func (m *Bot) XXX_Size() int {
	return m.Size()
}
func (m *Bot) XXX_DiscardUnknown() {
	xxx_messageInfo_Bot.DiscardUnknown(m)
}

var xxx_messageInfo_Bot proto.InternalMessageInfo

func (m *Bot) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *Bot) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *Bot) GetRobotId() int64 {
	if m != nil {
		return m.RobotId
	}
	return 0
}

func (*Bot) XXX_MessageName() string {
	return "models.Bot"
}

// Roguelike 战斗房间信息
type RlBattleRoom struct {
	Id   int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Door int64 `protobuf:"varint,2,opt,name=door,proto3" json:"door,omitempty"`
}

func (m *RlBattleRoom) Reset()      { *m = RlBattleRoom{} }
func (*RlBattleRoom) ProtoMessage() {}
func (*RlBattleRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{14}
}
func (m *RlBattleRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RlBattleRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RlBattleRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RlBattleRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RlBattleRoom.Merge(m, src)
}
func (m *RlBattleRoom) XXX_Size() int {
	return m.Size()
}
func (m *RlBattleRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_RlBattleRoom.DiscardUnknown(m)
}

var xxx_messageInfo_RlBattleRoom proto.InternalMessageInfo

func (m *RlBattleRoom) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RlBattleRoom) GetDoor() int64 {
	if m != nil {
		return m.Door
	}
	return 0
}

func (*RlBattleRoom) XXX_MessageName() string {
	return "models.RlBattleRoom"
}

//挂机副本分线信息
type LineInfo struct {
	LineId         int64  `protobuf:"varint,1,opt,name=line_id,json=lineId,proto3" json:"line_id,omitempty"`
	BattleServerId int64  `protobuf:"varint,2,opt,name=battle_server_id,json=battleServerId,proto3" json:"battle_server_id,omitempty"`
	CurNum         int64  `protobuf:"varint,3,opt,name=cur_num,json=curNum,proto3" json:"cur_num,omitempty"`
	Ip             string `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	Port           int64  `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	Status         int64  `protobuf:"varint,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *LineInfo) Reset()      { *m = LineInfo{} }
func (*LineInfo) ProtoMessage() {}
func (*LineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{15}
}
func (m *LineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LineInfo.Merge(m, src)
}
func (m *LineInfo) XXX_Size() int {
	return m.Size()
}
func (m *LineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LineInfo proto.InternalMessageInfo

func (m *LineInfo) GetLineId() int64 {
	if m != nil {
		return m.LineId
	}
	return 0
}

func (m *LineInfo) GetBattleServerId() int64 {
	if m != nil {
		return m.BattleServerId
	}
	return 0
}

func (m *LineInfo) GetCurNum() int64 {
	if m != nil {
		return m.CurNum
	}
	return 0
}

func (m *LineInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *LineInfo) GetPort() int64 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *LineInfo) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (*LineInfo) XXX_MessageName() string {
	return "models.LineInfo"
}

//某个挂机地图对应的所有分线信息
type AllLineInfo struct {
	MapId    int64               `protobuf:"varint,1,opt,name=map_id,json=mapId,proto3" json:"map_id,omitempty"`
	MaxNum   int64               `protobuf:"varint,2,opt,name=max_num,json=maxNum,proto3" json:"max_num,omitempty"`
	AllLines map[int64]*LineInfo `protobuf:"bytes,3,rep,name=all_lines,json=allLines,proto3" json:"all_lines,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AllLineInfo) Reset()      { *m = AllLineInfo{} }
func (*AllLineInfo) ProtoMessage() {}
func (*AllLineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{16}
}
func (m *AllLineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllLineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllLineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllLineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllLineInfo.Merge(m, src)
}
func (m *AllLineInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllLineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllLineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllLineInfo proto.InternalMessageInfo

func (m *AllLineInfo) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *AllLineInfo) GetMaxNum() int64 {
	if m != nil {
		return m.MaxNum
	}
	return 0
}

func (m *AllLineInfo) GetAllLines() map[int64]*LineInfo {
	if m != nil {
		return m.AllLines
	}
	return nil
}

func (*AllLineInfo) XXX_MessageName() string {
	return "models.AllLineInfo"
}

type BossBattleInfo struct {
	BossId      int64  `protobuf:"varint,1,opt,name=boss_id,json=bossId,proto3" json:"boss_id,omitempty"`
	IsDead      bool   `protobuf:"varint,2,opt,name=is_dead,json=isDead,proto3" json:"is_dead,omitempty"`
	RefreshTime int64  `protobuf:"varint,3,opt,name=refresh_time,json=refreshTime,proto3" json:"refresh_time,omitempty"`
	Killer      string `protobuf:"bytes,4,opt,name=killer,proto3" json:"killer,omitempty"`
	BattleId    int64  `protobuf:"varint,5,opt,name=battle_id,json=battleId,proto3" json:"battle_id,omitempty"`
	MapId       int64  `protobuf:"varint,6,opt,name=map_id,json=mapId,proto3" json:"map_id,omitempty"`
	Line        int64  `protobuf:"varint,7,opt,name=line,proto3" json:"line,omitempty"`
	TransPos    *Vec2  `protobuf:"bytes,8,opt,name=trans_pos,json=transPos,proto3" json:"trans_pos,omitempty"`
}

func (m *BossBattleInfo) Reset()      { *m = BossBattleInfo{} }
func (*BossBattleInfo) ProtoMessage() {}
func (*BossBattleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{17}
}
func (m *BossBattleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BossBattleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BossBattleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BossBattleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BossBattleInfo.Merge(m, src)
}
func (m *BossBattleInfo) XXX_Size() int {
	return m.Size()
}
func (m *BossBattleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BossBattleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BossBattleInfo proto.InternalMessageInfo

func (m *BossBattleInfo) GetBossId() int64 {
	if m != nil {
		return m.BossId
	}
	return 0
}

func (m *BossBattleInfo) GetIsDead() bool {
	if m != nil {
		return m.IsDead
	}
	return false
}

func (m *BossBattleInfo) GetRefreshTime() int64 {
	if m != nil {
		return m.RefreshTime
	}
	return 0
}

func (m *BossBattleInfo) GetKiller() string {
	if m != nil {
		return m.Killer
	}
	return ""
}

func (m *BossBattleInfo) GetBattleId() int64 {
	if m != nil {
		return m.BattleId
	}
	return 0
}

func (m *BossBattleInfo) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *BossBattleInfo) GetLine() int64 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *BossBattleInfo) GetTransPos() *Vec2 {
	if m != nil {
		return m.TransPos
	}
	return nil
}

func (*BossBattleInfo) XXX_MessageName() string {
	return "models.BossBattleInfo"
}

type BossInfo struct {
	BossId   int64                     `protobuf:"varint,1,opt,name=boss_id,json=bossId,proto3" json:"boss_id,omitempty"`
	BossInfo map[int64]*BossBattleInfo `protobuf:"bytes,2,rep,name=boss_info,json=bossInfo,proto3" json:"boss_info,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BossInfo) Reset()      { *m = BossInfo{} }
func (*BossInfo) ProtoMessage() {}
func (*BossInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{18}
}
func (m *BossInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BossInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BossInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BossInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BossInfo.Merge(m, src)
}
func (m *BossInfo) XXX_Size() int {
	return m.Size()
}
func (m *BossInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BossInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BossInfo proto.InternalMessageInfo

func (m *BossInfo) GetBossId() int64 {
	if m != nil {
		return m.BossId
	}
	return 0
}

func (m *BossInfo) GetBossInfo() map[int64]*BossBattleInfo {
	if m != nil {
		return m.BossInfo
	}
	return nil
}

func (*BossInfo) XXX_MessageName() string {
	return "models.BossInfo"
}

type SingleBattleSetAttr struct {
	ObjectId  string          `protobuf:"bytes,1,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	HeroInfos []*HeroAttrInfo `protobuf:"bytes,2,rep,name=hero_infos,json=heroInfos,proto3" json:"hero_infos,omitempty"`
}

func (m *SingleBattleSetAttr) Reset()      { *m = SingleBattleSetAttr{} }
func (*SingleBattleSetAttr) ProtoMessage() {}
func (*SingleBattleSetAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_74ca3004932ea658, []int{19}
}
func (m *SingleBattleSetAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleBattleSetAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleBattleSetAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleBattleSetAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleBattleSetAttr.Merge(m, src)
}
func (m *SingleBattleSetAttr) XXX_Size() int {
	return m.Size()
}
func (m *SingleBattleSetAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleBattleSetAttr.DiscardUnknown(m)
}

var xxx_messageInfo_SingleBattleSetAttr proto.InternalMessageInfo

func (m *SingleBattleSetAttr) GetObjectId() string {
	if m != nil {
		return m.ObjectId
	}
	return ""
}

func (m *SingleBattleSetAttr) GetHeroInfos() []*HeroAttrInfo {
	if m != nil {
		return m.HeroInfos
	}
	return nil
}

func (*SingleBattleSetAttr) XXX_MessageName() string {
	return "models.SingleBattleSetAttr"
}
func init() {
	proto.RegisterEnum("models.BattleType", BattleType_name, BattleType_value)
	proto.RegisterType((*Vec2)(nil), "models.Vec2")
	proto.RegisterType((*PosAndDir)(nil), "models.PosAndDir")
	proto.RegisterType((*HeroAttrInfo)(nil), "models.HeroAttrInfo")
	proto.RegisterMapType((map[int64]int64)(nil), "models.HeroAttrInfo.AttrEntry")
	proto.RegisterType((*HeroForBattle)(nil), "models.HeroForBattle")
	proto.RegisterMapType((map[int64]int64)(nil), "models.HeroForBattle.AttrEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "models.HeroForBattle.EquipEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "models.HeroForBattle.EquipLightEffectEntry")
	proto.RegisterType((*MedicineInfo)(nil), "models.MedicineInfo")
	proto.RegisterType((*TempBag)(nil), "models.TempBag")
	proto.RegisterMapType((map[int64]int64)(nil), "models.TempBag.ItemsEntry")
	proto.RegisterType((*RoleTempBag)(nil), "models.RoleTempBag")
	proto.RegisterType((*SinglePlayerInfo)(nil), "models.SinglePlayerInfo")
	proto.RegisterType((*BuffInfo)(nil), "models.BuffInfo")
	proto.RegisterType((*MonsterInfo)(nil), "models.MonsterInfo")
	proto.RegisterMapType((map[int64]int64)(nil), "models.MonsterInfo.AttrEntry")
	proto.RegisterType((*SingleBattleParam)(nil), "models.SingleBattleParam")
	proto.RegisterMapType((map[int64]*MedicineInfo)(nil), "models.SingleBattleParam.MedicineEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "models.SingleBattleParam.MonsterGroupInfoEntry")
	proto.RegisterType((*GmSingleBattleMonsterParam)(nil), "models.GmSingleBattleMonsterParam")
	proto.RegisterType((*GmSingleBattleAddBuff)(nil), "models.GmSingleBattleAddBuff")
	proto.RegisterType((*Bot)(nil), "models.Bot")
	proto.RegisterType((*RlBattleRoom)(nil), "models.RlBattleRoom")
	proto.RegisterType((*LineInfo)(nil), "models.LineInfo")
	proto.RegisterType((*AllLineInfo)(nil), "models.AllLineInfo")
	proto.RegisterMapType((map[int64]*LineInfo)(nil), "models.AllLineInfo.AllLinesEntry")
	proto.RegisterType((*BossBattleInfo)(nil), "models.BossBattleInfo")
	proto.RegisterType((*BossInfo)(nil), "models.BossInfo")
	proto.RegisterMapType((map[int64]*BossBattleInfo)(nil), "models.BossInfo.BossInfoEntry")
	proto.RegisterType((*SingleBattleSetAttr)(nil), "models.SingleBattleSetAttr")
}

func init() { proto.RegisterFile("proto/models/battle.proto", fileDescriptor_74ca3004932ea658) }

var fileDescriptor_74ca3004932ea658 = []byte{
	// 1711 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcb, 0x8f, 0x1b, 0x49,
	0x19, 0x9f, 0xf6, 0xa3, 0xdd, 0xfd, 0xd9, 0x4e, 0xbc, 0xb5, 0x79, 0x38, 0x46, 0x71, 0x66, 0x8d,
	0x08, 0x43, 0x20, 0x33, 0x30, 0x11, 0xcb, 0x0a, 0xb4, 0x48, 0x33, 0x93, 0xb0, 0xb1, 0x94, 0x44,
	0x43, 0x3b, 0xe1, 0x25, 0xa1, 0x56, 0xd9, 0x5d, 0xf6, 0x34, 0xd3, 0xdd, 0xd5, 0x74, 0x55, 0x67,
	0x66, 0xae, 0x5c, 0x39, 0xb0, 0x47, 0xce, 0x9c, 0xb8, 0x72, 0x40, 0x9c, 0xb9, 0xed, 0x81, 0xc3,
	0x1e, 0x57, 0xe2, 0x02, 0x13, 0x09, 0x71, 0xdc, 0x3f, 0x01, 0x7d, 0x55, 0xd5, 0x76, 0xdb, 0xf1,
	0xcc, 0x6a, 0x22, 0x6e, 0xf5, 0xfd, 0xaa, 0xbe, 0xf7, 0xa3, 0xaa, 0xe0, 0x4e, 0x9a, 0x71, 0xc9,
	0x77, 0x62, 0x1e, 0xb0, 0x48, 0xec, 0x8c, 0xa9, 0x94, 0x11, 0xdb, 0x56, 0x18, 0xb1, 0x35, 0xd8,
	0xdb, 0x9c, 0x71, 0x3e, 0x8b, 0xd8, 0x8e, 0x42, 0xc7, 0xf9, 0x74, 0x27, 0x60, 0x62, 0x92, 0x85,
	0xa9, 0xe4, 0x99, 0x3e, 0xd9, 0xbb, 0xbd, 0x24, 0x24, 0x17, 0x6c, 0xfd, 0xc6, 0x11, 0xcb, 0xb8,
	0xde, 0x18, 0x0c, 0xa0, 0xf6, 0x33, 0x36, 0xd9, 0x25, 0x2d, 0xb0, 0x4e, 0xbb, 0xd6, 0xa6, 0xb5,
	0x55, 0xf1, 0xac, 0x53, 0xa4, 0xce, 0xba, 0x15, 0x4d, 0x9d, 0x0d, 0x3e, 0x06, 0xf7, 0x90, 0x8b,
	0xbd, 0x24, 0x78, 0x1c, 0x66, 0xa4, 0x0f, 0xd5, 0x94, 0x0b, 0x75, 0xb4, 0xb9, 0xdb, 0xda, 0xd6,
	0x12, 0xb7, 0x51, 0x86, 0x87, 0x1b, 0xa4, 0x03, 0xd5, 0x20, 0xcc, 0x0c, 0x33, 0x2e, 0x07, 0x7f,
	0xb4, 0xa0, 0xf5, 0x94, 0x65, 0x7c, 0x4f, 0xca, 0x6c, 0x98, 0x4c, 0x39, 0xf9, 0x1a, 0xb8, 0x13,
	0x9e, 0x4c, 0xc3, 0x99, 0x1f, 0x06, 0x4a, 0x50, 0xd5, 0x73, 0x34, 0x30, 0x0c, 0xc8, 0x2e, 0xd4,
	0xa8, 0x94, 0x28, 0xa0, 0xba, 0xd5, 0xdc, 0xed, 0x17, 0x0a, 0xca, 0x02, 0xb6, 0x71, 0xf1, 0x24,
	0x91, 0xd9, 0x99, 0xa7, 0xce, 0xf6, 0x7e, 0x00, 0xee, 0x1c, 0x42, 0x03, 0x8e, 0xd9, 0x99, 0x91,
	0x8b, 0x4b, 0x72, 0x03, 0xea, 0xaf, 0x69, 0x94, 0x33, 0x65, 0x54, 0xd5, 0xd3, 0xc4, 0x0f, 0x2b,
	0x1f, 0x59, 0x83, 0x7f, 0xd6, 0xa0, 0x8d, 0x92, 0x7f, 0xc2, 0xb3, 0x7d, 0x15, 0xf1, 0xcb, 0x6d,
	0x7b, 0xb4, 0x64, 0xdb, 0xbd, 0xb2, 0x6d, 0x73, 0x09, 0xab, 0xc6, 0x91, 0x0f, 0xa1, 0xce, 0x7e,
	0x9b, 0x87, 0x69, 0xb7, 0xaa, 0xb8, 0x36, 0xd7, 0x73, 0x3d, 0xc1, 0x23, 0x9a, 0x4d, 0x1f, 0x27,
	0xf7, 0xa0, 0x89, 0x79, 0xf2, 0x85, 0xa4, 0x32, 0x17, 0xdd, 0x9a, 0xb2, 0x05, 0x10, 0x1a, 0x29,
	0x84, 0x7c, 0x08, 0xae, 0x38, 0x0e, 0xa3, 0xc8, 0x0f, 0x03, 0xd1, 0xad, 0x2b, 0xe1, 0x77, 0xca,
	0xc2, 0x47, 0xb8, 0xb9, 0x97, 0x04, 0x23, 0xc9, 0x13, 0xe6, 0x39, 0xea, 0xec, 0x30, 0x10, 0xe4,
	0x0e, 0x38, 0xe3, 0x7c, 0x3a, 0x55, 0x6c, 0xf6, 0x66, 0x75, 0xab, 0xea, 0x35, 0x90, 0xc6, 0xad,
	0x7b, 0xd0, 0x94, 0x34, 0x62, 0x89, 0xf4, 0x11, 0xe9, 0x36, 0xd4, 0x2e, 0x68, 0x68, 0x3f, 0x9f,
	0x4e, 0xc9, 0x2f, 0x81, 0x28, 0xeb, 0xfc, 0x28, 0x9c, 0x1d, 0x49, 0x9f, 0x4d, 0xa7, 0x6c, 0x22,
	0xbb, 0x8e, 0x52, 0xfe, 0xed, 0x4b, 0x3c, 0x7b, 0x86, 0xc7, 0x9f, 0xa8, 0xd3, 0xda, 0xc9, 0x0e,
	0x5b, 0x81, 0x49, 0x17, 0x1a, 0x53, 0x2a, 0x8e, 0x42, 0x9e, 0x74, 0x5d, 0xe5, 0x6b, 0x41, 0xbe,
	0x73, 0x7a, 0x7b, 0x1f, 0x01, 0x2c, 0xe2, 0x7a, 0x25, 0xce, 0x03, 0xb8, 0xb9, 0xd6, 0xee, 0x2b,
	0x55, 0xd7, 0x2f, 0xa0, 0xf5, 0x9c, 0x05, 0xe1, 0x24, 0x4c, 0x98, 0xaa, 0xfb, 0xdb, 0xd0, 0x98,
	0x04, 0xbe, 0x0c, 0x63, 0x66, 0xf8, 0xed, 0x49, 0xf0, 0x32, 0x8c, 0x19, 0x21, 0x50, 0xe3, 0x29,
	0x4b, 0x8c, 0x04, 0xb5, 0xc6, 0x42, 0xa4, 0xb9, 0xe4, 0xbe, 0xa4, 0xc7, 0xac, 0x5b, 0xd5, 0x85,
	0x88, 0xc0, 0x4b, 0x7a, 0xcc, 0x06, 0x7f, 0xab, 0x40, 0xe3, 0x25, 0x8b, 0xd3, 0x7d, 0x3a, 0x23,
	0x77, 0x01, 0x84, 0xa4, 0x99, 0x2c, 0x0b, 0x76, 0x15, 0xa2, 0x64, 0x7f, 0x00, 0x2d, 0x55, 0x24,
	0x31, 0x4f, 0x84, 0x64, 0x99, 0xd1, 0xd1, 0x44, 0xec, 0xb9, 0x86, 0x50, 0x95, 0x3a, 0x32, 0xe6,
	0x42, 0x14, 0xaa, 0x10, 0xd8, 0xe7, 0x42, 0x90, 0xaf, 0x43, 0x1b, 0x4d, 0xf0, 0x63, 0xe3, 0x89,
	0x29, 0xc4, 0x16, 0x82, 0x85, 0x77, 0x68, 0x43, 0xc0, 0x68, 0xe0, 0x4f, 0x78, 0x9e, 0xc8, 0x6e,
	0x5d, 0xdb, 0x80, 0xc8, 0x01, 0x02, 0xe4, 0xbb, 0x50, 0x0f, 0x25, 0x8b, 0x75, 0xb9, 0x35, 0x77,
	0x7b, 0x45, 0xa1, 0x18, 0x17, 0xb6, 0x87, 0xb8, 0x69, 0x8a, 0x5f, 0x1d, 0x44, 0x81, 0xec, 0x34,
	0xf5, 0xd3, 0x8c, 0x4f, 0x43, 0xd9, 0x85, 0x4d, 0x6b, 0xcb, 0xf2, 0x5c, 0x76, 0x9a, 0x1e, 0x2a,
	0x00, 0x13, 0xbb, 0xe0, 0xb9, 0x52, 0x4e, 0x42, 0x68, 0x7a, 0x3c, 0x62, 0x45, 0xf0, 0x6e, 0x43,
	0x23, 0xe3, 0x11, 0x2b, 0x9a, 0xdd, 0xf5, 0x6c, 0x24, 0x87, 0x01, 0x79, 0x00, 0x8e, 0x64, 0x71,
	0xea, 0x8f, 0xe9, 0x4c, 0x09, 0x69, 0xee, 0x5e, 0x5f, 0xb1, 0xda, 0x6b, 0x48, 0x23, 0xe4, 0x26,
	0xd8, 0x31, 0x4d, 0x51, 0x86, 0x0e, 0x5e, 0x3d, 0xa6, 0xe9, 0x30, 0x18, 0xfc, 0xde, 0x82, 0xce,
	0x28, 0x4c, 0x66, 0x11, 0x3b, 0x8c, 0xe8, 0x19, 0xd3, 0xb3, 0x6f, 0x13, 0x6a, 0xa8, 0x61, 0x75,
	0x7e, 0xa2, 0x4d, 0x9e, 0xda, 0x21, 0x0f, 0xc1, 0xc6, 0x26, 0x67, 0xc2, 0x8c, 0x99, 0x9b, 0x6b,
	0xdb, 0xca, 0x33, 0x87, 0xc8, 0x7d, 0xa8, 0x63, 0xaf, 0x0a, 0x33, 0x5e, 0x3a, 0xc5, 0x69, 0x6c,
	0x57, 0xd4, 0xe8, 0xe9, 0xed, 0xc1, 0xc7, 0xe0, 0x14, 0x10, 0x7a, 0x6d, 0x26, 0x40, 0x51, 0x88,
	0x7a, 0x00, 0x60, 0x0f, 0xf2, 0xd7, 0x2c, 0x8b, 0xa8, 0x9e, 0xfe, 0x75, 0xaf, 0x20, 0x07, 0x7f,
	0xb1, 0xa0, 0x69, 0xea, 0x45, 0x89, 0xb8, 0x0b, 0x60, 0x2a, 0x6a, 0x21, 0xc5, 0x35, 0xc8, 0x30,
	0x20, 0xdf, 0x5b, 0x9a, 0x94, 0x77, 0x0b, 0xa3, 0x4a, 0x12, 0xde, 0x9a, 0x93, 0xb7, 0xa1, 0x41,
	0x33, 0x46, 0x17, 0x61, 0xb4, 0x91, 0x1c, 0x06, 0xef, 0x3e, 0xdd, 0xff, 0x53, 0x87, 0xf7, 0x74,
	0x02, 0x74, 0xcc, 0x0e, 0x69, 0x46, 0xe3, 0xff, 0x7f, 0x06, 0x0e, 0xc0, 0x99, 0x37, 0x87, 0x4e,
	0xc2, 0x37, 0x0b, 0x86, 0xb7, 0xb4, 0x6f, 0x17, 0x2d, 0xa3, 0x3d, 0x9f, 0x33, 0x92, 0x5f, 0x03,
	0x29, 0xe2, 0x39, 0xcb, 0x78, 0x9e, 0xfa, 0x61, 0x32, 0xe5, 0xdd, 0x9a, 0x12, 0xb7, 0x73, 0x89,
	0x38, 0xcd, 0xf3, 0x09, 0xb2, 0x60, 0x54, 0xcd, 0x70, 0x8d, 0x57, 0x60, 0x4c, 0x97, 0xea, 0x4d,
	0x3f, 0xe0, 0x27, 0x49, 0xd1, 0xa0, 0x0a, 0x79, 0xcc, 0x4f, 0x12, 0xb2, 0x07, 0xd7, 0x8f, 0xb8,
	0x90, 0x61, 0xc4, 0xfc, 0x54, 0xd5, 0x6a, 0xd1, 0xaa, 0xdd, 0x65, 0xd5, 0x8b, 0x42, 0xf6, 0xae,
	0x19, 0x06, 0x0d, 0xe1, 0x9c, 0xa8, 0xa6, 0x34, 0xe8, 0x36, 0x54, 0x54, 0xdf, 0x2b, 0xd8, 0xe6,
	0xef, 0x06, 0x0f, 0x77, 0xc9, 0x43, 0x70, 0xf9, 0x49, 0xe2, 0xeb, 0x82, 0x75, 0x2e, 0x28, 0x58,
	0x87, 0x9f, 0x24, 0x48, 0x08, 0xf2, 0x7d, 0x68, 0x17, 0x41, 0xd1, 0x2c, 0xee, 0x05, 0x2c, 0x2d,
	0x73, 0x4c, 0xb3, 0xed, 0x80, 0x63, 0x68, 0xd1, 0x05, 0xc5, 0xf1, 0xfe, 0x9a, 0x02, 0xf4, 0xe6,
	0x87, 0xc8, 0x7d, 0xb8, 0xae, 0x66, 0xad, 0xe0, 0x79, 0xe4, 0xab, 0x7b, 0xb2, 0xdb, 0x54, 0x21,
	0x6a, 0x23, 0x3c, 0xe2, 0x79, 0xa4, 0xee, 0xd2, 0xde, 0x4f, 0xa1, 0xbd, 0x94, 0xbf, 0x35, 0xd5,
	0xf8, 0xa0, 0x5c, 0x8d, 0xcd, 0xdd, 0x1b, 0x73, 0xc5, 0xa5, 0x8b, 0x60, 0xe5, 0xa2, 0x59, 0x9b,
	0xc3, 0x2b, 0x15, 0xfa, 0xdf, 0x2d, 0xe8, 0x7d, 0x12, 0x97, 0xab, 0xc3, 0xc8, 0xd4, 0x15, 0xff,
	0x15, 0xbd, 0x6a, 0x5e, 0x74, 0x95, 0x8b, 0x5e, 0x74, 0xd7, 0xa0, 0x62, 0x7a, 0xd2, 0xf5, 0x2a,
	0x61, 0x40, 0xbe, 0x01, 0x0d, 0xc9, 0xfd, 0x13, 0x9a, 0x05, 0xea, 0x2e, 0x58, 0xe5, 0xb1, 0x25,
	0xff, 0x39, 0xcd, 0x54, 0xae, 0x69, 0x10, 0x98, 0xc4, 0xd5, 0x2f, 0xca, 0x35, 0x0d, 0x02, 0x95,
	0xb4, 0xc1, 0x04, 0x6e, 0x2e, 0xbb, 0xb0, 0xa7, 0x77, 0xf0, 0x76, 0xe2, 0xe3, 0xdf, 0xb0, 0x89,
	0x5c, 0x0c, 0x69, 0x47, 0x03, 0xc3, 0x15, 0x25, 0x95, 0xaf, 0x54, 0xf2, 0x0a, 0xaa, 0xfb, 0x5c,
	0x5e, 0x3c, 0xf5, 0x7b, 0xe0, 0x24, 0xe1, 0xe4, 0x38, 0xa1, 0xb1, 0x8e, 0xb2, 0xeb, 0xcd, 0x69,
	0x7c, 0x36, 0x65, 0x7c, 0xcc, 0xe5, 0x62, 0x40, 0x35, 0x14, 0x3d, 0x0c, 0x06, 0xbb, 0xd0, 0xf2,
	0x22, 0x33, 0x15, 0x38, 0x8f, 0x4d, 0xc4, 0x74, 0xa0, 0x31, 0x62, 0x04, 0x6a, 0x01, 0xe7, 0xc5,
	0xdd, 0xab, 0xd6, 0x83, 0x3f, 0x59, 0xe0, 0x3c, 0x2b, 0xbd, 0x0c, 0xa2, 0x30, 0x61, 0xa5, 0x81,
	0x8c, 0xe4, 0x30, 0x20, 0x5b, 0xd0, 0xd1, 0x5f, 0x01, 0x5f, 0xb0, 0xec, 0xb5, 0x4e, 0xa0, 0x96,
	0x72, 0x4d, 0xe3, 0x23, 0x05, 0x0f, 0x03, 0xf5, 0xb8, 0xc8, 0x33, 0x3f, 0xc9, 0xe3, 0x62, 0x7c,
	0x4e, 0xf2, 0xec, 0x45, 0xae, 0x8d, 0x49, 0x55, 0xa6, 0x30, 0x7d, 0x29, 0x1a, 0x93, 0xf2, 0xac,
	0xb8, 0xa5, 0xd5, 0x9a, 0xdc, 0x02, 0xdb, 0x3c, 0x33, 0x6d, 0xcd, 0xab, 0xa9, 0xc1, 0x3f, 0x2c,
	0x68, 0xee, 0x45, 0xd1, 0xdc, 0xce, 0xc5, 0x4d, 0x67, 0x95, 0x6e, 0x3a, 0xd4, 0x1d, 0xd3, 0x53,
	0xa5, 0x5b, 0x1b, 0x67, 0xc7, 0xf4, 0x14, 0x75, 0xff, 0x18, 0x5c, 0x1a, 0x45, 0x3e, 0x3a, 0x53,
	0x5c, 0x50, 0x1f, 0x14, 0xe9, 0x29, 0xc9, 0x2d, 0xd6, 0xe6, 0x0d, 0xe0, 0x50, 0x43, 0xf6, 0x9e,
	0x43, 0x7b, 0x69, 0x6b, 0x4d, 0x57, 0xdc, 0x5f, 0x6e, 0xb8, 0x79, 0xf6, 0x9f, 0xbd, 0xdd, 0x6c,
	0x83, 0x2f, 0x2d, 0xb8, 0x86, 0x8f, 0x1a, 0x9d, 0xaa, 0xf9, 0x55, 0xc8, 0x85, 0x28, 0x5f, 0x85,
	0x5c, 0x08, 0xed, 0x53, 0x28, 0x7c, 0x7c, 0xc3, 0x28, 0xc9, 0x8e, 0x67, 0x87, 0xe2, 0x31, 0xa3,
	0x01, 0x3e, 0xa8, 0x32, 0x36, 0xcd, 0x98, 0x38, 0xd2, 0x2f, 0x2e, 0x1d, 0xed, 0xa6, 0xc1, 0xd4,
	0x9b, 0xeb, 0x16, 0xd8, 0x38, 0x2f, 0x58, 0x66, 0xc2, 0x6e, 0x28, 0x2c, 0x65, 0x93, 0xcd, 0x30,
	0x30, 0xf1, 0x77, 0x34, 0x30, 0x0c, 0x4a, 0xb1, 0xb5, 0xcb, 0xb1, 0x25, 0x50, 0xc3, 0xf0, 0xa9,
	0xc1, 0x5a, 0xf5, 0xd4, 0x9a, 0x7c, 0x0b, 0x5c, 0x99, 0xd1, 0x44, 0xf8, 0xd8, 0xb7, 0xce, 0x9a,
	0x1e, 0x74, 0xd4, 0xf6, 0x21, 0x17, 0x83, 0xbf, 0x5a, 0xe0, 0xa0, 0xcb, 0x97, 0x3b, 0xfb, 0x23,
	0x70, 0xf5, 0x06, 0x5e, 0x3a, 0x2b, 0x3f, 0xaf, 0x82, 0x7b, 0xbe, 0x30, 0x49, 0x1a, 0x1b, 0xb2,
	0x37, 0x82, 0xf6, 0xd2, 0xd6, 0x9a, 0x24, 0x7d, 0x67, 0x39, 0x49, 0xb7, 0xca, 0xb2, 0x17, 0xc9,
	0x28, 0xa7, 0x6a, 0x06, 0xef, 0x97, 0x87, 0xc1, 0x88, 0x49, 0x7c, 0x03, 0x5c, 0x3e, 0x0c, 0x1e,
	0x81, 0xfa, 0x1e, 0x29, 0x2f, 0x8a, 0x69, 0x70, 0x63, 0xdd, 0x07, 0xd2, 0x73, 0xf1, 0x1c, 0xae,
	0xc4, 0x83, 0xdf, 0x59, 0x00, 0x5a, 0xc7, 0xcb, 0xb3, 0x94, 0x91, 0x16, 0x38, 0xaf, 0x92, 0xe3,
	0x04, 0x6f, 0xa9, 0xce, 0x06, 0x71, 0xa0, 0x76, 0x10, 0xca, 0xb3, 0x8e, 0x45, 0x00, 0xec, 0xa7,
	0x34, 0x99, 0xbd, 0x4a, 0x3b, 0x15, 0x85, 0xf2, 0xf4, 0xac, 0x53, 0x25, 0x6d, 0x70, 0x3d, 0x3e,
	0xcb, 0x59, 0x14, 0x1e, 0xb3, 0x4e, 0x0d, 0xc9, 0x57, 0x49, 0xc8, 0x13, 0x74, 0xab, 0x53, 0x47,
	0x59, 0xb8, 0x7a, 0x4a, 0xa3, 0xa8, 0x63, 0x93, 0x26, 0xd8, 0xda, 0xa3, 0xce, 0x1f, 0x5e, 0x90,
	0x36, 0x38, 0x07, 0xb9, 0x1c, 0x4d, 0x58, 0xc2, 0x3a, 0x9f, 0xbe, 0xd8, 0x7f, 0xfe, 0xc5, 0xbf,
	0xfb, 0x1b, 0x7f, 0x3e, 0xef, 0x5b, 0x9f, 0x9d, 0xf7, 0xad, 0xcf, 0xcf, 0xfb, 0xd6, 0xbf, 0xce,
	0xfb, 0xd6, 0x7f, 0xcf, 0xfb, 0x1b, 0x5f, 0x9e, 0xf7, 0xad, 0x4f, 0xdf, 0xf4, 0x37, 0x3e, 0x7b,
	0xd3, 0xb7, 0x3e, 0x7f, 0xd3, 0xdf, 0xf8, 0xe2, 0x4d, 0x7f, 0xe3, 0x57, 0xf7, 0x26, 0x3c, 0x4c,
	0x1e, 0xea, 0x81, 0xb0, 0x33, 0xe1, 0x71, 0xcc, 0x93, 0x9d, 0xf2, 0xff, 0x7e, 0x6c, 0x2b, 0xea,
	0xd1, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xbf, 0xc1, 0x0c, 0x67, 0x54, 0x10, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolVec2.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPosAndDir.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolHeroAttrInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolHeroForBattle.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMedicineInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTempBag.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRoleTempBag.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolSinglePlayerInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolBuffInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMonsterInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolSingleBattleParam.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolGmSingleBattleMonsterParam.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolGmSingleBattleAddBuff.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolBot.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRlBattleRoom.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolLineInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolAllLineInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolBossBattleInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolBossInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolSingleBattleSetAttr.Get().(proto.Message)
	})
}

var poolVec2 = &sync.Pool{New: func() interface{} { return &Vec2{} }}

func (m *Vec2) ReleasePool() { m.Reset(); poolVec2.Put(m); m = nil }

var poolPosAndDir = &sync.Pool{New: func() interface{} { return &PosAndDir{} }}

func (m *PosAndDir) ReleasePool() { m.Reset(); poolPosAndDir.Put(m); m = nil }

var poolHeroAttrInfo = &sync.Pool{New: func() interface{} { return &HeroAttrInfo{} }}

func (m *HeroAttrInfo) ReleasePool() { m.Reset(); poolHeroAttrInfo.Put(m); m = nil }

var poolHeroForBattle = &sync.Pool{New: func() interface{} { return &HeroForBattle{} }}

func (m *HeroForBattle) ReleasePool() { m.Reset(); poolHeroForBattle.Put(m); m = nil }

var poolMedicineInfo = &sync.Pool{New: func() interface{} { return &MedicineInfo{} }}

func (m *MedicineInfo) ReleasePool() { m.Reset(); poolMedicineInfo.Put(m); m = nil }

var poolTempBag = &sync.Pool{New: func() interface{} { return &TempBag{} }}

func (m *TempBag) ReleasePool() { m.Reset(); poolTempBag.Put(m); m = nil }

var poolRoleTempBag = &sync.Pool{New: func() interface{} { return &RoleTempBag{} }}

func (m *RoleTempBag) ReleasePool() { m.Reset(); poolRoleTempBag.Put(m); m = nil }

var poolSinglePlayerInfo = &sync.Pool{New: func() interface{} { return &SinglePlayerInfo{} }}

func (m *SinglePlayerInfo) ReleasePool() { m.Reset(); poolSinglePlayerInfo.Put(m); m = nil }

var poolBuffInfo = &sync.Pool{New: func() interface{} { return &BuffInfo{} }}

func (m *BuffInfo) ReleasePool() { m.Reset(); poolBuffInfo.Put(m); m = nil }

var poolMonsterInfo = &sync.Pool{New: func() interface{} { return &MonsterInfo{} }}

func (m *MonsterInfo) ReleasePool() { m.Reset(); poolMonsterInfo.Put(m); m = nil }

var poolSingleBattleParam = &sync.Pool{New: func() interface{} { return &SingleBattleParam{} }}

func (m *SingleBattleParam) ReleasePool() { m.Reset(); poolSingleBattleParam.Put(m); m = nil }

var poolGmSingleBattleMonsterParam = &sync.Pool{New: func() interface{} { return &GmSingleBattleMonsterParam{} }}

func (m *GmSingleBattleMonsterParam) ReleasePool() {
	m.Reset()
	poolGmSingleBattleMonsterParam.Put(m)
	m = nil
}

var poolGmSingleBattleAddBuff = &sync.Pool{New: func() interface{} { return &GmSingleBattleAddBuff{} }}

func (m *GmSingleBattleAddBuff) ReleasePool() { m.Reset(); poolGmSingleBattleAddBuff.Put(m); m = nil }

var poolBot = &sync.Pool{New: func() interface{} { return &Bot{} }}

func (m *Bot) ReleasePool() { m.Reset(); poolBot.Put(m); m = nil }

var poolRlBattleRoom = &sync.Pool{New: func() interface{} { return &RlBattleRoom{} }}

func (m *RlBattleRoom) ReleasePool() { m.Reset(); poolRlBattleRoom.Put(m); m = nil }

var poolLineInfo = &sync.Pool{New: func() interface{} { return &LineInfo{} }}

func (m *LineInfo) ReleasePool() { m.Reset(); poolLineInfo.Put(m); m = nil }

var poolAllLineInfo = &sync.Pool{New: func() interface{} { return &AllLineInfo{} }}

func (m *AllLineInfo) ReleasePool() { m.Reset(); poolAllLineInfo.Put(m); m = nil }

var poolBossBattleInfo = &sync.Pool{New: func() interface{} { return &BossBattleInfo{} }}

func (m *BossBattleInfo) ReleasePool() { m.Reset(); poolBossBattleInfo.Put(m); m = nil }

var poolBossInfo = &sync.Pool{New: func() interface{} { return &BossInfo{} }}

func (m *BossInfo) ReleasePool() { m.Reset(); poolBossInfo.Put(m); m = nil }

var poolSingleBattleSetAttr = &sync.Pool{New: func() interface{} { return &SingleBattleSetAttr{} }}

func (m *SingleBattleSetAttr) ReleasePool() { m.Reset(); poolSingleBattleSetAttr.Put(m); m = nil }
func (x BattleType) String() string {
	s, ok := BattleType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Vec2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vec2)
	if !ok {
		that2, ok := that.(Vec2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X != that1.X {
		return false
	}
	if this.Y != that1.Y {
		return false
	}
	return true
}
func (this *PosAndDir) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PosAndDir)
	if !ok {
		that2, ok := that.(PosAndDir)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Pos.Equal(that1.Pos) {
		return false
	}
	if this.Dir != that1.Dir {
		return false
	}
	return true
}
func (this *HeroAttrInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeroAttrInfo)
	if !ok {
		that2, ok := that.(HeroAttrInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConfigId != that1.ConfigId {
		return false
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if this.Attr[i] != that1.Attr[i] {
			return false
		}
	}
	return true
}
func (this *HeroForBattle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeroForBattle)
	if !ok {
		that2, ok := that.(HeroForBattle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConfigId != that1.ConfigId {
		return false
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if this.Attr[i] != that1.Attr[i] {
			return false
		}
	}
	if len(this.Equip) != len(that1.Equip) {
		return false
	}
	for i := range this.Equip {
		if this.Equip[i] != that1.Equip[i] {
			return false
		}
	}
	if this.HeroStatus != that1.HeroStatus {
		return false
	}
	if len(this.SkillIds) != len(that1.SkillIds) {
		return false
	}
	for i := range this.SkillIds {
		if !this.SkillIds[i].Equal(that1.SkillIds[i]) {
			return false
		}
	}
	if len(this.BuffIds) != len(that1.BuffIds) {
		return false
	}
	for i := range this.BuffIds {
		if this.BuffIds[i] != that1.BuffIds[i] {
			return false
		}
	}
	if len(this.TalentBuff) != len(that1.TalentBuff) {
		return false
	}
	for i := range this.TalentBuff {
		if this.TalentBuff[i] != that1.TalentBuff[i] {
			return false
		}
	}
	if len(this.EquipLightEffect) != len(that1.EquipLightEffect) {
		return false
	}
	for i := range this.EquipLightEffect {
		if this.EquipLightEffect[i] != that1.EquipLightEffect[i] {
			return false
		}
	}
	if this.Fashion != that1.Fashion {
		return false
	}
	return true
}
func (this *MedicineInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MedicineInfo)
	if !ok {
		that2, ok := that.(MedicineInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CdTime != that1.CdTime {
		return false
	}
	if this.Open != that1.Open {
		return false
	}
	if this.AutoTake != that1.AutoTake {
		return false
	}
	return true
}
func (this *TempBag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TempBag)
	if !ok {
		that2, ok := that.(TempBag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.KillMonster != that1.KillMonster {
		return false
	}
	if this.KillBoss != that1.KillBoss {
		return false
	}
	if this.TakeMedicine != that1.TakeMedicine {
		return false
	}
	if this.DeadCount != that1.DeadCount {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if this.Items[i] != that1.Items[i] {
			return false
		}
	}
	if this.ExpProfit != that1.ExpProfit {
		return false
	}
	return true
}
func (this *RoleTempBag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleTempBag)
	if !ok {
		that2, ok := that.(RoleTempBag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoleId != that1.RoleId {
		return false
	}
	if !this.TempBag.Equal(that1.TempBag) {
		return false
	}
	if this.MapId != that1.MapId {
		return false
	}
	return true
}
func (this *SinglePlayerInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SinglePlayerInfo)
	if !ok {
		that2, ok := that.(SinglePlayerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Role.Equal(that1.Role) {
		return false
	}
	if len(this.Heroes) != len(that1.Heroes) {
		return false
	}
	for i := range this.Heroes {
		if !this.Heroes[i].Equal(that1.Heroes[i]) {
			return false
		}
	}
	if len(this.Buffs) != len(that1.Buffs) {
		return false
	}
	for i := range this.Buffs {
		if !this.Buffs[i].Equal(that1.Buffs[i]) {
			return false
		}
	}
	return true
}
func (this *BuffInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BuffInfo)
	if !ok {
		that2, ok := that.(BuffInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BuffId != that1.BuffId {
		return false
	}
	if this.Overlay != that1.Overlay {
		return false
	}
	return true
}
func (this *MonsterInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MonsterInfo)
	if !ok {
		that2, ok := that.(MonsterInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MonsterId != that1.MonsterId {
		return false
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if this.Attr[i] != that1.Attr[i] {
			return false
		}
	}
	if this.AreaId != that1.AreaId {
		return false
	}
	return true
}
func (this *SingleBattleParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SingleBattleParam)
	if !ok {
		that2, ok := that.(SingleBattleParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Role.Equal(that1.Role) {
		return false
	}
	if len(this.Heroes) != len(that1.Heroes) {
		return false
	}
	for i := range this.Heroes {
		if !this.Heroes[i].Equal(that1.Heroes[i]) {
			return false
		}
	}
	if len(this.Medicine) != len(that1.Medicine) {
		return false
	}
	for i := range this.Medicine {
		if !this.Medicine[i].Equal(that1.Medicine[i]) {
			return false
		}
	}
	if len(this.MonsterGroupInfo) != len(that1.MonsterGroupInfo) {
		return false
	}
	for i := range this.MonsterGroupInfo {
		if this.MonsterGroupInfo[i] != that1.MonsterGroupInfo[i] {
			return false
		}
	}
	if this.CountDown != that1.CountDown {
		return false
	}
	if len(this.HostilePlayers) != len(that1.HostilePlayers) {
		return false
	}
	for i := range this.HostilePlayers {
		if !this.HostilePlayers[i].Equal(that1.HostilePlayers[i]) {
			return false
		}
	}
	if !this.Pad.Equal(that1.Pad) {
		return false
	}
	if len(this.OwnBuffs) != len(that1.OwnBuffs) {
		return false
	}
	for i := range this.OwnBuffs {
		if !this.OwnBuffs[i].Equal(that1.OwnBuffs[i]) {
			return false
		}
	}
	if len(this.MonsterBuffs) != len(that1.MonsterBuffs) {
		return false
	}
	for i := range this.MonsterBuffs {
		if !this.MonsterBuffs[i].Equal(that1.MonsterBuffs[i]) {
			return false
		}
	}
	if len(this.Monsters) != len(that1.Monsters) {
		return false
	}
	for i := range this.Monsters {
		if !this.Monsters[i].Equal(that1.Monsters[i]) {
			return false
		}
	}
	if this.AutoSoulSkill != that1.AutoSoulSkill {
		return false
	}
	return true
}
func (this *GmSingleBattleMonsterParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GmSingleBattleMonsterParam)
	if !ok {
		that2, ok := that.(GmSingleBattleMonsterParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MonsterId != that1.MonsterId {
		return false
	}
	if !this.Pos.Equal(that1.Pos) {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.ToWard.Equal(that1.ToWard) {
		return false
	}
	if len(this.AddBuffs) != len(that1.AddBuffs) {
		return false
	}
	for i := range this.AddBuffs {
		if !this.AddBuffs[i].Equal(that1.AddBuffs[i]) {
			return false
		}
	}
	return true
}
func (this *GmSingleBattleAddBuff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GmSingleBattleAddBuff)
	if !ok {
		that2, ok := that.(GmSingleBattleAddBuff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectId != that1.ObjectId {
		return false
	}
	if len(this.AddBuffs) != len(that1.AddBuffs) {
		return false
	}
	for i := range this.AddBuffs {
		if !this.AddBuffs[i].Equal(that1.AddBuffs[i]) {
			return false
		}
	}
	return true
}
func (this *Bot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Bot)
	if !ok {
		that2, ok := that.(Bot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoleId != that1.RoleId {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.RobotId != that1.RobotId {
		return false
	}
	return true
}
func (this *RlBattleRoom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RlBattleRoom)
	if !ok {
		that2, ok := that.(RlBattleRoom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Door != that1.Door {
		return false
	}
	return true
}
func (this *LineInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LineInfo)
	if !ok {
		that2, ok := that.(LineInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LineId != that1.LineId {
		return false
	}
	if this.BattleServerId != that1.BattleServerId {
		return false
	}
	if this.CurNum != that1.CurNum {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *AllLineInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllLineInfo)
	if !ok {
		that2, ok := that.(AllLineInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MapId != that1.MapId {
		return false
	}
	if this.MaxNum != that1.MaxNum {
		return false
	}
	if len(this.AllLines) != len(that1.AllLines) {
		return false
	}
	for i := range this.AllLines {
		if !this.AllLines[i].Equal(that1.AllLines[i]) {
			return false
		}
	}
	return true
}
func (this *BossBattleInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BossBattleInfo)
	if !ok {
		that2, ok := that.(BossBattleInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BossId != that1.BossId {
		return false
	}
	if this.IsDead != that1.IsDead {
		return false
	}
	if this.RefreshTime != that1.RefreshTime {
		return false
	}
	if this.Killer != that1.Killer {
		return false
	}
	if this.BattleId != that1.BattleId {
		return false
	}
	if this.MapId != that1.MapId {
		return false
	}
	if this.Line != that1.Line {
		return false
	}
	if !this.TransPos.Equal(that1.TransPos) {
		return false
	}
	return true
}
func (this *BossInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BossInfo)
	if !ok {
		that2, ok := that.(BossInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BossId != that1.BossId {
		return false
	}
	if len(this.BossInfo) != len(that1.BossInfo) {
		return false
	}
	for i := range this.BossInfo {
		if !this.BossInfo[i].Equal(that1.BossInfo[i]) {
			return false
		}
	}
	return true
}
func (this *SingleBattleSetAttr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SingleBattleSetAttr)
	if !ok {
		that2, ok := that.(SingleBattleSetAttr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectId != that1.ObjectId {
		return false
	}
	if len(this.HeroInfos) != len(that1.HeroInfos) {
		return false
	}
	for i := range this.HeroInfos {
		if !this.HeroInfos[i].Equal(that1.HeroInfos[i]) {
			return false
		}
	}
	return true
}
func (m *Vec2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vec2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vec2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x15
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *PosAndDir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PosAndDir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PosAndDir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dir != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Dir))))
		i--
		dAtA[i] = 0x15
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeroAttrInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroAttrInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeroAttrInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attr) > 0 {
		for k := range m.Attr {
			v := m.Attr[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ConfigId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.ConfigId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeroForBattle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroForBattle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeroForBattle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fashion != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Fashion))
		i--
		dAtA[i] = 0x48
	}
	if len(m.EquipLightEffect) > 0 {
		for k := range m.EquipLightEffect {
			v := m.EquipLightEffect[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TalentBuff) > 0 {
		dAtA3 := make([]byte, len(m.TalentBuff)*10)
		var j2 int
		for _, num1 := range m.TalentBuff {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintBattle(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BuffIds) > 0 {
		dAtA5 := make([]byte, len(m.BuffIds)*10)
		var j4 int
		for _, num1 := range m.BuffIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintBattle(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SkillIds) > 0 {
		for iNdEx := len(m.SkillIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SkillIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.HeroStatus != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.HeroStatus))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Equip) > 0 {
		for k := range m.Equip {
			v := m.Equip[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Attr) > 0 {
		for k := range m.Attr {
			v := m.Attr[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ConfigId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.ConfigId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MedicineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedicineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MedicineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoTake != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.AutoTake))
		i--
		dAtA[i] = 0x18
	}
	if m.Open != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Open))
		i--
		dAtA[i] = 0x10
	}
	if m.CdTime != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.CdTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TempBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TempBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TempBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExpProfit))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DeadCount != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.DeadCount))
		i--
		dAtA[i] = 0x28
	}
	if m.TakeMedicine != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.TakeMedicine))
		i--
		dAtA[i] = 0x20
	}
	if m.KillBoss != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.KillBoss))
		i--
		dAtA[i] = 0x18
	}
	if m.KillMonster != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.KillMonster))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTime != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleTempBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleTempBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleTempBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MapId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.MapId))
		i--
		dAtA[i] = 0x18
	}
	if m.TempBag != nil {
		{
			size, err := m.TempBag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleId) > 0 {
		i -= len(m.RoleId)
		copy(dAtA[i:], m.RoleId)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.RoleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SinglePlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SinglePlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SinglePlayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buffs) > 0 {
		for iNdEx := len(m.Buffs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buffs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Heroes) > 0 {
		for iNdEx := len(m.Heroes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Heroes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuffInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Overlay != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Overlay))
		i--
		dAtA[i] = 0x10
	}
	if m.BuffId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.BuffId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MonsterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonsterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonsterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AreaId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.AreaId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Attr) > 0 {
		for k := range m.Attr {
			v := m.Attr[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MonsterId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.MonsterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SingleBattleParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleBattleParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleBattleParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoSoulSkill != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.AutoSoulSkill))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Monsters) > 0 {
		for iNdEx := len(m.Monsters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Monsters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MonsterBuffs) > 0 {
		for iNdEx := len(m.MonsterBuffs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MonsterBuffs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OwnBuffs) > 0 {
		for iNdEx := len(m.OwnBuffs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnBuffs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Pad != nil {
		{
			size, err := m.Pad.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HostilePlayers) > 0 {
		for iNdEx := len(m.HostilePlayers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HostilePlayers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.CountDown != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.CountDown))
		i--
		dAtA[i] = 0x28
	}
	if len(m.MonsterGroupInfo) > 0 {
		for k := range m.MonsterGroupInfo {
			v := m.MonsterGroupInfo[k]
			baseI := i
			i = encodeVarintBattle(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Medicine) > 0 {
		for k := range m.Medicine {
			v := m.Medicine[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBattle(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Heroes) > 0 {
		for iNdEx := len(m.Heroes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Heroes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GmSingleBattleMonsterParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GmSingleBattleMonsterParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GmSingleBattleMonsterParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddBuffs) > 0 {
		for iNdEx := len(m.AddBuffs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddBuffs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ToWard != nil {
		{
			size, err := m.ToWard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MonsterId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.MonsterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GmSingleBattleAddBuff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GmSingleBattleAddBuff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GmSingleBattleAddBuff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddBuffs) > 0 {
		for iNdEx := len(m.AddBuffs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddBuffs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ObjectId) > 0 {
		i -= len(m.ObjectId)
		copy(dAtA[i:], m.ObjectId)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.ObjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Bot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RobotId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.RobotId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleId) > 0 {
		i -= len(m.RoleId)
		copy(dAtA[i:], m.RoleId)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.RoleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RlBattleRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RlBattleRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RlBattleRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Door != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Door))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.Port != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x22
	}
	if m.CurNum != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.CurNum))
		i--
		dAtA[i] = 0x18
	}
	if m.BattleServerId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleServerId))
		i--
		dAtA[i] = 0x10
	}
	if m.LineId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.LineId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AllLineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllLineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllLineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllLines) > 0 {
		for k := range m.AllLines {
			v := m.AllLines[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBattle(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaxNum != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.MaxNum))
		i--
		dAtA[i] = 0x10
	}
	if m.MapId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.MapId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BossBattleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossBattleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BossBattleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransPos != nil {
		{
			size, err := m.TransPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBattle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Line != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x38
	}
	if m.MapId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.MapId))
		i--
		dAtA[i] = 0x30
	}
	if m.BattleId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Killer) > 0 {
		i -= len(m.Killer)
		copy(dAtA[i:], m.Killer)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Killer)))
		i--
		dAtA[i] = 0x22
	}
	if m.RefreshTime != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.RefreshTime))
		i--
		dAtA[i] = 0x18
	}
	if m.IsDead {
		i--
		if m.IsDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BossId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.BossId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BossInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BossInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BossInfo) > 0 {
		for k := range m.BossInfo {
			v := m.BossInfo[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBattle(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintBattle(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBattle(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BossId != 0 {
		i = encodeVarintBattle(dAtA, i, uint64(m.BossId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SingleBattleSetAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleBattleSetAttr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleBattleSetAttr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HeroInfos) > 0 {
		for iNdEx := len(m.HeroInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HeroInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBattle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ObjectId) > 0 {
		i -= len(m.ObjectId)
		copy(dAtA[i:], m.ObjectId)
		i = encodeVarintBattle(dAtA, i, uint64(len(m.ObjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBattle(dAtA []byte, offset int, v uint64) int {
	offset -= sovBattle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *Vec2) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if math.Abs(float64(m.X)) > 0.000001 {
		w.RawByte('"')
		w.RawString("x")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.X))
		needWriteComma = true
	}
	if math.Abs(float64(m.Y)) > 0.000001 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("y")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.Y))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *PosAndDir) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("pos")
	w.RawByte('"')
	w.RawByte(':')
	m.Pos.JsonBytes(w)
	needWriteComma = true
	if math.Abs(float64(m.Dir)) > 0.000001 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("dir")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.Dir))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *HeroAttrInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.ConfigId != 0 {
		w.RawByte('"')
		w.RawString("config_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ConfigId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("attr")
	w.RawByte('"')
	w.RawByte(':')
	if m.Attr == nil {
		w.RawString("null")
	} else if len(m.Attr) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttr := len(m.Attr)
		for k, v := range m.Attr {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAttr--
			if mlAttr != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *HeroForBattle) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.ConfigId != 0 {
		w.RawByte('"')
		w.RawString("config_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ConfigId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("attr")
	w.RawByte('"')
	w.RawByte(':')
	if m.Attr == nil {
		w.RawString("null")
	} else if len(m.Attr) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttr := len(m.Attr)
		for k, v := range m.Attr {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAttr--
			if mlAttr != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("equip")
	w.RawByte('"')
	w.RawByte(':')
	if m.Equip == nil {
		w.RawString("null")
	} else if len(m.Equip) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlEquip := len(m.Equip)
		for k, v := range m.Equip {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlEquip--
			if mlEquip != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.HeroStatus != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("hero_status")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.HeroStatus))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("skill_ids")
	w.RawByte('"')
	w.RawByte(':')
	if m.SkillIds == nil {
		w.RawString("null")
	} else if len(m.SkillIds) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.SkillIds {
			v.JsonBytes(w)
			if i != len(m.SkillIds)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("buff_ids")
	w.RawByte('"')
	w.RawByte(':')
	if m.BuffIds == nil {
		w.RawString("null")
	} else if len(m.BuffIds) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.BuffIds {
			w.Int64(int64(v))
			if i != len(m.BuffIds)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("talent_buff")
	w.RawByte('"')
	w.RawByte(':')
	if m.TalentBuff == nil {
		w.RawString("null")
	} else if len(m.TalentBuff) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.TalentBuff {
			w.Int64(int64(v))
			if i != len(m.TalentBuff)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("equip_light_effect")
	w.RawByte('"')
	w.RawByte(':')
	if m.EquipLightEffect == nil {
		w.RawString("null")
	} else if len(m.EquipLightEffect) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlEquipLightEffect := len(m.EquipLightEffect)
		for k, v := range m.EquipLightEffect {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlEquipLightEffect--
			if mlEquipLightEffect != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.Fashion != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("fashion")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Fashion))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MedicineInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.CdTime != 0 {
		w.RawByte('"')
		w.RawString("cd_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CdTime))
		needWriteComma = true
	}
	if m.Open != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("open")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Open))
		needWriteComma = true
	}
	if m.AutoTake != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("auto_take")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AutoTake))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *TempBag) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.StartTime != 0 {
		w.RawByte('"')
		w.RawString("start_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.StartTime))
		needWriteComma = true
	}
	if m.KillMonster != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("kill_monster")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.KillMonster))
		needWriteComma = true
	}
	if m.KillBoss != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("kill_boss")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.KillBoss))
		needWriteComma = true
	}
	if m.TakeMedicine != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("take_medicine")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.TakeMedicine))
		needWriteComma = true
	}
	if m.DeadCount != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("dead_count")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DeadCount))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("items")
	w.RawByte('"')
	w.RawByte(':')
	if m.Items == nil {
		w.RawString("null")
	} else if len(m.Items) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlItems := len(m.Items)
		for k, v := range m.Items {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlItems--
			if mlItems != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if math.Abs(float64(m.ExpProfit)) > 0.000001 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("exp_profit")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.ExpProfit))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RoleTempBag) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.RoleId != "" {
		w.RawByte('"')
		w.RawString("role_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.RoleId)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("temp_bag")
	w.RawByte('"')
	w.RawByte(':')
	m.TempBag.JsonBytes(w)
	needWriteComma = true
	if m.MapId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("map_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MapId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *SinglePlayerInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("role")
	w.RawByte('"')
	w.RawByte(':')
	m.Role.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("heroes")
	w.RawByte('"')
	w.RawByte(':')
	if m.Heroes == nil {
		w.RawString("null")
	} else if len(m.Heroes) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Heroes {
			v.JsonBytes(w)
			if i != len(m.Heroes)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("buffs")
	w.RawByte('"')
	w.RawByte(':')
	if m.Buffs == nil {
		w.RawString("null")
	} else if len(m.Buffs) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Buffs {
			v.JsonBytes(w)
			if i != len(m.Buffs)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *BuffInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.BuffId != 0 {
		w.RawByte('"')
		w.RawString("buff_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuffId))
		needWriteComma = true
	}
	if m.Overlay != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("overlay")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Overlay))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MonsterInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.MonsterId != 0 {
		w.RawByte('"')
		w.RawString("monster_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MonsterId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("attr")
	w.RawByte('"')
	w.RawByte(':')
	if m.Attr == nil {
		w.RawString("null")
	} else if len(m.Attr) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttr := len(m.Attr)
		for k, v := range m.Attr {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAttr--
			if mlAttr != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.AreaId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("area_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AreaId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *SingleBattleParam) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("role")
	w.RawByte('"')
	w.RawByte(':')
	m.Role.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("heroes")
	w.RawByte('"')
	w.RawByte(':')
	if m.Heroes == nil {
		w.RawString("null")
	} else if len(m.Heroes) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Heroes {
			v.JsonBytes(w)
			if i != len(m.Heroes)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("medicine")
	w.RawByte('"')
	w.RawByte(':')
	if m.Medicine == nil {
		w.RawString("null")
	} else if len(m.Medicine) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMedicine := len(m.Medicine)
		for k, v := range m.Medicine {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlMedicine--
			if mlMedicine != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("monster_group_info")
	w.RawByte('"')
	w.RawByte(':')
	if m.MonsterGroupInfo == nil {
		w.RawString("null")
	} else if len(m.MonsterGroupInfo) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMonsterGroupInfo := len(m.MonsterGroupInfo)
		for k, v := range m.MonsterGroupInfo {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlMonsterGroupInfo--
			if mlMonsterGroupInfo != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.CountDown != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("count_down")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CountDown))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("hostile_players")
	w.RawByte('"')
	w.RawByte(':')
	if m.HostilePlayers == nil {
		w.RawString("null")
	} else if len(m.HostilePlayers) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.HostilePlayers {
			v.JsonBytes(w)
			if i != len(m.HostilePlayers)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("pad")
	w.RawByte('"')
	w.RawByte(':')
	m.Pad.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("own_buffs")
	w.RawByte('"')
	w.RawByte(':')
	if m.OwnBuffs == nil {
		w.RawString("null")
	} else if len(m.OwnBuffs) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.OwnBuffs {
			v.JsonBytes(w)
			if i != len(m.OwnBuffs)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("monster_buffs")
	w.RawByte('"')
	w.RawByte(':')
	if m.MonsterBuffs == nil {
		w.RawString("null")
	} else if len(m.MonsterBuffs) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.MonsterBuffs {
			v.JsonBytes(w)
			if i != len(m.MonsterBuffs)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("monsters")
	w.RawByte('"')
	w.RawByte(':')
	if m.Monsters == nil {
		w.RawString("null")
	} else if len(m.Monsters) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Monsters {
			v.JsonBytes(w)
			if i != len(m.Monsters)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.AutoSoulSkill != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("auto_soul_skill")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AutoSoulSkill))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *GmSingleBattleMonsterParam) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.MonsterId != 0 {
		w.RawByte('"')
		w.RawString("monster_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MonsterId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("pos")
	w.RawByte('"')
	w.RawByte(':')
	m.Pos.JsonBytes(w)
	needWriteComma = true
	if m.Id != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Id)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("to_ward")
	w.RawByte('"')
	w.RawByte(':')
	m.ToWard.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("add_buffs")
	w.RawByte('"')
	w.RawByte(':')
	if m.AddBuffs == nil {
		w.RawString("null")
	} else if len(m.AddBuffs) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.AddBuffs {
			v.JsonBytes(w)
			if i != len(m.AddBuffs)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *GmSingleBattleAddBuff) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.ObjectId != "" {
		w.RawByte('"')
		w.RawString("object_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ObjectId)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("add_buffs")
	w.RawByte('"')
	w.RawByte(':')
	if m.AddBuffs == nil {
		w.RawString("null")
	} else if len(m.AddBuffs) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.AddBuffs {
			v.JsonBytes(w)
			if i != len(m.AddBuffs)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Bot) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.RoleId != "" {
		w.RawByte('"')
		w.RawString("role_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.RoleId)
		needWriteComma = true
	}
	if m.Nickname != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("nickname")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Nickname)
		needWriteComma = true
	}
	if m.RobotId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("robot_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RobotId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RlBattleRoom) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Door != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("door")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Door))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *LineInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.LineId != 0 {
		w.RawByte('"')
		w.RawString("line_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LineId))
		needWriteComma = true
	}
	if m.BattleServerId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_server_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleServerId))
		needWriteComma = true
	}
	if m.CurNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("cur_num")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurNum))
		needWriteComma = true
	}
	if m.Ip != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ip")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Ip)
		needWriteComma = true
	}
	if m.Port != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("port")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Port))
		needWriteComma = true
	}
	if m.Status != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("status")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Status))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *AllLineInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.MapId != 0 {
		w.RawByte('"')
		w.RawString("map_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MapId))
		needWriteComma = true
	}
	if m.MaxNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("max_num")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MaxNum))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("all_lines")
	w.RawByte('"')
	w.RawByte(':')
	if m.AllLines == nil {
		w.RawString("null")
	} else if len(m.AllLines) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAllLines := len(m.AllLines)
		for k, v := range m.AllLines {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlAllLines--
			if mlAllLines != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *BossBattleInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.BossId != 0 {
		w.RawByte('"')
		w.RawString("boss_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BossId))
		needWriteComma = true
	}
	if m.IsDead {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_dead")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsDead)
		needWriteComma = true
	}
	if m.RefreshTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("refresh_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RefreshTime))
		needWriteComma = true
	}
	if m.Killer != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("killer")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Killer)
		needWriteComma = true
	}
	if m.BattleId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleId))
		needWriteComma = true
	}
	if m.MapId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("map_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MapId))
		needWriteComma = true
	}
	if m.Line != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("line")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Line))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("trans_pos")
	w.RawByte('"')
	w.RawByte(':')
	m.TransPos.JsonBytes(w)
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *BossInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.BossId != 0 {
		w.RawByte('"')
		w.RawString("boss_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BossId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("boss_info")
	w.RawByte('"')
	w.RawByte(':')
	if m.BossInfo == nil {
		w.RawString("null")
	} else if len(m.BossInfo) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlBossInfo := len(m.BossInfo)
		for k, v := range m.BossInfo {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlBossInfo--
			if mlBossInfo != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *SingleBattleSetAttr) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.ObjectId != "" {
		w.RawByte('"')
		w.RawString("object_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ObjectId)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("hero_infos")
	w.RawByte('"')
	w.RawByte(':')
	if m.HeroInfos == nil {
		w.RawString("null")
	} else if len(m.HeroInfos) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.HeroInfos {
			v.JsonBytes(w)
			if i != len(m.HeroInfos)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Vec2) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Vec2) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Vec2) GoString() string {
	return m.String()
}

func (m *PosAndDir) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *PosAndDir) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *PosAndDir) GoString() string {
	return m.String()
}

func (m *HeroAttrInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *HeroAttrInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *HeroAttrInfo) GoString() string {
	return m.String()
}

func (m *HeroForBattle) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *HeroForBattle) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *HeroForBattle) GoString() string {
	return m.String()
}

func (m *MedicineInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MedicineInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MedicineInfo) GoString() string {
	return m.String()
}

func (m *TempBag) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *TempBag) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *TempBag) GoString() string {
	return m.String()
}

func (m *RoleTempBag) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RoleTempBag) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RoleTempBag) GoString() string {
	return m.String()
}

func (m *SinglePlayerInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *SinglePlayerInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *SinglePlayerInfo) GoString() string {
	return m.String()
}

func (m *BuffInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *BuffInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *BuffInfo) GoString() string {
	return m.String()
}

func (m *MonsterInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MonsterInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MonsterInfo) GoString() string {
	return m.String()
}

func (m *SingleBattleParam) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *SingleBattleParam) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *SingleBattleParam) GoString() string {
	return m.String()
}

func (m *GmSingleBattleMonsterParam) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *GmSingleBattleMonsterParam) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *GmSingleBattleMonsterParam) GoString() string {
	return m.String()
}

func (m *GmSingleBattleAddBuff) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *GmSingleBattleAddBuff) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *GmSingleBattleAddBuff) GoString() string {
	return m.String()
}

func (m *Bot) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Bot) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Bot) GoString() string {
	return m.String()
}

func (m *RlBattleRoom) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RlBattleRoom) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RlBattleRoom) GoString() string {
	return m.String()
}

func (m *LineInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *LineInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *LineInfo) GoString() string {
	return m.String()
}

func (m *AllLineInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *AllLineInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *AllLineInfo) GoString() string {
	return m.String()
}

func (m *BossBattleInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *BossBattleInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *BossBattleInfo) GoString() string {
	return m.String()
}

func (m *BossInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *BossInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *BossInfo) GoString() string {
	return m.String()
}

func (m *SingleBattleSetAttr) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *SingleBattleSetAttr) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *SingleBattleSetAttr) GoString() string {
	return m.String()
}

func (m *Vec2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	return n
}

func (m *PosAndDir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Dir != 0 {
		n += 5
	}
	return n
}

func (m *HeroAttrInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigId != 0 {
		n += 1 + sovBattle(uint64(m.ConfigId))
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HeroForBattle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigId != 0 {
		n += 1 + sovBattle(uint64(m.ConfigId))
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if len(m.Equip) > 0 {
		for k, v := range m.Equip {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if m.HeroStatus != 0 {
		n += 1 + sovBattle(uint64(m.HeroStatus))
	}
	if len(m.SkillIds) > 0 {
		for _, e := range m.SkillIds {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.BuffIds) > 0 {
		l = 0
		for _, e := range m.BuffIds {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.TalentBuff) > 0 {
		l = 0
		for _, e := range m.TalentBuff {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.EquipLightEffect) > 0 {
		for k, v := range m.EquipLightEffect {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if m.Fashion != 0 {
		n += 1 + sovBattle(uint64(m.Fashion))
	}
	return n
}

func (m *MedicineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CdTime != 0 {
		n += 1 + sovBattle(uint64(m.CdTime))
	}
	if m.Open != 0 {
		n += 1 + sovBattle(uint64(m.Open))
	}
	if m.AutoTake != 0 {
		n += 1 + sovBattle(uint64(m.AutoTake))
	}
	return n
}

func (m *TempBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovBattle(uint64(m.StartTime))
	}
	if m.KillMonster != 0 {
		n += 1 + sovBattle(uint64(m.KillMonster))
	}
	if m.KillBoss != 0 {
		n += 1 + sovBattle(uint64(m.KillBoss))
	}
	if m.TakeMedicine != 0 {
		n += 1 + sovBattle(uint64(m.TakeMedicine))
	}
	if m.DeadCount != 0 {
		n += 1 + sovBattle(uint64(m.DeadCount))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if m.ExpProfit != 0 {
		n += 9
	}
	return n
}

func (m *RoleTempBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.TempBag != nil {
		l = m.TempBag.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.MapId != 0 {
		n += 1 + sovBattle(uint64(m.MapId))
	}
	return n
}

func (m *SinglePlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.Heroes) > 0 {
		for _, e := range m.Heroes {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.Buffs) > 0 {
		for _, e := range m.Buffs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *BuffInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BuffId != 0 {
		n += 1 + sovBattle(uint64(m.BuffId))
	}
	if m.Overlay != 0 {
		n += 1 + sovBattle(uint64(m.Overlay))
	}
	return n
}

func (m *MonsterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonsterId != 0 {
		n += 1 + sovBattle(uint64(m.MonsterId))
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if m.AreaId != 0 {
		n += 1 + sovBattle(uint64(m.AreaId))
	}
	return n
}

func (m *SingleBattleParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.Heroes) > 0 {
		for _, e := range m.Heroes {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.Medicine) > 0 {
		for k, v := range m.Medicine {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBattle(uint64(l))
			}
			mapEntrySize := 1 + sovBattle(uint64(k)) + l
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if len(m.MonsterGroupInfo) > 0 {
		for k, v := range m.MonsterGroupInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBattle(uint64(k)) + 1 + sovBattle(uint64(v))
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	if m.CountDown != 0 {
		n += 1 + sovBattle(uint64(m.CountDown))
	}
	if len(m.HostilePlayers) > 0 {
		for _, e := range m.HostilePlayers {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.Pad != nil {
		l = m.Pad.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.OwnBuffs) > 0 {
		for _, e := range m.OwnBuffs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.MonsterBuffs) > 0 {
		for _, e := range m.MonsterBuffs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.Monsters) > 0 {
		for _, e := range m.Monsters {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.AutoSoulSkill != 0 {
		n += 1 + sovBattle(uint64(m.AutoSoulSkill))
	}
	return n
}

func (m *GmSingleBattleMonsterParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonsterId != 0 {
		n += 1 + sovBattle(uint64(m.MonsterId))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.ToWard != nil {
		l = m.ToWard.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.AddBuffs) > 0 {
		for _, e := range m.AddBuffs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *GmSingleBattleAddBuff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.AddBuffs) > 0 {
		for _, e := range m.AddBuffs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *Bot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.RobotId != 0 {
		n += 1 + sovBattle(uint64(m.RobotId))
	}
	return n
}

func (m *RlBattleRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBattle(uint64(m.Id))
	}
	if m.Door != 0 {
		n += 1 + sovBattle(uint64(m.Door))
	}
	return n
}

func (m *LineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LineId != 0 {
		n += 1 + sovBattle(uint64(m.LineId))
	}
	if m.BattleServerId != 0 {
		n += 1 + sovBattle(uint64(m.BattleServerId))
	}
	if m.CurNum != 0 {
		n += 1 + sovBattle(uint64(m.CurNum))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovBattle(uint64(m.Port))
	}
	if m.Status != 0 {
		n += 1 + sovBattle(uint64(m.Status))
	}
	return n
}

func (m *AllLineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapId != 0 {
		n += 1 + sovBattle(uint64(m.MapId))
	}
	if m.MaxNum != 0 {
		n += 1 + sovBattle(uint64(m.MaxNum))
	}
	if len(m.AllLines) > 0 {
		for k, v := range m.AllLines {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBattle(uint64(l))
			}
			mapEntrySize := 1 + sovBattle(uint64(k)) + l
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BossBattleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BossId != 0 {
		n += 1 + sovBattle(uint64(m.BossId))
	}
	if m.IsDead {
		n += 2
	}
	if m.RefreshTime != 0 {
		n += 1 + sovBattle(uint64(m.RefreshTime))
	}
	l = len(m.Killer)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.BattleId != 0 {
		n += 1 + sovBattle(uint64(m.BattleId))
	}
	if m.MapId != 0 {
		n += 1 + sovBattle(uint64(m.MapId))
	}
	if m.Line != 0 {
		n += 1 + sovBattle(uint64(m.Line))
	}
	if m.TransPos != nil {
		l = m.TransPos.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *BossInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BossId != 0 {
		n += 1 + sovBattle(uint64(m.BossId))
	}
	if len(m.BossInfo) > 0 {
		for k, v := range m.BossInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBattle(uint64(l))
			}
			mapEntrySize := 1 + sovBattle(uint64(k)) + l
			n += mapEntrySize + 1 + sovBattle(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SingleBattleSetAttr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectId)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.HeroInfos) > 0 {
		for _, e := range m.HeroInfos {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func sovBattle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBattle(x uint64) (n int) {
	return sovBattle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Vec2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vec2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vec2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PosAndDir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PosAndDir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PosAndDir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vec2{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Dir = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroAttrInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroAttrInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroAttrInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigId", wireType)
			}
			m.ConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroForBattle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroForBattle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroForBattle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigId", wireType)
			}
			m.ConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equip[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroStatus", wireType)
			}
			m.HeroStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillIds = append(m.SkillIds, &HeroSkillAndStone{})
			if err := m.SkillIds[len(m.SkillIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffIds = append(m.BuffIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBattle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffIds) == 0 {
					m.BuffIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffIds = append(m.BuffIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffIds", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TalentBuff = append(m.TalentBuff, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBattle
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TalentBuff) == 0 {
					m.TalentBuff = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TalentBuff = append(m.TalentBuff, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TalentBuff", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipLightEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquipLightEffect == nil {
				m.EquipLightEffect = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EquipLightEffect[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fashion", wireType)
			}
			m.Fashion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fashion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedicineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedicineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedicineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			m.CdTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CdTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			m.Open = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Open |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoTake", wireType)
			}
			m.AutoTake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoTake |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TempBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TempBag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TempBag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillMonster", wireType)
			}
			m.KillMonster = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillMonster |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillBoss", wireType)
			}
			m.KillBoss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillBoss |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakeMedicine", wireType)
			}
			m.TakeMedicine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TakeMedicine |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadCount", wireType)
			}
			m.DeadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExpProfit = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleTempBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleTempBag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleTempBag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TempBag == nil {
				m.TempBag = &TempBag{}
			}
			if err := m.TempBag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SinglePlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SinglePlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SinglePlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &Role{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heroes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heroes = append(m.Heroes, &HeroForBattle{})
			if err := m.Heroes[len(m.Heroes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffs = append(m.Buffs, &BuffInfo{})
			if err := m.Buffs[len(m.Buffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlay", wireType)
			}
			m.Overlay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Overlay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonsterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonsterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonsterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			m.MonsterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleBattleParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleBattleParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleBattleParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &Role{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heroes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heroes = append(m.Heroes, &HeroForBattle{})
			if err := m.Heroes[len(m.Heroes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medicine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Medicine == nil {
				m.Medicine = make(map[int64]*MedicineInfo)
			}
			var mapkey int64
			var mapvalue *MedicineInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBattle
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBattle
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MedicineInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Medicine[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterGroupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonsterGroupInfo == nil {
				m.MonsterGroupInfo = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MonsterGroupInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDown", wireType)
			}
			m.CountDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDown |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostilePlayers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostilePlayers = append(m.HostilePlayers, &SinglePlayerInfo{})
			if err := m.HostilePlayers[len(m.HostilePlayers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pad", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pad == nil {
				m.Pad = &PosAndDir{}
			}
			if err := m.Pad.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnBuffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnBuffs = append(m.OwnBuffs, &BuffInfo{})
			if err := m.OwnBuffs[len(m.OwnBuffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterBuffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonsterBuffs = append(m.MonsterBuffs, &BuffInfo{})
			if err := m.MonsterBuffs[len(m.MonsterBuffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monsters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Monsters = append(m.Monsters, &MonsterInfo{})
			if err := m.Monsters[len(m.Monsters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoSoulSkill", wireType)
			}
			m.AutoSoulSkill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoSoulSkill |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GmSingleBattleMonsterParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GmSingleBattleMonsterParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GmSingleBattleMonsterParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			m.MonsterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vec2{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToWard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToWard == nil {
				m.ToWard = &Vec2{}
			}
			if err := m.ToWard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddBuffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddBuffs = append(m.AddBuffs, &BuffInfo{})
			if err := m.AddBuffs[len(m.AddBuffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GmSingleBattleAddBuff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GmSingleBattleAddBuff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GmSingleBattleAddBuff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddBuffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddBuffs = append(m.AddBuffs, &BuffInfo{})
			if err := m.AddBuffs[len(m.AddBuffs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotId", wireType)
			}
			m.RobotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RlBattleRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RlBattleRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RlBattleRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Door", wireType)
			}
			m.Door = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Door |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineId", wireType)
			}
			m.LineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LineId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleServerId", wireType)
			}
			m.BattleServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurNum", wireType)
			}
			m.CurNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllLineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllLineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllLineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNum", wireType)
			}
			m.MaxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllLines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllLines == nil {
				m.AllLines = make(map[int64]*LineInfo)
			}
			var mapkey int64
			var mapvalue *LineInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBattle
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBattle
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LineInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AllLines[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossBattleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossBattleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossBattleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossId", wireType)
			}
			m.BossId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDead = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTime", wireType)
			}
			m.RefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Killer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleId", wireType)
			}
			m.BattleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransPos == nil {
				m.TransPos = &Vec2{}
			}
			if err := m.TransPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BossInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BossInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossId", wireType)
			}
			m.BossId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BossInfo == nil {
				m.BossInfo = make(map[int64]*BossBattleInfo)
			}
			var mapkey int64
			var mapvalue *BossBattleInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBattle
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBattle
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BossBattleInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBattle(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBattle
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BossInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleBattleSetAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleBattleSetAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleBattleSetAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBattle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeroInfos = append(m.HeroInfos, &HeroAttrInfo{})
			if err := m.HeroInfos[len(m.HeroInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBattle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBattle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBattle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBattle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBattle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBattle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBattle = fmt.Errorf("proto: unexpected end of group")
)
