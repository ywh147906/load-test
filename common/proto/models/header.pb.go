// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/models/header.proto

package models

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgType int32

const (
	MsgType_invalid_msg_type MsgType = 0
	MsgType_request          MsgType = 1
	MsgType_response         MsgType = 2
	MsgType_push             MsgType = 3
	MsgType_internal         MsgType = 4
)

var MsgType_name = map[int32]string{
	0: "invalid_msg_type",
	1: "request",
	2: "response",
	3: "push",
	4: "internal",
}

var MsgType_value = map[string]int32{
	"invalid_msg_type": 0,
	"request":          1,
	"response":         2,
	"push":             3,
	"internal":         4,
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{0}
}

type ServerType int32

const (
	ServerType_Unknown               ServerType = 0
	ServerType_GatewayHttp           ServerType = 1
	ServerType_GameServer            ServerType = 2
	ServerType_AuthServer            ServerType = 3
	ServerType_GatewayStdTcp         ServerType = 4
	ServerType_EdgeServer            ServerType = 5
	ServerType_BattleServer          ServerType = 6
	ServerType_LoadTest              ServerType = 7
	ServerType_GuildFilterServer     ServerType = 8
	ServerType_RecommendServer       ServerType = 9
	ServerType_DungeonMatchServer    ServerType = 10
	ServerType_GenRankServer         ServerType = 11
	ServerType_BattleCopyServer      ServerType = 12
	ServerType_RoleStateServer       ServerType = 13
	ServerType_RankServer            ServerType = 14
	ServerType_CenterServer          ServerType = 15
	ServerType_RoguelikeMatchServer  ServerType = 16
	ServerType_ArenaServer           ServerType = 17
	ServerType_RacingRankServer      ServerType = 18
	ServerType_NewCenterServer       ServerType = 19
	ServerType_ActivityServer        ServerType = 20
	ServerType_ActivityRankingServer ServerType = 21
	ServerType_PayServer             ServerType = 22
	ServerType_FashionServer         ServerType = 23
	ServerType_NoticeServer          ServerType = 24
	ServerType_GVGGuildServer        ServerType = 25
	ServerType_GMServer              ServerType = 100
)

var ServerType_name = map[int32]string{
	0:   "Unknown",
	1:   "GatewayHttp",
	2:   "GameServer",
	3:   "AuthServer",
	4:   "GatewayStdTcp",
	5:   "EdgeServer",
	6:   "BattleServer",
	7:   "LoadTest",
	8:   "GuildFilterServer",
	9:   "RecommendServer",
	10:  "DungeonMatchServer",
	11:  "GenRankServer",
	12:  "BattleCopyServer",
	13:  "RoleStateServer",
	14:  "RankServer",
	15:  "CenterServer",
	16:  "RoguelikeMatchServer",
	17:  "ArenaServer",
	18:  "RacingRankServer",
	19:  "NewCenterServer",
	20:  "ActivityServer",
	21:  "ActivityRankingServer",
	22:  "PayServer",
	23:  "FashionServer",
	24:  "NoticeServer",
	25:  "GVGGuildServer",
	100: "GMServer",
}

var ServerType_value = map[string]int32{
	"Unknown":               0,
	"GatewayHttp":           1,
	"GameServer":            2,
	"AuthServer":            3,
	"GatewayStdTcp":         4,
	"EdgeServer":            5,
	"BattleServer":          6,
	"LoadTest":              7,
	"GuildFilterServer":     8,
	"RecommendServer":       9,
	"DungeonMatchServer":    10,
	"GenRankServer":         11,
	"BattleCopyServer":      12,
	"RoleStateServer":       13,
	"RankServer":            14,
	"CenterServer":          15,
	"RoguelikeMatchServer":  16,
	"ArenaServer":           17,
	"RacingRankServer":      18,
	"NewCenterServer":       19,
	"ActivityServer":        20,
	"ActivityRankingServer": 21,
	"PayServer":             22,
	"FashionServer":         23,
	"NoticeServer":          24,
	"GVGGuildServer":        25,
	"GMServer":              100,
}

func (ServerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{1}
}

type ErrorType int32

const (
	ErrorType_NoError     ErrorType = 0
	ErrorType_ErrorNormal ErrorType = 1
	// 大于 1 ,客户端统一显示服务器内部错误
	ErrorType_ErrorProtocol         ErrorType = 2
	ErrorType_ErrorPanic            ErrorType = 3
	ErrorType_ErrorDB               ErrorType = 4
	ErrorType_ErrorNoLogin          ErrorType = 5
	ErrorType_ErrorNatsNoResponders ErrorType = 6
)

var ErrorType_name = map[int32]string{
	0: "NoError",
	1: "ErrorNormal",
	2: "ErrorProtocol",
	3: "ErrorPanic",
	4: "ErrorDB",
	5: "ErrorNoLogin",
	6: "ErrorNatsNoResponders",
}

var ErrorType_value = map[string]int32{
	"NoError":               0,
	"ErrorNormal":           1,
	"ErrorProtocol":         2,
	"ErrorPanic":            3,
	"ErrorDB":               4,
	"ErrorNoLogin":          5,
	"ErrorNatsNoResponders": 6,
}

func (ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{2}
}

type Resp struct {
	ErrCode         ErrorType    `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=models.ErrorType" json:"err_code,omitempty"`
	ErrMsg          string       `protobuf:"bytes,2,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
	ErrInternalInfo string       `protobuf:"bytes,3,opt,name=err_internal_info,json=errInternalInfo,proto3" json:"err_internal_info,omitempty"`
	Resp            *types.Any   `protobuf:"bytes,4,opt,name=resp,proto3" json:"resp,omitempty"`
	OtherMsg        []*types.Any `protobuf:"bytes,5,rep,name=other_msg,json=otherMsg,proto3" json:"other_msg,omitempty"`
	OtherRequest    []string     `protobuf:"bytes,6,rep,name=other_request,json=otherRequest,proto3" json:"other_request,omitempty"`
	StackStace      []uint64     `protobuf:"varint,7,rep,packed,name=stack_stace,json=stackStace,proto3" json:"stack_stace,omitempty"`
}

func (m *Resp) Reset()      { *m = Resp{} }
func (*Resp) ProtoMessage() {}
func (*Resp) Descriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{0}
}
func (m *Resp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resp.Merge(m, src)
}
func (m *Resp) XXX_Size() int {
	return m.Size()
}
func (m *Resp) XXX_DiscardUnknown() {
	xxx_messageInfo_Resp.DiscardUnknown(m)
}

var xxx_messageInfo_Resp proto.InternalMessageInfo

func (m *Resp) GetErrCode() ErrorType {
	if m != nil {
		return m.ErrCode
	}
	return ErrorType_NoError
}

func (m *Resp) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *Resp) GetErrInternalInfo() string {
	if m != nil {
		return m.ErrInternalInfo
	}
	return ""
}

func (m *Resp) GetResp() *types.Any {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *Resp) GetOtherMsg() []*types.Any {
	if m != nil {
		return m.OtherMsg
	}
	return nil
}

func (m *Resp) GetOtherRequest() []string {
	if m != nil {
		return m.OtherRequest
	}
	return nil
}

func (m *Resp) GetStackStace() []uint64 {
	if m != nil {
		return m.StackStace
	}
	return nil
}

func (*Resp) XXX_MessageName() string {
	return "models.Resp"
}

type ServerHeader struct {
	StartTime         int64      `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	RoleId            string     `protobuf:"bytes,2,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	ServerId          int64      `protobuf:"varint,3,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ServerType        ServerType `protobuf:"varint,4,opt,name=server_type,json=serverType,proto3,enum=models.ServerType" json:"server_type,omitempty"`
	RuleVersion       string     `protobuf:"bytes,5,opt,name=rule_version,json=ruleVersion,proto3" json:"rule_version,omitempty"`
	TraceId           string     `protobuf:"bytes,6,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	GateId            int64      `protobuf:"varint,7,opt,name=gate_id,json=gateId,proto3" json:"gate_id,omitempty"`
	UserId            string     `protobuf:"bytes,8,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	InServerId        int64      `protobuf:"varint,9,opt,name=in_server_id,json=inServerId,proto3" json:"in_server_id,omitempty"`
	BattleServerId    int64      `protobuf:"varint,10,opt,name=battle_server_id,json=battleServerId,proto3" json:"battle_server_id,omitempty"`
	BattleMapId       int64      `protobuf:"varint,11,opt,name=battle_map_id,json=battleMapId,proto3" json:"battle_map_id,omitempty"`
	StateLessServerId int64      `protobuf:"varint,12,opt,name=state_less_server_id,json=stateLessServerId,proto3" json:"state_less_server_id,omitempty"`
	Ip                string     `protobuf:"bytes,13,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *ServerHeader) Reset()      { *m = ServerHeader{} }
func (*ServerHeader) ProtoMessage() {}
func (*ServerHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{1}
}
func (m *ServerHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerHeader.Merge(m, src)
}
func (m *ServerHeader) XXX_Size() int {
	return m.Size()
}
func (m *ServerHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ServerHeader proto.InternalMessageInfo

func (m *ServerHeader) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ServerHeader) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *ServerHeader) GetServerId() int64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *ServerHeader) GetServerType() ServerType {
	if m != nil {
		return m.ServerType
	}
	return ServerType_Unknown
}

func (m *ServerHeader) GetRuleVersion() string {
	if m != nil {
		return m.RuleVersion
	}
	return ""
}

func (m *ServerHeader) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *ServerHeader) GetGateId() int64 {
	if m != nil {
		return m.GateId
	}
	return 0
}

func (m *ServerHeader) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *ServerHeader) GetInServerId() int64 {
	if m != nil {
		return m.InServerId
	}
	return 0
}

func (m *ServerHeader) GetBattleServerId() int64 {
	if m != nil {
		return m.BattleServerId
	}
	return 0
}

func (m *ServerHeader) GetBattleMapId() int64 {
	if m != nil {
		return m.BattleMapId
	}
	return 0
}

func (m *ServerHeader) GetStateLessServerId() int64 {
	if m != nil {
		return m.StateLessServerId
	}
	return 0
}

func (m *ServerHeader) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (*ServerHeader) XXX_MessageName() string {
	return "models.ServerHeader"
}

type PING struct {
	Now int64 `protobuf:"varint,1,opt,name=now,proto3" json:"now,omitempty"`
}

func (m *PING) Reset()      { *m = PING{} }
func (*PING) ProtoMessage() {}
func (*PING) Descriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{2}
}
func (m *PING) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PING) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PING.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PING) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PING.Merge(m, src)
}
func (m *PING) XXX_Size() int {
	return m.Size()
}
func (m *PING) XXX_DiscardUnknown() {
	xxx_messageInfo_PING.DiscardUnknown(m)
}

var xxx_messageInfo_PING proto.InternalMessageInfo

func (m *PING) GetNow() int64 {
	if m != nil {
		return m.Now
	}
	return 0
}

func (*PING) XXX_MessageName() string {
	return "models.PING"
}

type PONG struct {
}

func (m *PONG) Reset()      { *m = PONG{} }
func (*PONG) ProtoMessage() {}
func (*PONG) Descriptor() ([]byte, []int) {
	return fileDescriptor_20b87ceb57276784, []int{3}
}
func (m *PONG) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PONG) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PONG.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PONG) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PONG.Merge(m, src)
}
func (m *PONG) XXX_Size() int {
	return m.Size()
}
func (m *PONG) XXX_DiscardUnknown() {
	xxx_messageInfo_PONG.DiscardUnknown(m)
}

var xxx_messageInfo_PONG proto.InternalMessageInfo

func (*PONG) XXX_MessageName() string {
	return "models.PONG"
}
func init() {
	proto.RegisterEnum("models.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("models.ServerType", ServerType_name, ServerType_value)
	proto.RegisterEnum("models.ErrorType", ErrorType_name, ErrorType_value)
	proto.RegisterType((*Resp)(nil), "models.Resp")
	proto.RegisterType((*ServerHeader)(nil), "models.ServerHeader")
	proto.RegisterType((*PING)(nil), "models.PING")
	proto.RegisterType((*PONG)(nil), "models.PONG")
}

func init() { proto.RegisterFile("proto/models/header.proto", fileDescriptor_20b87ceb57276784) }

var fileDescriptor_20b87ceb57276784 = []byte{
	// 968 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0x4d, 0x72, 0xdb, 0x36,
	0x14, 0x16, 0x45, 0x5a, 0x3f, 0x4f, 0x3f, 0xa6, 0x10, 0x3b, 0xa1, 0xdb, 0x29, 0xa3, 0xba, 0x1b,
	0x8d, 0xa7, 0x95, 0xa6, 0xce, 0x09, 0x6c, 0x27, 0x51, 0x34, 0x63, 0xa9, 0x1e, 0xda, 0xcd, 0xa2,
	0x1b, 0x0d, 0x4c, 0xc2, 0x14, 0xc6, 0x14, 0xc0, 0x02, 0x90, 0x3d, 0xba, 0x40, 0x57, 0x5d, 0xf4,
	0x00, 0x3d, 0x40, 0xaf, 0xd0, 0x1b, 0x64, 0x99, 0x65, 0x96, 0xad, 0xbc, 0xe9, 0xb2, 0x47, 0xe8,
	0x00, 0x20, 0x6d, 0x75, 0x91, 0x8d, 0x07, 0xef, 0x7b, 0xdf, 0x7b, 0xef, 0xc3, 0x87, 0x67, 0x0a,
	0x0e, 0x72, 0xc1, 0x15, 0x1f, 0x2d, 0x79, 0x42, 0x32, 0x39, 0x5a, 0x10, 0x9c, 0x10, 0x31, 0x34,
	0x18, 0xaa, 0x59, 0xf0, 0x8b, 0x83, 0x94, 0xf3, 0x34, 0x23, 0x23, 0x83, 0x5e, 0xaf, 0x6e, 0x46,
	0x98, 0xad, 0x2d, 0xe5, 0xf0, 0xf7, 0x2a, 0x78, 0x11, 0x91, 0x39, 0xfa, 0x16, 0x1a, 0x44, 0x88,
	0x79, 0xcc, 0x13, 0x12, 0x38, 0x7d, 0x67, 0xd0, 0x3d, 0xee, 0x0d, 0x6d, 0xf9, 0xf0, 0x8d, 0x10,
	0x5c, 0x5c, 0xad, 0x73, 0x12, 0xd5, 0x89, 0x10, 0x67, 0x3c, 0x21, 0xe8, 0x05, 0xe8, 0xe3, 0x7c,
	0x29, 0xd3, 0xa0, 0xda, 0x77, 0x06, 0xcd, 0xa8, 0x46, 0x84, 0x98, 0xca, 0x14, 0x1d, 0x41, 0x4f,
	0x27, 0x28, 0x53, 0x44, 0x30, 0x9c, 0xcd, 0x29, 0xbb, 0xe1, 0x81, 0x6b, 0x28, 0xbb, 0x44, 0x88,
	0x49, 0x81, 0x4f, 0xd8, 0x0d, 0x47, 0x03, 0xf0, 0x04, 0x91, 0x79, 0xe0, 0xf5, 0x9d, 0x41, 0xeb,
	0x78, 0x6f, 0x68, 0x55, 0x0e, 0x4b, 0x95, 0xc3, 0x13, 0xb6, 0x8e, 0x0c, 0x03, 0x7d, 0x0f, 0x4d,
	0xae, 0x16, 0xc4, 0x0e, 0xdc, 0xe9, 0xbb, 0x9f, 0xa5, 0x37, 0x0c, 0x4d, 0x0b, 0xf9, 0x06, 0x3a,
	0xb6, 0x44, 0x90, 0x9f, 0x57, 0x44, 0xaa, 0xa0, 0xd6, 0x77, 0x07, 0xcd, 0xa8, 0x6d, 0xc0, 0xc8,
	0x62, 0xe8, 0x25, 0xb4, 0xa4, 0xc2, 0xf1, 0xed, 0x5c, 0xff, 0x25, 0x41, 0xbd, 0xef, 0x0e, 0xbc,
	0x08, 0x0c, 0x74, 0xa9, 0x91, 0xc3, 0x3f, 0x5d, 0x68, 0x5f, 0x12, 0x71, 0x47, 0xc4, 0x3b, 0x63,
	0x2c, 0xfa, 0x0a, 0x74, 0x5a, 0xa8, 0xb9, 0xa2, 0x4b, 0x6b, 0x94, 0x1b, 0x35, 0x0d, 0x72, 0x45,
	0x97, 0xc6, 0x17, 0xc1, 0x33, 0x32, 0xa7, 0x49, 0xe9, 0x8b, 0x0e, 0x27, 0x09, 0xfa, 0x12, 0x9a,
	0xd2, 0xf4, 0xd1, 0x29, 0xd7, 0x94, 0x35, 0x2c, 0x30, 0x49, 0xd0, 0x2b, 0x68, 0x15, 0x49, 0xb5,
	0xce, 0x89, 0xf1, 0xa3, 0x7b, 0x8c, 0x4a, 0xfb, 0xed, 0x7c, 0xe3, 0x3f, 0xc8, 0xc7, 0x33, 0xfa,
	0x1a, 0xda, 0x62, 0x95, 0x91, 0xf9, 0x1d, 0x11, 0x92, 0x72, 0x16, 0xec, 0x98, 0x79, 0x2d, 0x8d,
	0xbd, 0xb7, 0x10, 0x3a, 0x80, 0x86, 0x12, 0x38, 0x36, 0x72, 0x6a, 0x26, 0x5d, 0x37, 0xf1, 0x24,
	0xd1, 0x42, 0x53, 0xac, 0x4c, 0xa6, 0x6e, 0xd4, 0xd4, 0x74, 0x68, 0x13, 0x2b, 0x69, 0x65, 0x36,
	0xec, 0x0d, 0x74, 0x38, 0x49, 0x50, 0x1f, 0xda, 0x94, 0xcd, 0x9f, 0x2e, 0xd1, 0x34, 0x65, 0x40,
	0xd9, 0x65, 0x79, 0x8d, 0x01, 0xf8, 0xd7, 0x58, 0xa9, 0x8c, 0x6c, 0xb1, 0xc0, 0xb0, 0xba, 0x16,
	0x7f, 0x64, 0x1e, 0x42, 0xa7, 0x60, 0x2e, 0x71, 0xae, 0x69, 0x2d, 0x43, 0x6b, 0x59, 0x70, 0x8a,
	0xf3, 0x49, 0x82, 0x46, 0xb0, 0x27, 0x95, 0x96, 0x98, 0x11, 0x29, 0xb7, 0x3a, 0xb6, 0x0d, 0xb5,
	0x67, 0x72, 0xe7, 0x44, 0xca, 0xc7, 0xa6, 0x5d, 0xa8, 0xd2, 0x3c, 0xe8, 0x18, 0xd1, 0x55, 0x9a,
	0x1f, 0x06, 0xe0, 0x5d, 0x4c, 0x66, 0x63, 0xe4, 0x83, 0xcb, 0xf8, 0x7d, 0xf1, 0x56, 0xfa, 0x78,
	0x58, 0x03, 0xef, 0xe2, 0x87, 0xd9, 0xf8, 0x28, 0x82, 0xfa, 0x54, 0xa6, 0xc6, 0xcd, 0x3d, 0xf0,
	0x29, 0xbb, 0xc3, 0x19, 0x4d, 0xf4, 0x8e, 0x99, 0x77, 0xf0, 0x2b, 0xa8, 0x05, 0xf5, 0x62, 0x7d,
	0x7c, 0x07, 0xb5, 0xa1, 0xa1, 0x97, 0x91, 0x33, 0x49, 0xfc, 0x2a, 0x6a, 0x80, 0x97, 0xaf, 0xe4,
	0xc2, 0x77, 0x35, 0x5e, 0xae, 0xbb, 0xef, 0x1d, 0xfd, 0xea, 0x01, 0x3c, 0xbd, 0x98, 0xee, 0xf0,
	0x23, 0xbb, 0x65, 0xfc, 0x9e, 0xf9, 0x15, 0xb4, 0x0b, 0xad, 0x31, 0x56, 0xe4, 0x1e, 0xaf, 0xdf,
	0x29, 0x95, 0xfb, 0x0e, 0xea, 0x02, 0x8c, 0xf1, 0xb2, 0xf0, 0xc5, 0xaf, 0xea, 0xf8, 0x64, 0xa5,
	0x16, 0x45, 0xec, 0xa2, 0x1e, 0x74, 0x8a, 0x82, 0x4b, 0x95, 0x5c, 0xc5, 0xb9, 0xef, 0x69, 0xca,
	0x9b, 0x24, 0x2d, 0x4b, 0x76, 0x90, 0x0f, 0xed, 0xd3, 0x2d, 0x73, 0xfd, 0x9a, 0xd6, 0x73, 0xce,
	0x71, 0x72, 0xa5, 0x55, 0xd7, 0xd1, 0x3e, 0xf4, 0xc6, 0x2b, 0x9a, 0x25, 0x6f, 0x69, 0xa6, 0x88,
	0x28, 0x48, 0x0d, 0xf4, 0x0c, 0x76, 0x23, 0x12, 0xf3, 0xe5, 0x92, 0xb0, 0xa4, 0x00, 0x9b, 0xe8,
	0x39, 0xa0, 0xd7, 0x2b, 0x96, 0x12, 0xce, 0xa6, 0x58, 0xc5, 0xa5, 0x0c, 0x30, 0x32, 0x08, 0x8b,
	0x30, 0xbb, 0x2d, 0xa0, 0x96, 0xf6, 0xcb, 0x8e, 0x3d, 0xe3, 0xf9, 0xba, 0x40, 0xdb, 0xa6, 0x2b,
	0xcf, 0xc8, 0xa5, 0x7e, 0x9b, 0x02, 0xec, 0x68, 0xc5, 0x5b, 0xa5, 0x5d, 0xad, 0xf8, 0x8c, 0xb0,
	0x27, 0x31, 0xbb, 0x28, 0x80, 0xbd, 0x88, 0xa7, 0x2b, 0x92, 0xd1, 0x5b, 0xb2, 0x3d, 0xd9, 0xd7,
	0x8e, 0x9d, 0x08, 0xc2, 0x70, 0x01, 0xf4, 0xf4, 0xdc, 0x08, 0xc7, 0x94, 0xa5, 0x5b, 0x2d, 0x91,
	0x9e, 0x3b, 0x23, 0xf7, 0xff, 0xeb, 0xfa, 0x0c, 0x21, 0xe8, 0x9e, 0xc4, 0x8a, 0xde, 0x51, 0x55,
	0x0a, 0xdc, 0x43, 0x07, 0xb0, 0x5f, 0x62, 0xba, 0x01, 0x65, 0x69, 0x91, 0xda, 0x47, 0x1d, 0x68,
	0x5e, 0xe0, 0x92, 0xf9, 0x5c, 0xdf, 0xf9, 0x2d, 0x96, 0x0b, 0xca, 0x8b, 0xfd, 0xf6, 0x5f, 0x68,
	0xe1, 0x33, 0xae, 0x68, 0x5c, 0x5e, 0x2d, 0xd0, 0x23, 0xc6, 0xef, 0xc7, 0xc6, 0xdf, 0x02, 0x3b,
	0xd0, 0xf6, 0x8f, 0xa7, 0x45, 0x94, 0x1c, 0xfd, 0xe2, 0x40, 0xf3, 0xf1, 0xfb, 0xa9, 0xb7, 0x61,
	0xc6, 0x4d, 0x68, 0xb7, 0xc1, 0x1c, 0x67, 0x5c, 0x2c, 0x71, 0xe6, 0x3b, 0x7a, 0xa4, 0x01, 0x2e,
	0xf4, 0x17, 0x2d, 0xe6, 0x99, 0x5d, 0x08, 0x0b, 0x61, 0x46, 0x63, 0xdf, 0xd5, 0x0d, 0x4c, 0xfc,
	0xfa, 0xd4, 0xf7, 0xb4, 0x9e, 0xa2, 0xc1, 0x39, 0x4f, 0x29, 0xf3, 0x77, 0xf4, 0xf5, 0x2c, 0x82,
	0x95, 0x9c, 0xf1, 0xc8, 0x6c, 0x6b, 0x42, 0x84, 0xf4, 0x6b, 0xa7, 0xd3, 0x4f, 0x7f, 0x87, 0x95,
	0x3f, 0x36, 0xa1, 0xf3, 0x61, 0x13, 0x3a, 0x1f, 0x37, 0xa1, 0xf3, 0xd7, 0x26, 0x74, 0xfe, 0xd9,
	0x84, 0x95, 0x7f, 0x37, 0xa1, 0xf3, 0xdb, 0x43, 0x58, 0xf9, 0xf0, 0x10, 0x3a, 0x1f, 0x1f, 0xc2,
	0xca, 0xa7, 0x87, 0xb0, 0xf2, 0xd3, 0xcb, 0x98, 0x53, 0xf6, 0x9d, 0xfd, 0xa7, 0x1b, 0xe9, 0x35,
	0xe1, 0x6c, 0xb4, 0xfd, 0x3b, 0x73, 0x5d, 0x33, 0xd1, 0xab, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x5c, 0xf2, 0x44, 0x7e, 0x7e, 0x06, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolResp.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolServerHeader.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPING.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPONG.Get().(proto.Message)
	})
}

var poolResp = &sync.Pool{New: func() interface{} { return &Resp{} }}

func (m *Resp) ReleasePool() { m.Reset(); poolResp.Put(m); m = nil }

var poolServerHeader = &sync.Pool{New: func() interface{} { return &ServerHeader{} }}

func (m *ServerHeader) ReleasePool() { m.Reset(); poolServerHeader.Put(m); m = nil }

var poolPING = &sync.Pool{New: func() interface{} { return &PING{} }}

func (m *PING) ReleasePool() { m.Reset(); poolPING.Put(m); m = nil }

var poolPONG = &sync.Pool{New: func() interface{} { return &PONG{} }}

func (m *PONG) ReleasePool() { m.Reset(); poolPONG.Put(m); m = nil }
func (x MsgType) String() string {
	s, ok := MsgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ServerType) String() string {
	s, ok := ServerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrorType) String() string {
	s, ok := ErrorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Resp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resp)
	if !ok {
		that2, ok := that.(Resp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ErrCode != that1.ErrCode {
		return false
	}
	if this.ErrMsg != that1.ErrMsg {
		return false
	}
	if this.ErrInternalInfo != that1.ErrInternalInfo {
		return false
	}
	if !this.Resp.Equal(that1.Resp) {
		return false
	}
	if len(this.OtherMsg) != len(that1.OtherMsg) {
		return false
	}
	for i := range this.OtherMsg {
		if !this.OtherMsg[i].Equal(that1.OtherMsg[i]) {
			return false
		}
	}
	if len(this.OtherRequest) != len(that1.OtherRequest) {
		return false
	}
	for i := range this.OtherRequest {
		if this.OtherRequest[i] != that1.OtherRequest[i] {
			return false
		}
	}
	if len(this.StackStace) != len(that1.StackStace) {
		return false
	}
	for i := range this.StackStace {
		if this.StackStace[i] != that1.StackStace[i] {
			return false
		}
	}
	return true
}
func (this *ServerHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServerHeader)
	if !ok {
		that2, ok := that.(ServerHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.RoleId != that1.RoleId {
		return false
	}
	if this.ServerId != that1.ServerId {
		return false
	}
	if this.ServerType != that1.ServerType {
		return false
	}
	if this.RuleVersion != that1.RuleVersion {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	if this.GateId != that1.GateId {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.InServerId != that1.InServerId {
		return false
	}
	if this.BattleServerId != that1.BattleServerId {
		return false
	}
	if this.BattleMapId != that1.BattleMapId {
		return false
	}
	if this.StateLessServerId != that1.StateLessServerId {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *PING) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PING)
	if !ok {
		that2, ok := that.(PING)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Now != that1.Now {
		return false
	}
	return true
}
func (this *PONG) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PONG)
	if !ok {
		that2, ok := that.(PONG)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (m *Resp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StackStace) > 0 {
		dAtA2 := make([]byte, len(m.StackStace)*10)
		var j1 int
		for _, num := range m.StackStace {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintHeader(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OtherRequest) > 0 {
		for iNdEx := len(m.OtherRequest) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OtherRequest[iNdEx])
			copy(dAtA[i:], m.OtherRequest[iNdEx])
			i = encodeVarintHeader(dAtA, i, uint64(len(m.OtherRequest[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OtherMsg) > 0 {
		for iNdEx := len(m.OtherMsg) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OtherMsg[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHeader(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Resp != nil {
		{
			size, err := m.Resp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHeader(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrInternalInfo) > 0 {
		i -= len(m.ErrInternalInfo)
		copy(dAtA[i:], m.ErrInternalInfo)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.ErrInternalInfo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrCode != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.ErrCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServerHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x6a
	}
	if m.StateLessServerId != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.StateLessServerId))
		i--
		dAtA[i] = 0x60
	}
	if m.BattleMapId != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.BattleMapId))
		i--
		dAtA[i] = 0x58
	}
	if m.BattleServerId != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.BattleServerId))
		i--
		dAtA[i] = 0x50
	}
	if m.InServerId != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.InServerId))
		i--
		dAtA[i] = 0x48
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x42
	}
	if m.GateId != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.GateId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RuleVersion) > 0 {
		i -= len(m.RuleVersion)
		copy(dAtA[i:], m.RuleVersion)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.RuleVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ServerType != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.ServerType))
		i--
		dAtA[i] = 0x20
	}
	if m.ServerId != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.ServerId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RoleId) > 0 {
		i -= len(m.RoleId)
		copy(dAtA[i:], m.RoleId)
		i = encodeVarintHeader(dAtA, i, uint64(len(m.RoleId)))
		i--
		dAtA[i] = 0x12
	}
	if m.StartTime != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PING) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PING) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PING) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Now != 0 {
		i = encodeVarintHeader(dAtA, i, uint64(m.Now))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PONG) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PONG) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PONG) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintHeader(dAtA []byte, offset int, v uint64) int {
	offset -= sovHeader(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *Resp) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.ErrCode != 0 {
		w.RawByte('"')
		w.RawString("err_code")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ErrCode))
		needWriteComma = true
	}
	if m.ErrMsg != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("err_msg")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ErrMsg)
		needWriteComma = true
	}
	if m.ErrInternalInfo != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("err_internal_info")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ErrInternalInfo)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("resp")
	w.RawByte('"')
	w.RawByte(':')
	(*coin_server_common_proto_jsonany.Any)(m.Resp).JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("other_msg")
	w.RawByte('"')
	w.RawByte(':')
	if m.OtherMsg == nil {
		w.RawString("null")
	} else if len(m.OtherMsg) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.OtherMsg {
			(*coin_server_common_proto_jsonany.Any)(v).JsonBytes(w)
			if i != len(m.OtherMsg)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("other_request")
	w.RawByte('"')
	w.RawByte(':')
	if m.OtherRequest == nil {
		w.RawString("null")
	} else if len(m.OtherRequest) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.OtherRequest {
			w.String(v)
			if i != len(m.OtherRequest)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("stack_stace")
	w.RawByte('"')
	w.RawByte(':')
	if m.StackStace == nil {
		w.RawString("null")
	} else if len(m.StackStace) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.StackStace {
			w.Uint64(uint64(v))
			if i != len(m.StackStace)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *ServerHeader) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.StartTime != 0 {
		w.RawByte('"')
		w.RawString("start_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.StartTime))
		needWriteComma = true
	}
	if m.RoleId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("role_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.RoleId)
		needWriteComma = true
	}
	if m.ServerId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("server_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ServerId))
		needWriteComma = true
	}
	if m.ServerType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("server_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ServerType))
		needWriteComma = true
	}
	if m.RuleVersion != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("rule_version")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.RuleVersion)
		needWriteComma = true
	}
	if m.TraceId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("trace_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.TraceId)
		needWriteComma = true
	}
	if m.GateId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("gate_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.GateId))
		needWriteComma = true
	}
	if m.UserId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("user_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.UserId)
		needWriteComma = true
	}
	if m.InServerId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("in_server_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.InServerId))
		needWriteComma = true
	}
	if m.BattleServerId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_server_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleServerId))
		needWriteComma = true
	}
	if m.BattleMapId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("battle_map_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BattleMapId))
		needWriteComma = true
	}
	if m.StateLessServerId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("state_less_server_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.StateLessServerId))
		needWriteComma = true
	}
	if m.Ip != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ip")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Ip)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *PING) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Now != 0 {
		w.RawByte('"')
		w.RawString("now")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Now))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *PONG) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	w.RawByte('}')

}

func (m *Resp) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Resp) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Resp) GoString() string {
	return m.String()
}

func (m *ServerHeader) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *ServerHeader) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *ServerHeader) GoString() string {
	return m.String()
}

func (m *PING) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *PING) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *PING) GoString() string {
	return m.String()
}

func (m *PONG) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *PONG) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *PONG) GoString() string {
	return m.String()
}

func (m *Resp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovHeader(uint64(m.ErrCode))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	l = len(m.ErrInternalInfo)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovHeader(uint64(l))
	}
	if len(m.OtherMsg) > 0 {
		for _, e := range m.OtherMsg {
			l = e.Size()
			n += 1 + l + sovHeader(uint64(l))
		}
	}
	if len(m.OtherRequest) > 0 {
		for _, s := range m.OtherRequest {
			l = len(s)
			n += 1 + l + sovHeader(uint64(l))
		}
	}
	if len(m.StackStace) > 0 {
		l = 0
		for _, e := range m.StackStace {
			l += sovHeader(uint64(e))
		}
		n += 1 + sovHeader(uint64(l)) + l
	}
	return n
}

func (m *ServerHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovHeader(uint64(m.StartTime))
	}
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	if m.ServerId != 0 {
		n += 1 + sovHeader(uint64(m.ServerId))
	}
	if m.ServerType != 0 {
		n += 1 + sovHeader(uint64(m.ServerType))
	}
	l = len(m.RuleVersion)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	if m.GateId != 0 {
		n += 1 + sovHeader(uint64(m.GateId))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	if m.InServerId != 0 {
		n += 1 + sovHeader(uint64(m.InServerId))
	}
	if m.BattleServerId != 0 {
		n += 1 + sovHeader(uint64(m.BattleServerId))
	}
	if m.BattleMapId != 0 {
		n += 1 + sovHeader(uint64(m.BattleMapId))
	}
	if m.StateLessServerId != 0 {
		n += 1 + sovHeader(uint64(m.StateLessServerId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovHeader(uint64(l))
	}
	return n
}

func (m *PING) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Now != 0 {
		n += 1 + sovHeader(uint64(m.Now))
	}
	return n
}

func (m *PONG) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovHeader(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHeader(x uint64) (n int) {
	return sovHeader(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Resp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeader
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= ErrorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInternalInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInternalInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &types.Any{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherMsg = append(m.OtherMsg, &types.Any{})
			if err := m.OtherMsg[len(m.OtherMsg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherRequest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherRequest = append(m.OtherRequest, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHeader
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StackStace = append(m.StackStace, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHeader
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHeader
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthHeader
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StackStace) == 0 {
					m.StackStace = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHeader
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StackStace = append(m.StackStace, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StackStace", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHeader(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeader
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeader
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerType", wireType)
			}
			m.ServerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerType |= ServerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateId", wireType)
			}
			m.GateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GateId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InServerId", wireType)
			}
			m.InServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleServerId", wireType)
			}
			m.BattleServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleMapId", wireType)
			}
			m.BattleMapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleMapId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateLessServerId", wireType)
			}
			m.StateLessServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StateLessServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeader
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeader
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHeader(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeader
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PING) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeader
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PING: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PING: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			m.Now = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Now |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHeader(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeader
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PONG) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeader
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PONG: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PONG: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHeader(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeader
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHeader(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHeader
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHeader
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHeader
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHeader
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHeader
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHeader        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHeader          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHeader = fmt.Errorf("proto: unexpected end of group")
)
