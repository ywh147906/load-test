// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/models/tower.proto

package models

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TowerType int32

const (
	TowerType_TT_None    TowerType = 0
	TowerType_TT_Default TowerType = 1
)

var TowerType_name = map[int32]string{
	0: "TT_None",
	1: "TT_Default",
}

var TowerType_value = map[string]int32{
	"TT_None":    0,
	"TT_Default": 1,
}

func (TowerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{0}
}

type AccumulateHarvestType int32

const (
	AccumulateHarvestType_AT_None       AccumulateHarvestType = 0
	AccumulateHarvestType_AT_FREE       AccumulateHarvestType = 1
	AccumulateHarvestType_AT_Meditation AccumulateHarvestType = 2
)

var AccumulateHarvestType_name = map[int32]string{
	0: "AT_None",
	1: "AT_FREE",
	2: "AT_Meditation",
}

var AccumulateHarvestType_value = map[string]int32{
	"AT_None":       0,
	"AT_FREE":       1,
	"AT_Meditation": 2,
}

func (AccumulateHarvestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{1}
}

type TowerWinType int32

const (
	TowerWinType_TW_None  TowerWinType = 0
	TowerWinType_TW_Pass  TowerWinType = 1
	TowerWinType_TW_MopUp TowerWinType = 2
)

var TowerWinType_name = map[int32]string{
	0: "TW_None",
	1: "TW_Pass",
	2: "TW_MopUp",
}

var TowerWinType_value = map[string]int32{
	"TW_None":  0,
	"TW_Pass":  1,
	"TW_MopUp": 2,
}

func (TowerWinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{2}
}

type TowerPassData struct {
	TowerLevel int64   `protobuf:"varint,1,opt,name=tower_level,json=towerLevel,proto3" json:"tower_level,omitempty"`
	PassTime   float64 `protobuf:"fixed64,2,opt,name=pass_time,json=passTime,proto3" json:"pass_time,omitempty"`
	Rewards    []int64 `protobuf:"varint,3,rep,packed,name=rewards,proto3" json:"rewards,omitempty"`
}

func (m *TowerPassData) Reset()      { *m = TowerPassData{} }
func (*TowerPassData) ProtoMessage() {}
func (*TowerPassData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{0}
}
func (m *TowerPassData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TowerPassData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TowerPassData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TowerPassData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TowerPassData.Merge(m, src)
}
func (m *TowerPassData) XXX_Size() int {
	return m.Size()
}
func (m *TowerPassData) XXX_DiscardUnknown() {
	xxx_messageInfo_TowerPassData.DiscardUnknown(m)
}

var xxx_messageInfo_TowerPassData proto.InternalMessageInfo

func (m *TowerPassData) GetTowerLevel() int64 {
	if m != nil {
		return m.TowerLevel
	}
	return 0
}

func (m *TowerPassData) GetPassTime() float64 {
	if m != nil {
		return m.PassTime
	}
	return 0
}

func (m *TowerPassData) GetRewards() []int64 {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (*TowerPassData) XXX_MessageName() string {
	return "models.TowerPassData"
}

type Postion struct {
	X float64 `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y float64 `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Postion) Reset()      { *m = Postion{} }
func (*Postion) ProtoMessage() {}
func (*Postion) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{1}
}
func (m *Postion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Postion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Postion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Postion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Postion.Merge(m, src)
}
func (m *Postion) XXX_Size() int {
	return m.Size()
}
func (m *Postion) XXX_DiscardUnknown() {
	xxx_messageInfo_Postion.DiscardUnknown(m)
}

var xxx_messageInfo_Postion proto.InternalMessageInfo

func (m *Postion) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Postion) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (*Postion) XXX_MessageName() string {
	return "models.Postion"
}

type Tower struct {
	CurrentTowerLevel int64 `protobuf:"varint,1,opt,name=current_tower_level,json=currentTowerLevel,proto3" json:"current_tower_level,omitempty"`
	IsAllPass         bool  `protobuf:"varint,2,opt,name=is_all_pass,json=isAllPass,proto3" json:"is_all_pass,omitempty"`
	UseChallengeTimes int64 `protobuf:"varint,3,opt,name=use_challenge_times,json=useChallengeTimes,proto3" json:"use_challenge_times,omitempty"`
	MaxChallengeTimes int64 `protobuf:"varint,4,opt,name=max_challenge_times,json=maxChallengeTimes,proto3" json:"max_challenge_times,omitempty"`
	NextRefreshTime   int64 `protobuf:"varint,5,opt,name=next_refresh_time,json=nextRefreshTime,proto3" json:"next_refresh_time,omitempty"`
}

func (m *Tower) Reset()      { *m = Tower{} }
func (*Tower) ProtoMessage() {}
func (*Tower) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{2}
}
func (m *Tower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tower.Merge(m, src)
}
func (m *Tower) XXX_Size() int {
	return m.Size()
}
func (m *Tower) XXX_DiscardUnknown() {
	xxx_messageInfo_Tower.DiscardUnknown(m)
}

var xxx_messageInfo_Tower proto.InternalMessageInfo

func (m *Tower) GetCurrentTowerLevel() int64 {
	if m != nil {
		return m.CurrentTowerLevel
	}
	return 0
}

func (m *Tower) GetIsAllPass() bool {
	if m != nil {
		return m.IsAllPass
	}
	return false
}

func (m *Tower) GetUseChallengeTimes() int64 {
	if m != nil {
		return m.UseChallengeTimes
	}
	return 0
}

func (m *Tower) GetMaxChallengeTimes() int64 {
	if m != nil {
		return m.MaxChallengeTimes
	}
	return 0
}

func (m *Tower) GetNextRefreshTime() int64 {
	if m != nil {
		return m.NextRefreshTime
	}
	return 0
}

func (*Tower) XXX_MessageName() string {
	return "models.Tower"
}

//缓存收益
type TowerAccumulateHarvestCacheInfo struct {
	ProfitsData        []*Item `protobuf:"bytes,1,rep,name=profits_data,json=profitsData,proto3" json:"profits_data,omitempty"`
	LastSettlementTime int64   `protobuf:"varint,2,opt,name=last_settlement_time,json=lastSettlementTime,proto3" json:"last_settlement_time,omitempty"`
	SettlementUseTime  int64   `protobuf:"varint,3,opt,name=settlement_use_time,json=settlementUseTime,proto3" json:"settlement_use_time,omitempty"`
}

func (m *TowerAccumulateHarvestCacheInfo) Reset()      { *m = TowerAccumulateHarvestCacheInfo{} }
func (*TowerAccumulateHarvestCacheInfo) ProtoMessage() {}
func (*TowerAccumulateHarvestCacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{3}
}
func (m *TowerAccumulateHarvestCacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TowerAccumulateHarvestCacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TowerAccumulateHarvestCacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TowerAccumulateHarvestCacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TowerAccumulateHarvestCacheInfo.Merge(m, src)
}
func (m *TowerAccumulateHarvestCacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *TowerAccumulateHarvestCacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TowerAccumulateHarvestCacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TowerAccumulateHarvestCacheInfo proto.InternalMessageInfo

func (m *TowerAccumulateHarvestCacheInfo) GetProfitsData() []*Item {
	if m != nil {
		return m.ProfitsData
	}
	return nil
}

func (m *TowerAccumulateHarvestCacheInfo) GetLastSettlementTime() int64 {
	if m != nil {
		return m.LastSettlementTime
	}
	return 0
}

func (m *TowerAccumulateHarvestCacheInfo) GetSettlementUseTime() int64 {
	if m != nil {
		return m.SettlementUseTime
	}
	return 0
}

func (*TowerAccumulateHarvestCacheInfo) XXX_MessageName() string {
	return "models.TowerAccumulateHarvestCacheInfo"
}

type ChallengeData struct {
	UseChallengeTimes int64 `protobuf:"varint,1,opt,name=use_challenge_times,json=useChallengeTimes,proto3" json:"use_challenge_times,omitempty"`
	LastChallengeTime int64 `protobuf:"varint,2,opt,name=last_challenge_time,json=lastChallengeTime,proto3" json:"last_challenge_time,omitempty"`
}

func (m *ChallengeData) Reset()      { *m = ChallengeData{} }
func (*ChallengeData) ProtoMessage() {}
func (*ChallengeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{4}
}
func (m *ChallengeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeData.Merge(m, src)
}
func (m *ChallengeData) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeData.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeData proto.InternalMessageInfo

func (m *ChallengeData) GetUseChallengeTimes() int64 {
	if m != nil {
		return m.UseChallengeTimes
	}
	return 0
}

func (m *ChallengeData) GetLastChallengeTime() int64 {
	if m != nil {
		return m.LastChallengeTime
	}
	return 0
}

func (*ChallengeData) XXX_MessageName() string {
	return "models.ChallengeData"
}

type TowerAccumulateHarvestInfo struct {
	ProfitsData               []*Item `protobuf:"bytes,1,rep,name=profits_data,json=profitsData,proto3" json:"profits_data,omitempty"`
	LastSettlementTime        int64   `protobuf:"varint,2,opt,name=last_settlement_time,json=lastSettlementTime,proto3" json:"last_settlement_time,omitempty"`
	NextSettlementTime        int64   `protobuf:"varint,3,opt,name=next_settlement_time,json=nextSettlementTime,proto3" json:"next_settlement_time,omitempty"`
	SettlementInterval        int64   `protobuf:"varint,4,opt,name=settlement_interval,json=settlementInterval,proto3" json:"settlement_interval,omitempty"`
	IsMax                     bool    `protobuf:"varint,5,opt,name=is_max,json=isMax,proto3" json:"is_max,omitempty"`
	ProfitsItem               []*Item `protobuf:"bytes,6,rep,name=profits_item,json=profitsItem,proto3" json:"profits_item,omitempty"`
	LeftFreeMeditationTimes   int32   `protobuf:"varint,7,opt,name=left_free_meditation_times,json=leftFreeMeditationTimes,proto3" json:"left_free_meditation_times,omitempty"`
	UseCostMeditationTimes    int32   `protobuf:"varint,8,opt,name=Use_cost_meditation_times,json=UseCostMeditationTimes,proto3" json:"Use_cost_meditation_times,omitempty"`
	NextMeditationRefreshTime int64   `protobuf:"varint,9,opt,name=next_meditation_refresh_time,json=nextMeditationRefreshTime,proto3" json:"next_meditation_refresh_time,omitempty"`
	NowHandleupAllTime        int64   `protobuf:"varint,10,opt,name=now_handleup_all_time,json=nowHandleupAllTime,proto3" json:"now_handleup_all_time,omitempty"`
	ModTime                   int64   `protobuf:"varint,11,opt,name=mod_time,json=modTime,proto3" json:"mod_time,omitempty"`
}

func (m *TowerAccumulateHarvestInfo) Reset()      { *m = TowerAccumulateHarvestInfo{} }
func (*TowerAccumulateHarvestInfo) ProtoMessage() {}
func (*TowerAccumulateHarvestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{5}
}
func (m *TowerAccumulateHarvestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TowerAccumulateHarvestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TowerAccumulateHarvestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TowerAccumulateHarvestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TowerAccumulateHarvestInfo.Merge(m, src)
}
func (m *TowerAccumulateHarvestInfo) XXX_Size() int {
	return m.Size()
}
func (m *TowerAccumulateHarvestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TowerAccumulateHarvestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TowerAccumulateHarvestInfo proto.InternalMessageInfo

func (m *TowerAccumulateHarvestInfo) GetProfitsData() []*Item {
	if m != nil {
		return m.ProfitsData
	}
	return nil
}

func (m *TowerAccumulateHarvestInfo) GetLastSettlementTime() int64 {
	if m != nil {
		return m.LastSettlementTime
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetNextSettlementTime() int64 {
	if m != nil {
		return m.NextSettlementTime
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetSettlementInterval() int64 {
	if m != nil {
		return m.SettlementInterval
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetIsMax() bool {
	if m != nil {
		return m.IsMax
	}
	return false
}

func (m *TowerAccumulateHarvestInfo) GetProfitsItem() []*Item {
	if m != nil {
		return m.ProfitsItem
	}
	return nil
}

func (m *TowerAccumulateHarvestInfo) GetLeftFreeMeditationTimes() int32 {
	if m != nil {
		return m.LeftFreeMeditationTimes
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetUseCostMeditationTimes() int32 {
	if m != nil {
		return m.UseCostMeditationTimes
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetNextMeditationRefreshTime() int64 {
	if m != nil {
		return m.NextMeditationRefreshTime
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetNowHandleupAllTime() int64 {
	if m != nil {
		return m.NowHandleupAllTime
	}
	return 0
}

func (m *TowerAccumulateHarvestInfo) GetModTime() int64 {
	if m != nil {
		return m.ModTime
	}
	return 0
}

func (*TowerAccumulateHarvestInfo) XXX_MessageName() string {
	return "models.TowerAccumulateHarvestInfo"
}

type MeditationData struct {
	LastMeditationTime     int64 `protobuf:"varint,1,opt,name=last_meditation_time,json=lastMeditationTime,proto3" json:"last_meditation_time,omitempty"`
	UseFreeMeditationTimes int32 `protobuf:"varint,2,opt,name=use_free_meditation_times,json=useFreeMeditationTimes,proto3" json:"use_free_meditation_times,omitempty"`
	UseCostMeditationTimes int32 `protobuf:"varint,3,opt,name=use_cost_meditation_times,json=useCostMeditationTimes,proto3" json:"use_cost_meditation_times,omitempty"`
}

func (m *MeditationData) Reset()      { *m = MeditationData{} }
func (*MeditationData) ProtoMessage() {}
func (*MeditationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{6}
}
func (m *MeditationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeditationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeditationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeditationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeditationData.Merge(m, src)
}
func (m *MeditationData) XXX_Size() int {
	return m.Size()
}
func (m *MeditationData) XXX_DiscardUnknown() {
	xxx_messageInfo_MeditationData.DiscardUnknown(m)
}

var xxx_messageInfo_MeditationData proto.InternalMessageInfo

func (m *MeditationData) GetLastMeditationTime() int64 {
	if m != nil {
		return m.LastMeditationTime
	}
	return 0
}

func (m *MeditationData) GetUseFreeMeditationTimes() int32 {
	if m != nil {
		return m.UseFreeMeditationTimes
	}
	return 0
}

func (m *MeditationData) GetUseCostMeditationTimes() int32 {
	if m != nil {
		return m.UseCostMeditationTimes
	}
	return 0
}

func (*MeditationData) XXX_MessageName() string {
	return "models.MeditationData"
}

type TowerData struct {
	Type              TowerType                        `protobuf:"varint,1,opt,name=type,proto3,enum=models.TowerType" json:"type,omitempty"`
	CurrentTowerLevel int64                            `protobuf:"varint,2,opt,name=current_tower_level,json=currentTowerLevel,proto3" json:"current_tower_level,omitempty"`
	PassData          map[int64]*TowerPassData         `protobuf:"bytes,3,rep,name=pass_data,json=passData,proto3" json:"pass_data,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CacheInfo         *TowerAccumulateHarvestCacheInfo `protobuf:"bytes,4,opt,name=cache_info,json=cacheInfo,proto3" json:"cache_info,omitempty"`
	MeditationData    *MeditationData                  `protobuf:"bytes,5,opt,name=meditation_data,json=meditationData,proto3" json:"meditation_data,omitempty"`
	ChallengeData     *ChallengeData                   `protobuf:"bytes,6,opt,name=challenge_data,json=challengeData,proto3" json:"challenge_data,omitempty"`
}

func (m *TowerData) Reset()      { *m = TowerData{} }
func (*TowerData) ProtoMessage() {}
func (*TowerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{7}
}
func (m *TowerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TowerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TowerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TowerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TowerData.Merge(m, src)
}
func (m *TowerData) XXX_Size() int {
	return m.Size()
}
func (m *TowerData) XXX_DiscardUnknown() {
	xxx_messageInfo_TowerData.DiscardUnknown(m)
}

var xxx_messageInfo_TowerData proto.InternalMessageInfo

func (m *TowerData) GetType() TowerType {
	if m != nil {
		return m.Type
	}
	return TowerType_TT_None
}

func (m *TowerData) GetCurrentTowerLevel() int64 {
	if m != nil {
		return m.CurrentTowerLevel
	}
	return 0
}

func (m *TowerData) GetPassData() map[int64]*TowerPassData {
	if m != nil {
		return m.PassData
	}
	return nil
}

func (m *TowerData) GetCacheInfo() *TowerAccumulateHarvestCacheInfo {
	if m != nil {
		return m.CacheInfo
	}
	return nil
}

func (m *TowerData) GetMeditationData() *MeditationData {
	if m != nil {
		return m.MeditationData
	}
	return nil
}

func (m *TowerData) GetChallengeData() *ChallengeData {
	if m != nil {
		return m.ChallengeData
	}
	return nil
}

func (*TowerData) XXX_MessageName() string {
	return "models.TowerData"
}

type HeroInfo struct {
	HeroId int64 `protobuf:"varint,1,opt,name=hero_id,json=heroId,proto3" json:"hero_id,omitempty"`
	HeroHp int64 `protobuf:"varint,2,opt,name=hero_hp,json=heroHp,proto3" json:"hero_hp,omitempty"`
}

func (m *HeroInfo) Reset()      { *m = HeroInfo{} }
func (*HeroInfo) ProtoMessage() {}
func (*HeroInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9c07d78b4932f4, []int{8}
}
func (m *HeroInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeroInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeroInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeroInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeroInfo.Merge(m, src)
}
func (m *HeroInfo) XXX_Size() int {
	return m.Size()
}
func (m *HeroInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HeroInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HeroInfo proto.InternalMessageInfo

func (m *HeroInfo) GetHeroId() int64 {
	if m != nil {
		return m.HeroId
	}
	return 0
}

func (m *HeroInfo) GetHeroHp() int64 {
	if m != nil {
		return m.HeroHp
	}
	return 0
}

func (*HeroInfo) XXX_MessageName() string {
	return "models.HeroInfo"
}
func init() {
	proto.RegisterEnum("models.TowerType", TowerType_name, TowerType_value)
	proto.RegisterEnum("models.AccumulateHarvestType", AccumulateHarvestType_name, AccumulateHarvestType_value)
	proto.RegisterEnum("models.TowerWinType", TowerWinType_name, TowerWinType_value)
	proto.RegisterType((*TowerPassData)(nil), "models.TowerPassData")
	proto.RegisterType((*Postion)(nil), "models.Postion")
	proto.RegisterType((*Tower)(nil), "models.Tower")
	proto.RegisterType((*TowerAccumulateHarvestCacheInfo)(nil), "models.TowerAccumulateHarvestCacheInfo")
	proto.RegisterType((*ChallengeData)(nil), "models.ChallengeData")
	proto.RegisterType((*TowerAccumulateHarvestInfo)(nil), "models.TowerAccumulateHarvestInfo")
	proto.RegisterType((*MeditationData)(nil), "models.MeditationData")
	proto.RegisterType((*TowerData)(nil), "models.TowerData")
	proto.RegisterMapType((map[int64]*TowerPassData)(nil), "models.TowerData.PassDataEntry")
	proto.RegisterType((*HeroInfo)(nil), "models.HeroInfo")
}

func init() { proto.RegisterFile("proto/models/tower.proto", fileDescriptor_1a9c07d78b4932f4) }

var fileDescriptor_1a9c07d78b4932f4 = []byte{
	// 997 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x4e, 0x23, 0x47,
	0x10, 0x76, 0xdb, 0xf8, 0x87, 0x32, 0xb0, 0x66, 0x76, 0x61, 0x0d, 0x89, 0x06, 0x64, 0x69, 0x15,
	0x8b, 0x28, 0xf6, 0x86, 0x48, 0x51, 0x7e, 0x90, 0x56, 0x84, 0x1f, 0x81, 0x14, 0xa2, 0xd5, 0x64,
	0x10, 0x52, 0x2e, 0xad, 0x5e, 0xbb, 0x8c, 0x47, 0x99, 0x99, 0xb6, 0xa6, 0x7b, 0xc0, 0x7e, 0x8b,
	0x3c, 0x46, 0xae, 0x91, 0x72, 0x88, 0x94, 0x17, 0xd8, 0xe3, 0x1e, 0xf7, 0x98, 0x98, 0x4b, 0x8e,
	0x79, 0x84, 0xa8, 0x6b, 0xc6, 0x3f, 0x03, 0x78, 0x8f, 0xb9, 0xd1, 0x5d, 0xdf, 0x57, 0x53, 0xf5,
	0x7d, 0xd5, 0x65, 0xa0, 0x3e, 0x88, 0xa4, 0x96, 0xed, 0x40, 0x76, 0xd1, 0x57, 0x6d, 0x2d, 0x6f,
	0x31, 0x6a, 0xd1, 0x95, 0x55, 0x4a, 0xee, 0xb6, 0x37, 0x33, 0x88, 0x37, 0xe2, 0x3a, 0x89, 0x37,
	0xae, 0x61, 0xd5, 0x35, 0xf0, 0xd7, 0x42, 0xa9, 0x63, 0xa1, 0x85, 0xb5, 0x03, 0x55, 0xe2, 0x73,
	0x1f, 0x6f, 0xd0, 0xaf, 0xb3, 0x5d, 0xd6, 0x2c, 0x38, 0x40, 0x57, 0xdf, 0x9b, 0x1b, 0xeb, 0x23,
	0x58, 0x1e, 0x08, 0xa5, 0xb8, 0xf6, 0x02, 0xac, 0xe7, 0x77, 0x59, 0x93, 0x39, 0x15, 0x73, 0xe1,
	0x7a, 0x01, 0x5a, 0x75, 0x28, 0x47, 0x78, 0x2b, 0xa2, 0xae, 0xaa, 0x17, 0x76, 0x0b, 0xcd, 0x82,
	0x33, 0x39, 0x36, 0x5e, 0x40, 0xf9, 0xb5, 0x54, 0xda, 0x93, 0xa1, 0xb5, 0x02, 0x6c, 0x48, 0x89,
	0x99, 0xc3, 0x86, 0xe6, 0x34, 0x4a, 0xf3, 0xb0, 0x51, 0xe3, 0x8e, 0x41, 0x91, 0x0a, 0xb2, 0x5a,
	0xf0, 0xb4, 0x13, 0x47, 0x11, 0x86, 0x9a, 0x3f, 0x2c, 0x68, 0x3d, 0x0d, 0xb9, 0xb3, 0xba, 0x6c,
	0xa8, 0x7a, 0x8a, 0x0b, 0xdf, 0xe7, 0xa6, 0x1a, 0xca, 0x58, 0x71, 0x96, 0x3d, 0x75, 0xe8, 0xfb,
	0xa6, 0x39, 0x93, 0x2f, 0x56, 0xc8, 0x3b, 0x7d, 0xe1, 0xfb, 0x18, 0x5e, 0x23, 0x35, 0x60, 0xca,
	0xa4, 0x7c, 0xb1, 0xc2, 0xa3, 0x49, 0xc4, 0x74, 0x42, 0xf8, 0x40, 0x0c, 0x1f, 0xe0, 0x97, 0x12,
	0x7c, 0x20, 0x86, 0xf7, 0xf0, 0x7b, 0xb0, 0x1e, 0xe2, 0x50, 0xf3, 0x08, 0x7b, 0x11, 0xaa, 0x7e,
	0xa2, 0x4f, 0x91, 0xd0, 0x4f, 0x4c, 0xc0, 0x49, 0xee, 0x0d, 0xb8, 0xf1, 0x3b, 0x83, 0x1d, 0x2a,
	0xfd, 0xb0, 0xd3, 0x89, 0x83, 0xd8, 0x17, 0x1a, 0xcf, 0x44, 0x74, 0x83, 0x4a, 0x1f, 0x89, 0x4e,
	0x1f, 0xcf, 0xc3, 0x9e, 0xb4, 0xda, 0xb0, 0x32, 0x88, 0x64, 0xcf, 0xd3, 0x8a, 0x77, 0x85, 0x16,
	0x75, 0xb6, 0x5b, 0x68, 0x56, 0xf7, 0x57, 0x5a, 0x89, 0x85, 0xad, 0x73, 0x8d, 0x81, 0x53, 0x4d,
	0x11, 0xe4, 0xdc, 0x4b, 0x78, 0xe6, 0x0b, 0xa5, 0xb9, 0x42, 0xad, 0x7d, 0x0c, 0x48, 0xb8, 0x89,
	0x47, 0x05, 0xc7, 0x32, 0xb1, 0x1f, 0xa7, 0x21, 0x72, 0xab, 0x05, 0x4f, 0xe7, 0xc0, 0x46, 0x1d,
	0x22, 0xa4, 0x92, 0xcc, 0x42, 0x97, 0x8a, 0x7a, 0x6c, 0x48, 0x58, 0x9d, 0x36, 0x4d, 0x9f, 0x5c,
	0xa0, 0x29, 0xfb, 0x80, 0xa6, 0x54, 0x62, 0x96, 0x90, 0x56, 0xb8, 0x6e, 0x42, 0x19, 0x42, 0xe3,
	0xb7, 0x25, 0xd8, 0x7e, 0x5c, 0xa7, 0xff, 0x4b, 0xa2, 0x97, 0xf0, 0x8c, 0x5c, 0xbd, 0xcf, 0x48,
	0x34, 0xb2, 0x4c, 0xec, 0x1e, 0xa3, 0x9d, 0x11, 0xd5, 0x0b, 0x35, 0x46, 0x37, 0xc2, 0x4f, 0xe7,
	0xc6, 0x9a, 0x85, 0xce, 0xd3, 0x88, 0xb5, 0x01, 0x25, 0x4f, 0xf1, 0x40, 0x0c, 0x69, 0x5a, 0x2a,
	0x4e, 0xd1, 0x53, 0x17, 0x62, 0x38, 0xdf, 0x9c, 0xa7, 0x31, 0xa8, 0x97, 0x3e, 0xd0, 0x9c, 0x39,
	0x58, 0xdf, 0xc2, 0xb6, 0x8f, 0x3d, 0xcd, 0x7b, 0x11, 0x22, 0x0f, 0xb0, 0xeb, 0x69, 0x61, 0x9e,
	0x5b, 0xea, 0x49, 0x79, 0x97, 0x35, 0x8b, 0xce, 0x73, 0x83, 0x38, 0x8d, 0x10, 0x2f, 0xa6, 0xf1,
	0xc4, 0x99, 0xaf, 0x61, 0xeb, 0xd2, 0x38, 0x29, 0x95, 0x7e, 0xc8, 0xad, 0x10, 0x77, 0xf3, 0x52,
	0xe1, 0x91, 0x54, 0xfa, 0x3e, 0xf5, 0x15, 0x7c, 0x4c, 0x12, 0xcd, 0xd1, 0x32, 0x6f, 0x60, 0x99,
	0x3a, 0xdf, 0x32, 0x98, 0x19, 0x75, 0xee, 0x35, 0x58, 0x9f, 0xc3, 0x46, 0x28, 0x6f, 0x79, 0x5f,
	0x84, 0x5d, 0x1f, 0xe3, 0x01, 0xbd, 0x61, 0x62, 0x42, 0x2a, 0xb2, 0xbc, 0x3d, 0x4b, 0x63, 0x87,
	0xbe, 0x4f, 0x94, 0x2d, 0xa8, 0x04, 0xb2, 0x9b, 0xa0, 0xaa, 0x84, 0x2a, 0x07, 0xb2, 0x4b, 0x33,
	0xf3, 0x07, 0x83, 0xb5, 0xd9, 0x77, 0x32, 0xb6, 0xdf, 0x6b, 0x2c, 0x9d, 0x53, 0xb2, 0x3d, 0xdb,
	0x94, 0x91, 0xc3, 0x0c, 0xf6, 0xe3, 0x52, 0xe6, 0x13, 0x39, 0x62, 0x85, 0x0b, 0x94, 0x8c, 0x17,
	0x2a, 0x59, 0x98, 0x52, 0x1f, 0x51, 0xb2, 0xf1, 0x67, 0x01, 0x96, 0x69, 0xdc, 0xa9, 0xea, 0x17,
	0xb0, 0xa4, 0x47, 0x83, 0xa4, 0xca, 0xb5, 0xfd, 0xf5, 0x89, 0xf1, 0x04, 0x70, 0x47, 0x03, 0x74,
	0x28, 0xbc, 0x68, 0x4f, 0xe6, 0x17, 0xed, 0xc9, 0x83, 0x74, 0x7f, 0xd3, 0x8b, 0x29, 0xd0, 0x50,
	0xed, 0x64, 0x72, 0x9b, 0x8f, 0xb7, 0x26, 0xbf, 0x07, 0x27, 0xa1, 0x8e, 0x46, 0xc9, 0x82, 0xa7,
	0xa2, 0x4e, 0x01, 0x3a, 0x66, 0x45, 0x71, 0x2f, 0xec, 0x49, 0x1a, 0xea, 0xea, 0xfe, 0x27, 0x19,
	0xfa, 0xe2, 0x95, 0xe6, 0x2c, 0x77, 0xa6, 0xdb, 0xed, 0x15, 0x3c, 0x99, 0x13, 0x87, 0x6a, 0x29,
	0x52, 0xb2, 0xcd, 0x49, 0xb2, 0xac, 0x87, 0xce, 0x5a, 0x90, 0xf5, 0xf4, 0x00, 0xd6, 0x66, 0x5b,
	0x84, 0xf8, 0x25, 0xe2, 0x6f, 0x4c, 0xf8, 0x99, 0x4d, 0xe5, 0xac, 0x76, 0xe6, 0x8f, 0xdb, 0x0e,
	0xac, 0x66, 0x3a, 0xb4, 0x6a, 0x50, 0xf8, 0x19, 0x47, 0xe9, 0x44, 0x98, 0x3f, 0xad, 0x4f, 0xa1,
	0x78, 0x23, 0xfc, 0x38, 0x59, 0x0e, 0x73, 0x79, 0x33, 0x3f, 0x97, 0x4e, 0x82, 0xf9, 0x26, 0xff,
	0x15, 0x6b, 0x1c, 0x40, 0xe5, 0x0c, 0x23, 0x49, 0xed, 0x3d, 0x87, 0x72, 0x1f, 0x23, 0xc9, 0xbd,
	0x6e, 0x9a, 0xb2, 0x64, 0x8e, 0xe7, 0xdd, 0x69, 0xa0, 0x3f, 0x48, 0x1d, 0xa2, 0xc0, 0xd9, 0x60,
	0xaf, 0x99, 0x5a, 0x6f, 0x9c, 0xb5, 0xaa, 0x50, 0x76, 0x5d, 0xfe, 0x83, 0x0c, 0xb1, 0x96, 0xb3,
	0xd6, 0x00, 0x5c, 0x97, 0x1f, 0x63, 0x4f, 0xc4, 0xbe, 0xae, 0xb1, 0xbd, 0x63, 0xd8, 0x78, 0xa0,
	0xf1, 0x84, 0x75, 0x38, 0x65, 0x25, 0x87, 0x53, 0xe7, 0xe4, 0xa4, 0xc6, 0xac, 0x75, 0x58, 0x3d,
	0x74, 0xf9, 0x4c, 0xd1, 0x5a, 0x7e, 0xef, 0x4b, 0x58, 0xa1, 0xef, 0x5d, 0x79, 0xe1, 0xf4, 0x93,
	0x57, 0x73, 0x64, 0xf7, 0x8a, 0x9b, 0x26, 0x6b, 0xcc, 0x5a, 0x81, 0x8a, 0x7b, 0xc5, 0x2f, 0xe4,
	0xe0, 0x72, 0x50, 0xcb, 0x7f, 0x77, 0xf1, 0xfe, 0x6f, 0x3b, 0xf7, 0xeb, 0xd8, 0x66, 0x6f, 0xc7,
	0x36, 0x7b, 0x37, 0xb6, 0xd9, 0x5f, 0x63, 0x9b, 0xfd, 0x33, 0xb6, 0x73, 0xff, 0x8e, 0x6d, 0xf6,
	0xcb, 0x9d, 0x9d, 0x7b, 0x7b, 0x67, 0xb3, 0x77, 0x77, 0x76, 0xee, 0xfd, 0x9d, 0x9d, 0xfb, 0x69,
	0xa7, 0x23, 0xbd, 0xf0, 0x33, 0x85, 0xd1, 0x0d, 0x46, 0xed, 0x8e, 0x0c, 0x02, 0x19, 0xb6, 0xe7,
	0xff, 0x13, 0x79, 0x53, 0xa2, 0xd3, 0x17, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xd2, 0x0f, 0x3f,
	0x22, 0xc2, 0x08, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTowerPassData.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPostion.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTower.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTowerAccumulateHarvestCacheInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolChallengeData.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTowerAccumulateHarvestInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMeditationData.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTowerData.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolHeroInfo.Get().(proto.Message)
	})
}

var poolTowerPassData = &sync.Pool{New: func() interface{} { return &TowerPassData{} }}

func (m *TowerPassData) ReleasePool() { m.Reset(); poolTowerPassData.Put(m); m = nil }

var poolPostion = &sync.Pool{New: func() interface{} { return &Postion{} }}

func (m *Postion) ReleasePool() { m.Reset(); poolPostion.Put(m); m = nil }

var poolTower = &sync.Pool{New: func() interface{} { return &Tower{} }}

func (m *Tower) ReleasePool() { m.Reset(); poolTower.Put(m); m = nil }

var poolTowerAccumulateHarvestCacheInfo = &sync.Pool{New: func() interface{} { return &TowerAccumulateHarvestCacheInfo{} }}

func (m *TowerAccumulateHarvestCacheInfo) ReleasePool() {
	m.Reset()
	poolTowerAccumulateHarvestCacheInfo.Put(m)
	m = nil
}

var poolChallengeData = &sync.Pool{New: func() interface{} { return &ChallengeData{} }}

func (m *ChallengeData) ReleasePool() { m.Reset(); poolChallengeData.Put(m); m = nil }

var poolTowerAccumulateHarvestInfo = &sync.Pool{New: func() interface{} { return &TowerAccumulateHarvestInfo{} }}

func (m *TowerAccumulateHarvestInfo) ReleasePool() {
	m.Reset()
	poolTowerAccumulateHarvestInfo.Put(m)
	m = nil
}

var poolMeditationData = &sync.Pool{New: func() interface{} { return &MeditationData{} }}

func (m *MeditationData) ReleasePool() { m.Reset(); poolMeditationData.Put(m); m = nil }

var poolTowerData = &sync.Pool{New: func() interface{} { return &TowerData{} }}

func (m *TowerData) ReleasePool() { m.Reset(); poolTowerData.Put(m); m = nil }

var poolHeroInfo = &sync.Pool{New: func() interface{} { return &HeroInfo{} }}

func (m *HeroInfo) ReleasePool() { m.Reset(); poolHeroInfo.Put(m); m = nil }
func (x TowerType) String() string {
	s, ok := TowerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AccumulateHarvestType) String() string {
	s, ok := AccumulateHarvestType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TowerWinType) String() string {
	s, ok := TowerWinType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TowerPassData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TowerPassData)
	if !ok {
		that2, ok := that.(TowerPassData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TowerLevel != that1.TowerLevel {
		return false
	}
	if this.PassTime != that1.PassTime {
		return false
	}
	if len(this.Rewards) != len(that1.Rewards) {
		return false
	}
	for i := range this.Rewards {
		if this.Rewards[i] != that1.Rewards[i] {
			return false
		}
	}
	return true
}
func (this *Postion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Postion)
	if !ok {
		that2, ok := that.(Postion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X != that1.X {
		return false
	}
	if this.Y != that1.Y {
		return false
	}
	return true
}
func (this *Tower) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tower)
	if !ok {
		that2, ok := that.(Tower)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CurrentTowerLevel != that1.CurrentTowerLevel {
		return false
	}
	if this.IsAllPass != that1.IsAllPass {
		return false
	}
	if this.UseChallengeTimes != that1.UseChallengeTimes {
		return false
	}
	if this.MaxChallengeTimes != that1.MaxChallengeTimes {
		return false
	}
	if this.NextRefreshTime != that1.NextRefreshTime {
		return false
	}
	return true
}
func (this *TowerAccumulateHarvestCacheInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TowerAccumulateHarvestCacheInfo)
	if !ok {
		that2, ok := that.(TowerAccumulateHarvestCacheInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProfitsData) != len(that1.ProfitsData) {
		return false
	}
	for i := range this.ProfitsData {
		if !this.ProfitsData[i].Equal(that1.ProfitsData[i]) {
			return false
		}
	}
	if this.LastSettlementTime != that1.LastSettlementTime {
		return false
	}
	if this.SettlementUseTime != that1.SettlementUseTime {
		return false
	}
	return true
}
func (this *ChallengeData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeData)
	if !ok {
		that2, ok := that.(ChallengeData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseChallengeTimes != that1.UseChallengeTimes {
		return false
	}
	if this.LastChallengeTime != that1.LastChallengeTime {
		return false
	}
	return true
}
func (this *TowerAccumulateHarvestInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TowerAccumulateHarvestInfo)
	if !ok {
		that2, ok := that.(TowerAccumulateHarvestInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ProfitsData) != len(that1.ProfitsData) {
		return false
	}
	for i := range this.ProfitsData {
		if !this.ProfitsData[i].Equal(that1.ProfitsData[i]) {
			return false
		}
	}
	if this.LastSettlementTime != that1.LastSettlementTime {
		return false
	}
	if this.NextSettlementTime != that1.NextSettlementTime {
		return false
	}
	if this.SettlementInterval != that1.SettlementInterval {
		return false
	}
	if this.IsMax != that1.IsMax {
		return false
	}
	if len(this.ProfitsItem) != len(that1.ProfitsItem) {
		return false
	}
	for i := range this.ProfitsItem {
		if !this.ProfitsItem[i].Equal(that1.ProfitsItem[i]) {
			return false
		}
	}
	if this.LeftFreeMeditationTimes != that1.LeftFreeMeditationTimes {
		return false
	}
	if this.UseCostMeditationTimes != that1.UseCostMeditationTimes {
		return false
	}
	if this.NextMeditationRefreshTime != that1.NextMeditationRefreshTime {
		return false
	}
	if this.NowHandleupAllTime != that1.NowHandleupAllTime {
		return false
	}
	if this.ModTime != that1.ModTime {
		return false
	}
	return true
}
func (this *MeditationData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeditationData)
	if !ok {
		that2, ok := that.(MeditationData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LastMeditationTime != that1.LastMeditationTime {
		return false
	}
	if this.UseFreeMeditationTimes != that1.UseFreeMeditationTimes {
		return false
	}
	if this.UseCostMeditationTimes != that1.UseCostMeditationTimes {
		return false
	}
	return true
}
func (this *TowerData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TowerData)
	if !ok {
		that2, ok := that.(TowerData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.CurrentTowerLevel != that1.CurrentTowerLevel {
		return false
	}
	if len(this.PassData) != len(that1.PassData) {
		return false
	}
	for i := range this.PassData {
		if !this.PassData[i].Equal(that1.PassData[i]) {
			return false
		}
	}
	if !this.CacheInfo.Equal(that1.CacheInfo) {
		return false
	}
	if !this.MeditationData.Equal(that1.MeditationData) {
		return false
	}
	if !this.ChallengeData.Equal(that1.ChallengeData) {
		return false
	}
	return true
}
func (this *HeroInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeroInfo)
	if !ok {
		that2, ok := that.(HeroInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HeroId != that1.HeroId {
		return false
	}
	if this.HeroHp != that1.HeroHp {
		return false
	}
	return true
}
func (m *TowerPassData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerPassData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TowerPassData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		dAtA2 := make([]byte, len(m.Rewards)*10)
		var j1 int
		for _, num1 := range m.Rewards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTower(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.PassTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PassTime))))
		i--
		dAtA[i] = 0x11
	}
	if m.TowerLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.TowerLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Postion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Postion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Postion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i--
		dAtA[i] = 0x11
	}
	if m.X != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Tower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextRefreshTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.NextRefreshTime))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxChallengeTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.MaxChallengeTimes))
		i--
		dAtA[i] = 0x20
	}
	if m.UseChallengeTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.UseChallengeTimes))
		i--
		dAtA[i] = 0x18
	}
	if m.IsAllPass {
		i--
		if m.IsAllPass {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CurrentTowerLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentTowerLevel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TowerAccumulateHarvestCacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerAccumulateHarvestCacheInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TowerAccumulateHarvestCacheInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SettlementUseTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.SettlementUseTime))
		i--
		dAtA[i] = 0x18
	}
	if m.LastSettlementTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.LastSettlementTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProfitsData) > 0 {
		for iNdEx := len(m.ProfitsData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProfitsData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTower(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastChallengeTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.LastChallengeTime))
		i--
		dAtA[i] = 0x10
	}
	if m.UseChallengeTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.UseChallengeTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TowerAccumulateHarvestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerAccumulateHarvestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TowerAccumulateHarvestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.ModTime))
		i--
		dAtA[i] = 0x58
	}
	if m.NowHandleupAllTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.NowHandleupAllTime))
		i--
		dAtA[i] = 0x50
	}
	if m.NextMeditationRefreshTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.NextMeditationRefreshTime))
		i--
		dAtA[i] = 0x48
	}
	if m.UseCostMeditationTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.UseCostMeditationTimes))
		i--
		dAtA[i] = 0x40
	}
	if m.LeftFreeMeditationTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.LeftFreeMeditationTimes))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ProfitsItem) > 0 {
		for iNdEx := len(m.ProfitsItem) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProfitsItem[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTower(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.IsMax {
		i--
		if m.IsMax {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SettlementInterval != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.SettlementInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.NextSettlementTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.NextSettlementTime))
		i--
		dAtA[i] = 0x18
	}
	if m.LastSettlementTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.LastSettlementTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProfitsData) > 0 {
		for iNdEx := len(m.ProfitsData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProfitsData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTower(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MeditationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeditationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeditationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseCostMeditationTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.UseCostMeditationTimes))
		i--
		dAtA[i] = 0x18
	}
	if m.UseFreeMeditationTimes != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.UseFreeMeditationTimes))
		i--
		dAtA[i] = 0x10
	}
	if m.LastMeditationTime != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.LastMeditationTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TowerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TowerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TowerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChallengeData != nil {
		{
			size, err := m.ChallengeData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MeditationData != nil {
		{
			size, err := m.MeditationData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CacheInfo != nil {
		{
			size, err := m.CacheInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTower(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PassData) > 0 {
		for k := range m.PassData {
			v := m.PassData[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTower(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTower(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTower(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CurrentTowerLevel != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.CurrentTowerLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeroInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeroInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeroHp != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.HeroHp))
		i--
		dAtA[i] = 0x10
	}
	if m.HeroId != 0 {
		i = encodeVarintTower(dAtA, i, uint64(m.HeroId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTower(dAtA []byte, offset int, v uint64) int {
	offset -= sovTower(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *TowerPassData) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.TowerLevel != 0 {
		w.RawByte('"')
		w.RawString("tower_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.TowerLevel))
		needWriteComma = true
	}
	if math.Abs(float64(m.PassTime)) > 0.000001 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("pass_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.PassTime))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("rewards")
	w.RawByte('"')
	w.RawByte(':')
	if m.Rewards == nil {
		w.RawString("null")
	} else if len(m.Rewards) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Rewards {
			w.Int64(int64(v))
			if i != len(m.Rewards)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Postion) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if math.Abs(float64(m.X)) > 0.000001 {
		w.RawByte('"')
		w.RawString("x")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.X))
		needWriteComma = true
	}
	if math.Abs(float64(m.Y)) > 0.000001 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("y")
		w.RawByte('"')
		w.RawByte(':')
		w.Float64(float64(m.Y))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tower) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.CurrentTowerLevel != 0 {
		w.RawByte('"')
		w.RawString("current_tower_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurrentTowerLevel))
		needWriteComma = true
	}
	if m.IsAllPass {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_all_pass")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsAllPass)
		needWriteComma = true
	}
	if m.UseChallengeTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("use_challenge_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.UseChallengeTimes))
		needWriteComma = true
	}
	if m.MaxChallengeTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("max_challenge_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MaxChallengeTimes))
		needWriteComma = true
	}
	if m.NextRefreshTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("next_refresh_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.NextRefreshTime))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *TowerAccumulateHarvestCacheInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("profits_data")
	w.RawByte('"')
	w.RawByte(':')
	if m.ProfitsData == nil {
		w.RawString("null")
	} else if len(m.ProfitsData) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ProfitsData {
			v.JsonBytes(w)
			if i != len(m.ProfitsData)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.LastSettlementTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("last_settlement_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LastSettlementTime))
		needWriteComma = true
	}
	if m.SettlementUseTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("settlement_use_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SettlementUseTime))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *ChallengeData) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.UseChallengeTimes != 0 {
		w.RawByte('"')
		w.RawString("use_challenge_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.UseChallengeTimes))
		needWriteComma = true
	}
	if m.LastChallengeTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("last_challenge_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LastChallengeTime))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *TowerAccumulateHarvestInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("profits_data")
	w.RawByte('"')
	w.RawByte(':')
	if m.ProfitsData == nil {
		w.RawString("null")
	} else if len(m.ProfitsData) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ProfitsData {
			v.JsonBytes(w)
			if i != len(m.ProfitsData)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.LastSettlementTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("last_settlement_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LastSettlementTime))
		needWriteComma = true
	}
	if m.NextSettlementTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("next_settlement_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.NextSettlementTime))
		needWriteComma = true
	}
	if m.SettlementInterval != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("settlement_interval")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SettlementInterval))
		needWriteComma = true
	}
	if m.IsMax {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_max")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsMax)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("profits_item")
	w.RawByte('"')
	w.RawByte(':')
	if m.ProfitsItem == nil {
		w.RawString("null")
	} else if len(m.ProfitsItem) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ProfitsItem {
			v.JsonBytes(w)
			if i != len(m.ProfitsItem)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.LeftFreeMeditationTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("left_free_meditation_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LeftFreeMeditationTimes))
		needWriteComma = true
	}
	if m.UseCostMeditationTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Use_cost_meditation_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.UseCostMeditationTimes))
		needWriteComma = true
	}
	if m.NextMeditationRefreshTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("next_meditation_refresh_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.NextMeditationRefreshTime))
		needWriteComma = true
	}
	if m.NowHandleupAllTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("now_handleup_all_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.NowHandleupAllTime))
		needWriteComma = true
	}
	if m.ModTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("mod_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ModTime))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MeditationData) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.LastMeditationTime != 0 {
		w.RawByte('"')
		w.RawString("last_meditation_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LastMeditationTime))
		needWriteComma = true
	}
	if m.UseFreeMeditationTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("use_free_meditation_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.UseFreeMeditationTimes))
		needWriteComma = true
	}
	if m.UseCostMeditationTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("use_cost_meditation_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.UseCostMeditationTimes))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *TowerData) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Type != 0 {
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Type))
		needWriteComma = true
	}
	if m.CurrentTowerLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("current_tower_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CurrentTowerLevel))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("pass_data")
	w.RawByte('"')
	w.RawByte(':')
	if m.PassData == nil {
		w.RawString("null")
	} else if len(m.PassData) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlPassData := len(m.PassData)
		for k, v := range m.PassData {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlPassData--
			if mlPassData != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("cache_info")
	w.RawByte('"')
	w.RawByte(':')
	m.CacheInfo.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("meditation_data")
	w.RawByte('"')
	w.RawByte(':')
	m.MeditationData.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("challenge_data")
	w.RawByte('"')
	w.RawByte(':')
	m.ChallengeData.JsonBytes(w)
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *HeroInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.HeroId != 0 {
		w.RawByte('"')
		w.RawString("hero_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.HeroId))
		needWriteComma = true
	}
	if m.HeroHp != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("hero_hp")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.HeroHp))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *TowerPassData) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *TowerPassData) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *TowerPassData) GoString() string {
	return m.String()
}

func (m *Postion) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Postion) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Postion) GoString() string {
	return m.String()
}

func (m *Tower) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tower) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tower) GoString() string {
	return m.String()
}

func (m *TowerAccumulateHarvestCacheInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *TowerAccumulateHarvestCacheInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *TowerAccumulateHarvestCacheInfo) GoString() string {
	return m.String()
}

func (m *ChallengeData) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *ChallengeData) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *ChallengeData) GoString() string {
	return m.String()
}

func (m *TowerAccumulateHarvestInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *TowerAccumulateHarvestInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *TowerAccumulateHarvestInfo) GoString() string {
	return m.String()
}

func (m *MeditationData) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MeditationData) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MeditationData) GoString() string {
	return m.String()
}

func (m *TowerData) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *TowerData) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *TowerData) GoString() string {
	return m.String()
}

func (m *HeroInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *HeroInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *HeroInfo) GoString() string {
	return m.String()
}

func (m *TowerPassData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TowerLevel != 0 {
		n += 1 + sovTower(uint64(m.TowerLevel))
	}
	if m.PassTime != 0 {
		n += 9
	}
	if len(m.Rewards) > 0 {
		l = 0
		for _, e := range m.Rewards {
			l += sovTower(uint64(e))
		}
		n += 1 + sovTower(uint64(l)) + l
	}
	return n
}

func (m *Postion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	return n
}

func (m *Tower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentTowerLevel != 0 {
		n += 1 + sovTower(uint64(m.CurrentTowerLevel))
	}
	if m.IsAllPass {
		n += 2
	}
	if m.UseChallengeTimes != 0 {
		n += 1 + sovTower(uint64(m.UseChallengeTimes))
	}
	if m.MaxChallengeTimes != 0 {
		n += 1 + sovTower(uint64(m.MaxChallengeTimes))
	}
	if m.NextRefreshTime != 0 {
		n += 1 + sovTower(uint64(m.NextRefreshTime))
	}
	return n
}

func (m *TowerAccumulateHarvestCacheInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProfitsData) > 0 {
		for _, e := range m.ProfitsData {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.LastSettlementTime != 0 {
		n += 1 + sovTower(uint64(m.LastSettlementTime))
	}
	if m.SettlementUseTime != 0 {
		n += 1 + sovTower(uint64(m.SettlementUseTime))
	}
	return n
}

func (m *ChallengeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseChallengeTimes != 0 {
		n += 1 + sovTower(uint64(m.UseChallengeTimes))
	}
	if m.LastChallengeTime != 0 {
		n += 1 + sovTower(uint64(m.LastChallengeTime))
	}
	return n
}

func (m *TowerAccumulateHarvestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProfitsData) > 0 {
		for _, e := range m.ProfitsData {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.LastSettlementTime != 0 {
		n += 1 + sovTower(uint64(m.LastSettlementTime))
	}
	if m.NextSettlementTime != 0 {
		n += 1 + sovTower(uint64(m.NextSettlementTime))
	}
	if m.SettlementInterval != 0 {
		n += 1 + sovTower(uint64(m.SettlementInterval))
	}
	if m.IsMax {
		n += 2
	}
	if len(m.ProfitsItem) > 0 {
		for _, e := range m.ProfitsItem {
			l = e.Size()
			n += 1 + l + sovTower(uint64(l))
		}
	}
	if m.LeftFreeMeditationTimes != 0 {
		n += 1 + sovTower(uint64(m.LeftFreeMeditationTimes))
	}
	if m.UseCostMeditationTimes != 0 {
		n += 1 + sovTower(uint64(m.UseCostMeditationTimes))
	}
	if m.NextMeditationRefreshTime != 0 {
		n += 1 + sovTower(uint64(m.NextMeditationRefreshTime))
	}
	if m.NowHandleupAllTime != 0 {
		n += 1 + sovTower(uint64(m.NowHandleupAllTime))
	}
	if m.ModTime != 0 {
		n += 1 + sovTower(uint64(m.ModTime))
	}
	return n
}

func (m *MeditationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastMeditationTime != 0 {
		n += 1 + sovTower(uint64(m.LastMeditationTime))
	}
	if m.UseFreeMeditationTimes != 0 {
		n += 1 + sovTower(uint64(m.UseFreeMeditationTimes))
	}
	if m.UseCostMeditationTimes != 0 {
		n += 1 + sovTower(uint64(m.UseCostMeditationTimes))
	}
	return n
}

func (m *TowerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTower(uint64(m.Type))
	}
	if m.CurrentTowerLevel != 0 {
		n += 1 + sovTower(uint64(m.CurrentTowerLevel))
	}
	if len(m.PassData) > 0 {
		for k, v := range m.PassData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTower(uint64(l))
			}
			mapEntrySize := 1 + sovTower(uint64(k)) + l
			n += mapEntrySize + 1 + sovTower(uint64(mapEntrySize))
		}
	}
	if m.CacheInfo != nil {
		l = m.CacheInfo.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.MeditationData != nil {
		l = m.MeditationData.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	if m.ChallengeData != nil {
		l = m.ChallengeData.Size()
		n += 1 + l + sovTower(uint64(l))
	}
	return n
}

func (m *HeroInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeroId != 0 {
		n += 1 + sovTower(uint64(m.HeroId))
	}
	if m.HeroHp != 0 {
		n += 1 + sovTower(uint64(m.HeroHp))
	}
	return n
}

func sovTower(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTower(x uint64) (n int) {
	return sovTower(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TowerPassData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerPassData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerPassData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TowerLevel", wireType)
			}
			m.TowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TowerLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PassTime = float64(math.Float64frombits(v))
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rewards = append(m.Rewards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTower
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTower
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rewards) == 0 {
					m.Rewards = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rewards = append(m.Rewards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Postion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Postion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Postion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTowerLevel", wireType)
			}
			m.CurrentTowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTowerLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllPass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllPass = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseChallengeTimes", wireType)
			}
			m.UseChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseChallengeTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChallengeTimes", wireType)
			}
			m.MaxChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxChallengeTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRefreshTime", wireType)
			}
			m.NextRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRefreshTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerAccumulateHarvestCacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerAccumulateHarvestCacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerAccumulateHarvestCacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfitsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfitsData = append(m.ProfitsData, &Item{})
			if err := m.ProfitsData[len(m.ProfitsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSettlementTime", wireType)
			}
			m.LastSettlementTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSettlementTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementUseTime", wireType)
			}
			m.SettlementUseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementUseTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseChallengeTimes", wireType)
			}
			m.UseChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseChallengeTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChallengeTime", wireType)
			}
			m.LastChallengeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChallengeTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerAccumulateHarvestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerAccumulateHarvestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerAccumulateHarvestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfitsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfitsData = append(m.ProfitsData, &Item{})
			if err := m.ProfitsData[len(m.ProfitsData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSettlementTime", wireType)
			}
			m.LastSettlementTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSettlementTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSettlementTime", wireType)
			}
			m.NextSettlementTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSettlementTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementInterval", wireType)
			}
			m.SettlementInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMax", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMax = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfitsItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfitsItem = append(m.ProfitsItem, &Item{})
			if err := m.ProfitsItem[len(m.ProfitsItem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftFreeMeditationTimes", wireType)
			}
			m.LeftFreeMeditationTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftFreeMeditationTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCostMeditationTimes", wireType)
			}
			m.UseCostMeditationTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseCostMeditationTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMeditationRefreshTime", wireType)
			}
			m.NextMeditationRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextMeditationRefreshTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowHandleupAllTime", wireType)
			}
			m.NowHandleupAllTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowHandleupAllTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTime", wireType)
			}
			m.ModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeditationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeditationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeditationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMeditationTime", wireType)
			}
			m.LastMeditationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMeditationTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseFreeMeditationTimes", wireType)
			}
			m.UseFreeMeditationTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseFreeMeditationTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCostMeditationTimes", wireType)
			}
			m.UseCostMeditationTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseCostMeditationTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TowerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TowerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TowerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TowerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTowerLevel", wireType)
			}
			m.CurrentTowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTowerLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassData == nil {
				m.PassData = make(map[int64]*TowerPassData)
			}
			var mapkey int64
			var mapvalue *TowerPassData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTower
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTower
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTower
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTower
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TowerPassData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTower(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTower
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PassData[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheInfo == nil {
				m.CacheInfo = &TowerAccumulateHarvestCacheInfo{}
			}
			if err := m.CacheInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeditationData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeditationData == nil {
				m.MeditationData = &MeditationData{}
			}
			if err := m.MeditationData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTower
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTower
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeData == nil {
				m.ChallengeData = &ChallengeData{}
			}
			if err := m.ChallengeData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTower
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroId", wireType)
			}
			m.HeroId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroHp", wireType)
			}
			m.HeroHp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTower
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroHp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTower(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTower
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTower(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTower
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTower
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTower
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTower
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTower
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTower
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTower        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTower          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTower = fmt.Errorf("proto: unexpected end of group")
)
