// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/models/activity.proto

package models

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PassesStatus int32

const (
	PassesStatus_PassesStatusLocked   PassesStatus = 0
	PassesStatus_PassesStatusGeneral  PassesStatus = 1
	PassesStatus_PassesStatusAdvanced PassesStatus = 2
)

var PassesStatus_name = map[int32]string{
	0: "PassesStatusLocked",
	1: "PassesStatusGeneral",
	2: "PassesStatusAdvanced",
}

var PassesStatus_value = map[string]int32{
	"PassesStatusLocked":   0,
	"PassesStatusGeneral":  1,
	"PassesStatusAdvanced": 2,
}

func (PassesStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{0}
}

type Activity struct {
	Id                         int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Sort                       int64    `protobuf:"varint,2,opt,name=sort,proto3" json:"sort,omitempty"`
	ActivityDescribeLanguageId []string `protobuf:"bytes,4,rep,name=activity_describe_language_id,json=activityDescribeLanguageId,proto3" json:"activity_describe_language_id,omitempty"`
	Begin                      int64    `protobuf:"varint,6,opt,name=begin,proto3" json:"begin,omitempty"`
	End                        int64    `protobuf:"varint,7,opt,name=end,proto3" json:"end,omitempty"`
	SystemId                   int64    `protobuf:"varint,9,opt,name=system_id,json=systemId,proto3" json:"system_id,omitempty"`
	ChargeId                   []string `protobuf:"bytes,10,rep,name=ChargeId,proto3" json:"ChargeId,omitempty"`
}

func (m *Activity) Reset()      { *m = Activity{} }
func (*Activity) ProtoMessage() {}
func (*Activity) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{0}
}
func (m *Activity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Activity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Activity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Activity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Activity.Merge(m, src)
}
func (m *Activity) XXX_Size() int {
	return m.Size()
}
func (m *Activity) XXX_DiscardUnknown() {
	xxx_messageInfo_Activity.DiscardUnknown(m)
}

var xxx_messageInfo_Activity proto.InternalMessageInfo

func (m *Activity) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Activity) GetSort() int64 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *Activity) GetActivityDescribeLanguageId() []string {
	if m != nil {
		return m.ActivityDescribeLanguageId
	}
	return nil
}

func (m *Activity) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Activity) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Activity) GetSystemId() int64 {
	if m != nil {
		return m.SystemId
	}
	return 0
}

func (m *Activity) GetChargeId() []string {
	if m != nil {
		return m.ChargeId
	}
	return nil
}

func (*Activity) XXX_MessageName() string {
	return "models.Activity"
}

type SevenDaysInfo struct {
	SignedInDay        int64   `protobuf:"varint,1,opt,name=signed_in_day,json=signedInDay,proto3" json:"signed_in_day,omitempty"`
	ReceivedRewardDays []int64 `protobuf:"varint,2,rep,packed,name=received_reward_days,json=receivedRewardDays,proto3" json:"received_reward_days,omitempty"`
	ActivityId         int64   `protobuf:"varint,3,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
}

func (m *SevenDaysInfo) Reset()      { *m = SevenDaysInfo{} }
func (*SevenDaysInfo) ProtoMessage() {}
func (*SevenDaysInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{1}
}
func (m *SevenDaysInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SevenDaysInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SevenDaysInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SevenDaysInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SevenDaysInfo.Merge(m, src)
}
func (m *SevenDaysInfo) XXX_Size() int {
	return m.Size()
}
func (m *SevenDaysInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SevenDaysInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SevenDaysInfo proto.InternalMessageInfo

func (m *SevenDaysInfo) GetSignedInDay() int64 {
	if m != nil {
		return m.SignedInDay
	}
	return 0
}

func (m *SevenDaysInfo) GetReceivedRewardDays() []int64 {
	if m != nil {
		return m.ReceivedRewardDays
	}
	return nil
}

func (m *SevenDaysInfo) GetActivityId() int64 {
	if m != nil {
		return m.ActivityId
	}
	return 0
}

func (*SevenDaysInfo) XXX_MessageName() string {
	return "models.SevenDaysInfo"
}

// 礼包
type GiftBag struct {
	Id        int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Items     map[int64]int64 `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ChargeId  int64           `protobuf:"varint,3,opt,name=charge_id,json=chargeId,proto3" json:"charge_id,omitempty"`
	IsSoldOut bool            `protobuf:"varint,4,opt,name=is_sold_out,json=isSoldOut,proto3" json:"is_sold_out,omitempty"`
	PayValue  int64           `protobuf:"varint,5,opt,name=pay_value,json=payValue,proto3" json:"pay_value,omitempty"`
}

func (m *GiftBag) Reset()      { *m = GiftBag{} }
func (*GiftBag) ProtoMessage() {}
func (*GiftBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{2}
}
func (m *GiftBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GiftBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftBag.Merge(m, src)
}
func (m *GiftBag) XXX_Size() int {
	return m.Size()
}
func (m *GiftBag) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftBag.DiscardUnknown(m)
}

var xxx_messageInfo_GiftBag proto.InternalMessageInfo

func (m *GiftBag) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GiftBag) GetItems() map[int64]int64 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *GiftBag) GetChargeId() int64 {
	if m != nil {
		return m.ChargeId
	}
	return 0
}

func (m *GiftBag) GetIsSoldOut() bool {
	if m != nil {
		return m.IsSoldOut
	}
	return false
}

func (m *GiftBag) GetPayValue() int64 {
	if m != nil {
		return m.PayValue
	}
	return 0
}

func (*GiftBag) XXX_MessageName() string {
	return "models.GiftBag"
}

// 限时弹窗礼包
type LimitedTimePackage struct {
	Id                 int64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Begin              int64      `protobuf:"varint,3,opt,name=begin,proto3" json:"begin,omitempty"`
	End                int64      `protobuf:"varint,4,opt,name=end,proto3" json:"end,omitempty"`
	MainCityIcon       string     `protobuf:"bytes,5,opt,name=main_city_icon,json=mainCityIcon,proto3" json:"main_city_icon,omitempty"`
	Banner             string     `protobuf:"bytes,6,opt,name=banner,proto3" json:"banner,omitempty"`
	Name               int64      `protobuf:"varint,7,opt,name=name,proto3" json:"name,omitempty"`
	DescribeLanguageId []int64    `protobuf:"varint,8,rep,packed,name=describe_language_id,json=describeLanguageId,proto3" json:"describe_language_id,omitempty"`
	Bags               []*GiftBag `protobuf:"bytes,9,rep,name=bags,proto3" json:"bags,omitempty"`
	RealEnd            int64      `protobuf:"varint,10,opt,name=real_end,json=realEnd,proto3" json:"real_end,omitempty"`
}

func (m *LimitedTimePackage) Reset()      { *m = LimitedTimePackage{} }
func (*LimitedTimePackage) ProtoMessage() {}
func (*LimitedTimePackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{3}
}
func (m *LimitedTimePackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimitedTimePackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimitedTimePackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimitedTimePackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimitedTimePackage.Merge(m, src)
}
func (m *LimitedTimePackage) XXX_Size() int {
	return m.Size()
}
func (m *LimitedTimePackage) XXX_DiscardUnknown() {
	xxx_messageInfo_LimitedTimePackage.DiscardUnknown(m)
}

var xxx_messageInfo_LimitedTimePackage proto.InternalMessageInfo

func (m *LimitedTimePackage) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LimitedTimePackage) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *LimitedTimePackage) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *LimitedTimePackage) GetMainCityIcon() string {
	if m != nil {
		return m.MainCityIcon
	}
	return ""
}

func (m *LimitedTimePackage) GetBanner() string {
	if m != nil {
		return m.Banner
	}
	return ""
}

func (m *LimitedTimePackage) GetName() int64 {
	if m != nil {
		return m.Name
	}
	return 0
}

func (m *LimitedTimePackage) GetDescribeLanguageId() []int64 {
	if m != nil {
		return m.DescribeLanguageId
	}
	return nil
}

func (m *LimitedTimePackage) GetBags() []*GiftBag {
	if m != nil {
		return m.Bags
	}
	return nil
}

func (m *LimitedTimePackage) GetRealEnd() int64 {
	if m != nil {
		return m.RealEnd
	}
	return 0
}

func (*LimitedTimePackage) XXX_MessageName() string {
	return "models.LimitedTimePackage"
}

type LevelGrowthFundItem struct {
	Free bool `protobuf:"varint,1,opt,name=free,proto3" json:"free,omitempty"`
	Paid bool `protobuf:"varint,2,opt,name=paid,proto3" json:"paid,omitempty"`
}

func (m *LevelGrowthFundItem) Reset()      { *m = LevelGrowthFundItem{} }
func (*LevelGrowthFundItem) ProtoMessage() {}
func (*LevelGrowthFundItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{4}
}
func (m *LevelGrowthFundItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LevelGrowthFundItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LevelGrowthFundItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LevelGrowthFundItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LevelGrowthFundItem.Merge(m, src)
}
func (m *LevelGrowthFundItem) XXX_Size() int {
	return m.Size()
}
func (m *LevelGrowthFundItem) XXX_DiscardUnknown() {
	xxx_messageInfo_LevelGrowthFundItem.DiscardUnknown(m)
}

var xxx_messageInfo_LevelGrowthFundItem proto.InternalMessageInfo

func (m *LevelGrowthFundItem) GetFree() bool {
	if m != nil {
		return m.Free
	}
	return false
}

func (m *LevelGrowthFundItem) GetPaid() bool {
	if m != nil {
		return m.Paid
	}
	return false
}

func (*LevelGrowthFundItem) XXX_MessageName() string {
	return "models.LevelGrowthFundItem"
}

type LevelGrowthFundCfg struct {
	Id                int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TypeId            int64   `protobuf:"varint,2,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	Level             int64   `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	ActivityReward    []int64 `protobuf:"varint,4,rep,packed,name=activity_reward,json=activityReward,proto3" json:"activity_reward,omitempty"`
	ActivityPayReward []int64 `protobuf:"varint,5,rep,packed,name=activity_pay_reward,json=activityPayReward,proto3" json:"activity_pay_reward,omitempty"`
}

func (m *LevelGrowthFundCfg) Reset()      { *m = LevelGrowthFundCfg{} }
func (*LevelGrowthFundCfg) ProtoMessage() {}
func (*LevelGrowthFundCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{5}
}
func (m *LevelGrowthFundCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LevelGrowthFundCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LevelGrowthFundCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LevelGrowthFundCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LevelGrowthFundCfg.Merge(m, src)
}
func (m *LevelGrowthFundCfg) XXX_Size() int {
	return m.Size()
}
func (m *LevelGrowthFundCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_LevelGrowthFundCfg.DiscardUnknown(m)
}

var xxx_messageInfo_LevelGrowthFundCfg proto.InternalMessageInfo

func (m *LevelGrowthFundCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LevelGrowthFundCfg) GetTypeId() int64 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *LevelGrowthFundCfg) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *LevelGrowthFundCfg) GetActivityReward() []int64 {
	if m != nil {
		return m.ActivityReward
	}
	return nil
}

func (m *LevelGrowthFundCfg) GetActivityPayReward() []int64 {
	if m != nil {
		return m.ActivityPayReward
	}
	return nil
}

func (*LevelGrowthFundCfg) XXX_MessageName() string {
	return "models.LevelGrowthFundCfg"
}

type FirstPayCfg struct {
	Id             int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TypeId         int64   `protobuf:"varint,2,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	ItemPictureId  string  `protobuf:"bytes,3,opt,name=item_picture_id,json=itemPictureId,proto3" json:"item_picture_id,omitempty"`
	SpecialFieldId string  `protobuf:"bytes,4,opt,name=special_field_id,json=specialFieldId,proto3" json:"special_field_id,omitempty"`
	Day            int64   `protobuf:"varint,5,opt,name=day,proto3" json:"day,omitempty"`
	ActivityReward []int64 `protobuf:"varint,6,rep,packed,name=activity_reward,json=activityReward,proto3" json:"activity_reward,omitempty"`
}

func (m *FirstPayCfg) Reset()      { *m = FirstPayCfg{} }
func (*FirstPayCfg) ProtoMessage() {}
func (*FirstPayCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{6}
}
func (m *FirstPayCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirstPayCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirstPayCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirstPayCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstPayCfg.Merge(m, src)
}
func (m *FirstPayCfg) XXX_Size() int {
	return m.Size()
}
func (m *FirstPayCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstPayCfg.DiscardUnknown(m)
}

var xxx_messageInfo_FirstPayCfg proto.InternalMessageInfo

func (m *FirstPayCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FirstPayCfg) GetTypeId() int64 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *FirstPayCfg) GetItemPictureId() string {
	if m != nil {
		return m.ItemPictureId
	}
	return ""
}

func (m *FirstPayCfg) GetSpecialFieldId() string {
	if m != nil {
		return m.SpecialFieldId
	}
	return ""
}

func (m *FirstPayCfg) GetDay() int64 {
	if m != nil {
		return m.Day
	}
	return 0
}

func (m *FirstPayCfg) GetActivityReward() []int64 {
	if m != nil {
		return m.ActivityReward
	}
	return nil
}

func (*FirstPayCfg) XXX_MessageName() string {
	return "models.FirstPayCfg"
}

type AccRechargeCfg struct {
	Id             int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DemandAmount   int64   `protobuf:"varint,2,opt,name=demand_amount,json=demandAmount,proto3" json:"demand_amount,omitempty"`
	RechargeReward []int64 `protobuf:"varint,3,rep,packed,name=recharge_reward,json=rechargeReward,proto3" json:"recharge_reward,omitempty"`
}

func (m *AccRechargeCfg) Reset()      { *m = AccRechargeCfg{} }
func (*AccRechargeCfg) ProtoMessage() {}
func (*AccRechargeCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{7}
}
func (m *AccRechargeCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccRechargeCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccRechargeCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccRechargeCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccRechargeCfg.Merge(m, src)
}
func (m *AccRechargeCfg) XXX_Size() int {
	return m.Size()
}
func (m *AccRechargeCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_AccRechargeCfg.DiscardUnknown(m)
}

var xxx_messageInfo_AccRechargeCfg proto.InternalMessageInfo

func (m *AccRechargeCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AccRechargeCfg) GetDemandAmount() int64 {
	if m != nil {
		return m.DemandAmount
	}
	return 0
}

func (m *AccRechargeCfg) GetRechargeReward() []int64 {
	if m != nil {
		return m.RechargeReward
	}
	return nil
}

func (*AccRechargeCfg) XXX_MessageName() string {
	return "models.AccRechargeCfg"
}

type DailySaleCfg struct {
	Id             int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BuyType        int64   `protobuf:"varint,2,opt,name=buy_type,json=buyType,proto3" json:"buy_type,omitempty"`
	PayId          []int64 `protobuf:"varint,3,rep,packed,name=pay_id,json=payId,proto3" json:"pay_id,omitempty"`
	ActivityReward []int64 `protobuf:"varint,4,rep,packed,name=activity_reward,json=activityReward,proto3" json:"activity_reward,omitempty"`
	ItemPictureId  string  `protobuf:"bytes,5,opt,name=item_picture_id,json=itemPictureId,proto3" json:"item_picture_id,omitempty"`
	PayNum         int64   `protobuf:"varint,6,opt,name=pay_num,json=payNum,proto3" json:"pay_num,omitempty"`
	ActivityGridId int64   `protobuf:"varint,7,opt,name=activity_grid_id,json=activityGridId,proto3" json:"activity_grid_id,omitempty"`
}

func (m *DailySaleCfg) Reset()      { *m = DailySaleCfg{} }
func (*DailySaleCfg) ProtoMessage() {}
func (*DailySaleCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{8}
}
func (m *DailySaleCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailySaleCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailySaleCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DailySaleCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailySaleCfg.Merge(m, src)
}
func (m *DailySaleCfg) XXX_Size() int {
	return m.Size()
}
func (m *DailySaleCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_DailySaleCfg.DiscardUnknown(m)
}

var xxx_messageInfo_DailySaleCfg proto.InternalMessageInfo

func (m *DailySaleCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DailySaleCfg) GetBuyType() int64 {
	if m != nil {
		return m.BuyType
	}
	return 0
}

func (m *DailySaleCfg) GetPayId() []int64 {
	if m != nil {
		return m.PayId
	}
	return nil
}

func (m *DailySaleCfg) GetActivityReward() []int64 {
	if m != nil {
		return m.ActivityReward
	}
	return nil
}

func (m *DailySaleCfg) GetItemPictureId() string {
	if m != nil {
		return m.ItemPictureId
	}
	return ""
}

func (m *DailySaleCfg) GetPayNum() int64 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

func (m *DailySaleCfg) GetActivityGridId() int64 {
	if m != nil {
		return m.ActivityGridId
	}
	return 0
}

func (*DailySaleCfg) XXX_MessageName() string {
	return "models.DailySaleCfg"
}

type WeeklySaleCfg struct {
	Id             int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BuyType        int64   `protobuf:"varint,2,opt,name=buy_type,json=buyType,proto3" json:"buy_type,omitempty"`
	PayId          []int64 `protobuf:"varint,3,rep,packed,name=pay_id,json=payId,proto3" json:"pay_id,omitempty"`
	ActivityReward []int64 `protobuf:"varint,4,rep,packed,name=activity_reward,json=activityReward,proto3" json:"activity_reward,omitempty"`
	ItemPictureId  string  `protobuf:"bytes,5,opt,name=item_picture_id,json=itemPictureId,proto3" json:"item_picture_id,omitempty"`
	PayNum         int64   `protobuf:"varint,6,opt,name=pay_num,json=payNum,proto3" json:"pay_num,omitempty"`
	ActivityGridId int64   `protobuf:"varint,7,opt,name=activity_grid_id,json=activityGridId,proto3" json:"activity_grid_id,omitempty"`
}

func (m *WeeklySaleCfg) Reset()      { *m = WeeklySaleCfg{} }
func (*WeeklySaleCfg) ProtoMessage() {}
func (*WeeklySaleCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{9}
}
func (m *WeeklySaleCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WeeklySaleCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WeeklySaleCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WeeklySaleCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WeeklySaleCfg.Merge(m, src)
}
func (m *WeeklySaleCfg) XXX_Size() int {
	return m.Size()
}
func (m *WeeklySaleCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_WeeklySaleCfg.DiscardUnknown(m)
}

var xxx_messageInfo_WeeklySaleCfg proto.InternalMessageInfo

func (m *WeeklySaleCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *WeeklySaleCfg) GetBuyType() int64 {
	if m != nil {
		return m.BuyType
	}
	return 0
}

func (m *WeeklySaleCfg) GetPayId() []int64 {
	if m != nil {
		return m.PayId
	}
	return nil
}

func (m *WeeklySaleCfg) GetActivityReward() []int64 {
	if m != nil {
		return m.ActivityReward
	}
	return nil
}

func (m *WeeklySaleCfg) GetItemPictureId() string {
	if m != nil {
		return m.ItemPictureId
	}
	return ""
}

func (m *WeeklySaleCfg) GetPayNum() int64 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

func (m *WeeklySaleCfg) GetActivityGridId() int64 {
	if m != nil {
		return m.ActivityGridId
	}
	return 0
}

func (*WeeklySaleCfg) XXX_MessageName() string {
	return "models.WeeklySaleCfg"
}

type StellargemShopCfg struct {
	Id                 int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StellarGemNum      []int64 `protobuf:"varint,2,rep,packed,name=stellar_gem_num,json=stellarGemNum,proto3" json:"stellar_gem_num,omitempty"`
	SourceGemNum       []int64 `protobuf:"varint,3,rep,packed,name=source_gem_num,json=sourceGemNum,proto3" json:"source_gem_num,omitempty"`
	ExtraGemNum        []int64 `protobuf:"varint,4,rep,packed,name=extra_gem_num,json=extraGemNum,proto3" json:"extra_gem_num,omitempty"`
	GiftLanguage       int64   `protobuf:"varint,5,opt,name=gift_language,json=giftLanguage,proto3" json:"gift_language,omitempty"`
	BuyGiftLanguage    int64   `protobuf:"varint,6,opt,name=buy_gift_language,json=buyGiftLanguage,proto3" json:"buy_gift_language,omitempty"`
	StellarGemIconName string  `protobuf:"bytes,7,opt,name=stellar_gem_icon_name,json=stellarGemIconName,proto3" json:"stellar_gem_icon_name,omitempty"`
	PurchasePrice      int64   `protobuf:"varint,8,opt,name=purchase_price,json=purchasePrice,proto3" json:"purchase_price,omitempty"`
	Tags               string  `protobuf:"bytes,9,opt,name=tags,proto3" json:"tags,omitempty"`
	GiftTags           string  `protobuf:"bytes,10,opt,name=gift_tags,json=giftTags,proto3" json:"gift_tags,omitempty"`
}

func (m *StellargemShopCfg) Reset()      { *m = StellargemShopCfg{} }
func (*StellargemShopCfg) ProtoMessage() {}
func (*StellargemShopCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{10}
}
func (m *StellargemShopCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StellargemShopCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StellargemShopCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StellargemShopCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StellargemShopCfg.Merge(m, src)
}
func (m *StellargemShopCfg) XXX_Size() int {
	return m.Size()
}
func (m *StellargemShopCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_StellargemShopCfg.DiscardUnknown(m)
}

var xxx_messageInfo_StellargemShopCfg proto.InternalMessageInfo

func (m *StellargemShopCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StellargemShopCfg) GetStellarGemNum() []int64 {
	if m != nil {
		return m.StellarGemNum
	}
	return nil
}

func (m *StellargemShopCfg) GetSourceGemNum() []int64 {
	if m != nil {
		return m.SourceGemNum
	}
	return nil
}

func (m *StellargemShopCfg) GetExtraGemNum() []int64 {
	if m != nil {
		return m.ExtraGemNum
	}
	return nil
}

func (m *StellargemShopCfg) GetGiftLanguage() int64 {
	if m != nil {
		return m.GiftLanguage
	}
	return 0
}

func (m *StellargemShopCfg) GetBuyGiftLanguage() int64 {
	if m != nil {
		return m.BuyGiftLanguage
	}
	return 0
}

func (m *StellargemShopCfg) GetStellarGemIconName() string {
	if m != nil {
		return m.StellarGemIconName
	}
	return ""
}

func (m *StellargemShopCfg) GetPurchasePrice() int64 {
	if m != nil {
		return m.PurchasePrice
	}
	return 0
}

func (m *StellargemShopCfg) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *StellargemShopCfg) GetGiftTags() string {
	if m != nil {
		return m.GiftTags
	}
	return ""
}

func (*StellargemShopCfg) XXX_MessageName() string {
	return "models.StellargemShopCfg"
}

// 通行证奖励
type PassesReward struct {
	Id          int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lv          int64           `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	RewardType  int64           `protobuf:"varint,3,opt,name=reward_type,json=rewardType,proto3" json:"reward_type,omitempty"`
	FreeReward  map[int64]int64 `protobuf:"bytes,4,rep,name=free_reward,json=freeReward,proto3" json:"free_reward,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	PaidReward  map[int64]int64 `protobuf:"bytes,5,rep,name=paid_reward,json=paidReward,proto3" json:"paid_reward,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	RequiredExp int64           `protobuf:"varint,6,opt,name=required_exp,json=requiredExp,proto3" json:"required_exp,omitempty"`
	LvRange     []int64         `protobuf:"varint,7,rep,packed,name=lv_range,json=lvRange,proto3" json:"lv_range,omitempty"`
}

func (m *PassesReward) Reset()      { *m = PassesReward{} }
func (*PassesReward) ProtoMessage() {}
func (*PassesReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{11}
}
func (m *PassesReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassesReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassesReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PassesReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassesReward.Merge(m, src)
}
func (m *PassesReward) XXX_Size() int {
	return m.Size()
}
func (m *PassesReward) XXX_DiscardUnknown() {
	xxx_messageInfo_PassesReward.DiscardUnknown(m)
}

var xxx_messageInfo_PassesReward proto.InternalMessageInfo

func (m *PassesReward) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PassesReward) GetLv() int64 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *PassesReward) GetRewardType() int64 {
	if m != nil {
		return m.RewardType
	}
	return 0
}

func (m *PassesReward) GetFreeReward() map[int64]int64 {
	if m != nil {
		return m.FreeReward
	}
	return nil
}

func (m *PassesReward) GetPaidReward() map[int64]int64 {
	if m != nil {
		return m.PaidReward
	}
	return nil
}

func (m *PassesReward) GetRequiredExp() int64 {
	if m != nil {
		return m.RequiredExp
	}
	return 0
}

func (m *PassesReward) GetLvRange() []int64 {
	if m != nil {
		return m.LvRange
	}
	return nil
}

func (*PassesReward) XXX_MessageName() string {
	return "models.PassesReward"
}

// 通行证数据
type PassesData struct {
	Lv         int64                  `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	Exp        int64                  `protobuf:"varint,3,opt,name=exp,proto3" json:"exp,omitempty"`
	Status     PassesStatus           `protobuf:"varint,4,opt,name=status,proto3,enum=models.PassesStatus" json:"status,omitempty"`
	FreeUnlock map[int64]RewardStatus `protobuf:"bytes,5,rep,name=free_unlock,json=freeUnlock,proto3" json:"free_unlock,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=models.RewardStatus"`
	PaidUnlock map[int64]RewardStatus `protobuf:"bytes,6,rep,name=paid_unlock,json=paidUnlock,proto3" json:"paid_unlock,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=models.RewardStatus"`
	ResetAt    int64                  `protobuf:"varint,7,opt,name=reset_at,json=resetAt,proto3" json:"reset_at,omitempty"`
}

func (m *PassesData) Reset()      { *m = PassesData{} }
func (*PassesData) ProtoMessage() {}
func (*PassesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{12}
}
func (m *PassesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PassesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassesData.Merge(m, src)
}
func (m *PassesData) XXX_Size() int {
	return m.Size()
}
func (m *PassesData) XXX_DiscardUnknown() {
	xxx_messageInfo_PassesData.DiscardUnknown(m)
}

var xxx_messageInfo_PassesData proto.InternalMessageInfo

func (m *PassesData) GetLv() int64 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *PassesData) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *PassesData) GetStatus() PassesStatus {
	if m != nil {
		return m.Status
	}
	return PassesStatus_PassesStatusLocked
}

func (m *PassesData) GetFreeUnlock() map[int64]RewardStatus {
	if m != nil {
		return m.FreeUnlock
	}
	return nil
}

func (m *PassesData) GetPaidUnlock() map[int64]RewardStatus {
	if m != nil {
		return m.PaidUnlock
	}
	return nil
}

func (m *PassesData) GetResetAt() int64 {
	if m != nil {
		return m.ResetAt
	}
	return 0
}

func (*PassesData) XXX_MessageName() string {
	return "models.PassesData"
}

// 通行证
type Passes struct {
	Data         *PassesData     `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	RewardCfgs   []*PassesReward `protobuf:"bytes,2,rep,name=reward_cfgs,json=rewardCfgs,proto3" json:"reward_cfgs,omitempty"`
	AdvancePrice int64           `protobuf:"varint,3,opt,name=advance_price,json=advancePrice,proto3" json:"advance_price,omitempty"`
}

func (m *Passes) Reset()      { *m = Passes{} }
func (*Passes) ProtoMessage() {}
func (*Passes) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{13}
}
func (m *Passes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Passes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Passes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Passes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Passes.Merge(m, src)
}
func (m *Passes) XXX_Size() int {
	return m.Size()
}
func (m *Passes) XXX_DiscardUnknown() {
	xxx_messageInfo_Passes.DiscardUnknown(m)
}

var xxx_messageInfo_Passes proto.InternalMessageInfo

func (m *Passes) GetData() *PassesData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Passes) GetRewardCfgs() []*PassesReward {
	if m != nil {
		return m.RewardCfgs
	}
	return nil
}

func (m *Passes) GetAdvancePrice() int64 {
	if m != nil {
		return m.AdvancePrice
	}
	return 0
}

func (*Passes) XXX_MessageName() string {
	return "models.Passes"
}

// 零元购
type ZeroBuy struct {
	BuyAt []int64 `protobuf:"varint,1,rep,packed,name=buy_at,json=buyAt,proto3" json:"buy_at,omitempty"`
}

func (m *ZeroBuy) Reset()      { *m = ZeroBuy{} }
func (*ZeroBuy) ProtoMessage() {}
func (*ZeroBuy) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{14}
}
func (m *ZeroBuy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroBuy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroBuy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroBuy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroBuy.Merge(m, src)
}
func (m *ZeroBuy) XXX_Size() int {
	return m.Size()
}
func (m *ZeroBuy) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroBuy.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroBuy proto.InternalMessageInfo

func (m *ZeroBuy) GetBuyAt() []int64 {
	if m != nil {
		return m.BuyAt
	}
	return nil
}

func (*ZeroBuy) XXX_MessageName() string {
	return "models.ZeroBuy"
}

type ZeroBuyCfg struct {
	Id                int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ActivityId        int64    `protobuf:"varint,2,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	Day               int64    `protobuf:"varint,3,opt,name=day,proto3" json:"day,omitempty"`
	RewardImmediately []int64  `protobuf:"varint,4,rep,packed,name=reward_immediately,json=rewardImmediately,proto3" json:"reward_immediately,omitempty"`
	RewardTomo        []int64  `protobuf:"varint,5,rep,packed,name=reward_tomo,json=rewardTomo,proto3" json:"reward_tomo,omitempty"`
	CostItem          []int64  `protobuf:"varint,6,rep,packed,name=cost_item,json=costItem,proto3" json:"cost_item,omitempty"`
	PictureId         []string `protobuf:"bytes,7,rep,name=picture_id,json=pictureId,proto3" json:"picture_id,omitempty"`
}

func (m *ZeroBuyCfg) Reset()      { *m = ZeroBuyCfg{} }
func (*ZeroBuyCfg) ProtoMessage() {}
func (*ZeroBuyCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_50d96ae539e8265e, []int{15}
}
func (m *ZeroBuyCfg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroBuyCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroBuyCfg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroBuyCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroBuyCfg.Merge(m, src)
}
func (m *ZeroBuyCfg) XXX_Size() int {
	return m.Size()
}
func (m *ZeroBuyCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroBuyCfg.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroBuyCfg proto.InternalMessageInfo

func (m *ZeroBuyCfg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ZeroBuyCfg) GetActivityId() int64 {
	if m != nil {
		return m.ActivityId
	}
	return 0
}

func (m *ZeroBuyCfg) GetDay() int64 {
	if m != nil {
		return m.Day
	}
	return 0
}

func (m *ZeroBuyCfg) GetRewardImmediately() []int64 {
	if m != nil {
		return m.RewardImmediately
	}
	return nil
}

func (m *ZeroBuyCfg) GetRewardTomo() []int64 {
	if m != nil {
		return m.RewardTomo
	}
	return nil
}

func (m *ZeroBuyCfg) GetCostItem() []int64 {
	if m != nil {
		return m.CostItem
	}
	return nil
}

func (m *ZeroBuyCfg) GetPictureId() []string {
	if m != nil {
		return m.PictureId
	}
	return nil
}

func (*ZeroBuyCfg) XXX_MessageName() string {
	return "models.ZeroBuyCfg"
}
func init() {
	proto.RegisterEnum("models.PassesStatus", PassesStatus_name, PassesStatus_value)
	proto.RegisterType((*Activity)(nil), "models.Activity")
	proto.RegisterType((*SevenDaysInfo)(nil), "models.SevenDaysInfo")
	proto.RegisterType((*GiftBag)(nil), "models.GiftBag")
	proto.RegisterMapType((map[int64]int64)(nil), "models.GiftBag.ItemsEntry")
	proto.RegisterType((*LimitedTimePackage)(nil), "models.LimitedTimePackage")
	proto.RegisterType((*LevelGrowthFundItem)(nil), "models.LevelGrowthFundItem")
	proto.RegisterType((*LevelGrowthFundCfg)(nil), "models.LevelGrowthFundCfg")
	proto.RegisterType((*FirstPayCfg)(nil), "models.FirstPayCfg")
	proto.RegisterType((*AccRechargeCfg)(nil), "models.AccRechargeCfg")
	proto.RegisterType((*DailySaleCfg)(nil), "models.DailySaleCfg")
	proto.RegisterType((*WeeklySaleCfg)(nil), "models.WeeklySaleCfg")
	proto.RegisterType((*StellargemShopCfg)(nil), "models.StellargemShopCfg")
	proto.RegisterType((*PassesReward)(nil), "models.PassesReward")
	proto.RegisterMapType((map[int64]int64)(nil), "models.PassesReward.FreeRewardEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "models.PassesReward.PaidRewardEntry")
	proto.RegisterType((*PassesData)(nil), "models.PassesData")
	proto.RegisterMapType((map[int64]RewardStatus)(nil), "models.PassesData.FreeUnlockEntry")
	proto.RegisterMapType((map[int64]RewardStatus)(nil), "models.PassesData.PaidUnlockEntry")
	proto.RegisterType((*Passes)(nil), "models.Passes")
	proto.RegisterType((*ZeroBuy)(nil), "models.ZeroBuy")
	proto.RegisterType((*ZeroBuyCfg)(nil), "models.ZeroBuyCfg")
}

func init() { proto.RegisterFile("proto/models/activity.proto", fileDescriptor_50d96ae539e8265e) }

var fileDescriptor_50d96ae539e8265e = []byte{
	// 1533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x4b, 0x6f, 0x1c, 0xc7,
	0x11, 0xe6, 0xec, 0x92, 0xfb, 0xa8, 0x7d, 0x90, 0x6c, 0x51, 0xd2, 0x8a, 0x82, 0x56, 0xcc, 0x48,
	0x51, 0x08, 0x21, 0x22, 0x15, 0x06, 0x01, 0x84, 0x00, 0x3a, 0x50, 0x7c, 0x61, 0x01, 0x46, 0x21,
	0x66, 0x95, 0x04, 0xd1, 0x65, 0xd0, 0x3b, 0xdd, 0xbb, 0x6c, 0x70, 0x5e, 0x99, 0xc7, 0x8a, 0xf3,
	0x07, 0x72, 0xca, 0x41, 0xd7, 0xfc, 0x83, 0x00, 0xf1, 0xbf, 0xf0, 0x45, 0x47, 0xc1, 0x27, 0x01,
	0x3e, 0xd8, 0x26, 0x6d, 0xc0, 0x47, 0xfb, 0x1f, 0x18, 0xd5, 0xdd, 0x33, 0x1c, 0x92, 0x2b, 0xc0,
	0x02, 0x7c, 0xf2, 0xad, 0xfb, 0xeb, 0xea, 0xaa, 0xa9, 0xfa, 0xaa, 0xbf, 0xee, 0x81, 0xbb, 0x61,
	0x14, 0x24, 0xc1, 0xa6, 0x17, 0x30, 0xee, 0xc6, 0x9b, 0xd4, 0x49, 0xc4, 0x54, 0x24, 0xd9, 0x86,
	0x44, 0x49, 0x4d, 0xc1, 0xab, 0xbd, 0x4b, 0x46, 0xdc, 0x4f, 0xbd, 0x58, 0x59, 0x98, 0x5f, 0x18,
	0xd0, 0xd8, 0xd6, 0x9b, 0x48, 0x17, 0x2a, 0x82, 0xf5, 0x8c, 0x35, 0x63, 0xbd, 0x6a, 0x55, 0x04,
	0x23, 0x04, 0xe6, 0xe3, 0x20, 0x4a, 0x7a, 0x15, 0x89, 0xc8, 0x31, 0xd9, 0x86, 0x7b, 0x79, 0x10,
	0x9b, 0xf1, 0xd8, 0x89, 0xc4, 0x88, 0xdb, 0x2e, 0xf5, 0x27, 0x29, 0x9d, 0x70, 0x5b, 0xb0, 0xde,
	0xfc, 0x5a, 0x75, 0xbd, 0x69, 0xad, 0xe6, 0x46, 0xbb, 0xda, 0xe6, 0x50, 0x9b, 0x0c, 0x18, 0x59,
	0x81, 0x85, 0x11, 0x9f, 0x08, 0xbf, 0x57, 0x93, 0x7e, 0xd5, 0x84, 0x2c, 0x41, 0x95, 0xfb, 0xac,
	0x57, 0x97, 0x18, 0x0e, 0xc9, 0x5d, 0x68, 0xc6, 0x59, 0x9c, 0x70, 0x0f, 0xdd, 0x36, 0x25, 0xde,
	0x50, 0xc0, 0x80, 0x91, 0x55, 0x68, 0xec, 0x1c, 0xd3, 0x08, 0x1d, 0xf6, 0x40, 0x86, 0x2c, 0xe6,
	0xe6, 0xbf, 0x0d, 0xe8, 0x0c, 0xf9, 0x94, 0xfb, 0xbb, 0x34, 0x8b, 0x07, 0xfe, 0x38, 0x20, 0x26,
	0x74, 0x62, 0x31, 0xf1, 0x39, 0xb3, 0x85, 0x6f, 0x33, 0x9a, 0xe9, 0x24, 0x5b, 0x0a, 0x1c, 0xa0,
	0x21, 0x79, 0x0a, 0x2b, 0x11, 0x77, 0xb8, 0x98, 0x72, 0x66, 0x47, 0xfc, 0x0d, 0x8d, 0x18, 0x5a,
	0xc6, 0xbd, 0xca, 0x5a, 0x75, 0xbd, 0x6a, 0x91, 0x7c, 0xcd, 0x92, 0x4b, 0xe8, 0x99, 0xdc, 0x87,
	0x56, 0x51, 0x0b, 0xc1, 0x7a, 0x55, 0xe9, 0x13, 0x72, 0x68, 0xc0, 0xcc, 0xaf, 0x0c, 0xa8, 0x1f,
	0x88, 0x71, 0xf2, 0x82, 0x4e, 0xae, 0x15, 0xf7, 0x29, 0x2c, 0x88, 0x84, 0x7b, 0xca, 0x7f, 0x6b,
	0x6b, 0x75, 0x43, 0xb1, 0xb3, 0xa1, 0xed, 0x37, 0x06, 0xb8, 0xb8, 0xe7, 0x27, 0x51, 0x66, 0x29,
	0x43, 0xac, 0x87, 0x23, 0x53, 0xbc, 0x08, 0xd6, 0x70, 0x74, 0xce, 0xa4, 0x0f, 0x2d, 0x11, 0xdb,
	0x71, 0xe0, 0x32, 0x3b, 0x48, 0x93, 0xde, 0xfc, 0x9a, 0xb1, 0xde, 0xb0, 0x9a, 0x22, 0x1e, 0x06,
	0x2e, 0xfb, 0x6b, 0x9a, 0xe0, 0xe6, 0x90, 0x66, 0xf6, 0x94, 0xba, 0x29, 0xef, 0x2d, 0xa8, 0xcd,
	0x21, 0xcd, 0xfe, 0x8e, 0xf3, 0xd5, 0x67, 0x00, 0x17, 0xe1, 0x90, 0x89, 0x13, 0x9e, 0x97, 0x08,
	0x87, 0xc8, 0x98, 0xda, 0xa8, 0x3a, 0x41, 0x4d, 0xfe, 0x5c, 0x79, 0x66, 0x98, 0x6f, 0x2b, 0x40,
	0x0e, 0x85, 0x27, 0x12, 0xce, 0x5e, 0x09, 0x8f, 0x1f, 0x51, 0xe7, 0x84, 0x4e, 0xb8, 0x4e, 0xb6,
	0x52, 0x24, 0x5b, 0x50, 0x5e, 0x9d, 0x41, 0xf9, 0xfc, 0x05, 0xe5, 0x0f, 0xa1, 0xeb, 0x51, 0xe1,
	0xdb, 0x8e, 0x2c, 0xa9, 0x13, 0xf8, 0xf2, 0x53, 0x9b, 0x56, 0x1b, 0xd1, 0x1d, 0x2c, 0xaa, 0x13,
	0xf8, 0xe4, 0x16, 0xd4, 0x46, 0xd4, 0xf7, 0x79, 0x24, 0x3b, 0xa8, 0x69, 0xe9, 0x19, 0xf6, 0xab,
	0x4f, 0x3d, 0xae, 0x7b, 0x48, 0x8e, 0x91, 0xd5, 0x99, 0x6d, 0xda, 0x50, 0xac, 0xb2, 0xeb, 0xed,
	0xf9, 0x00, 0xe6, 0x47, 0x74, 0x12, 0xf7, 0x9a, 0x92, 0x97, 0xc5, 0x2b, 0xbc, 0x58, 0x72, 0x91,
	0xdc, 0x81, 0x46, 0xc4, 0xa9, 0x6b, 0xe3, 0xf7, 0x83, 0x0c, 0x57, 0xc7, 0xf9, 0x9e, 0xcf, 0xcc,
	0xe7, 0x70, 0xe3, 0x90, 0x4f, 0xb9, 0x7b, 0x10, 0x05, 0x6f, 0x92, 0xe3, 0xfd, 0xd4, 0x67, 0x58,
	0x5b, 0xfc, 0xb8, 0x71, 0xc4, 0xb9, 0x2c, 0x6b, 0xc3, 0x92, 0x63, 0xc4, 0x42, 0xaa, 0x0b, 0xd5,
	0xb0, 0xe4, 0xd8, 0xfc, 0xcc, 0x00, 0x72, 0x65, 0xff, 0xce, 0xf8, 0x7a, 0xfb, 0xdc, 0x86, 0x7a,
	0x92, 0x85, 0x32, 0x15, 0x55, 0xe6, 0x1a, 0x4e, 0xd5, 0xe9, 0x72, 0x71, 0x7b, 0x5e, 0x6a, 0x39,
	0x21, 0xbf, 0x83, 0xc5, 0xa2, 0x55, 0x55, 0x73, 0xcb, 0x83, 0x5a, 0xb5, 0xba, 0x39, 0xac, 0xfa,
	0x9a, 0x6c, 0xc0, 0x8d, 0xc2, 0x10, 0x1b, 0x46, 0x1b, 0x2f, 0x48, 0xe3, 0xe5, 0x7c, 0xe9, 0x88,
	0x6a, 0x7b, 0xf3, 0x73, 0x03, 0x5a, 0xfb, 0x22, 0x8a, 0x93, 0x23, 0x9a, 0x7d, 0xd2, 0x77, 0x3e,
	0x82, 0x45, 0x6c, 0x6b, 0x3b, 0x14, 0x4e, 0x92, 0x46, 0x45, 0x4f, 0x37, 0xad, 0x0e, 0xc2, 0x47,
	0x0a, 0x1d, 0x30, 0xb2, 0x0e, 0x4b, 0x71, 0xc8, 0x1d, 0x41, 0x5d, 0x7b, 0x2c, 0xb8, 0xcb, 0x94,
	0xc6, 0xa0, 0x61, 0x57, 0xe3, 0xfb, 0x08, 0x0f, 0x18, 0xb6, 0x13, 0x1e, 0x6d, 0xd5, 0xdc, 0x38,
	0x9c, 0x95, 0x75, 0x6d, 0x56, 0xd6, 0xa6, 0x0f, 0xdd, 0x6d, 0xc7, 0xb1, 0xb8, 0x3a, 0x4e, 0xb3,
	0xf2, 0x78, 0x00, 0x1d, 0xc6, 0x3d, 0xea, 0x33, 0x9b, 0x7a, 0x41, 0xea, 0xe7, 0xa2, 0xd8, 0x56,
	0xe0, 0xb6, 0xc4, 0x30, 0x5e, 0xa4, 0x7d, 0xe4, 0xf1, 0xaa, 0x2a, 0x5e, 0x0e, 0xeb, 0x78, 0xdf,
	0x1a, 0xd0, 0xde, 0xa5, 0xc2, 0xcd, 0x86, 0xd4, 0x9d, 0x19, 0xee, 0x0e, 0x34, 0x46, 0x69, 0x66,
	0x63, 0xad, 0x74, 0xa4, 0xfa, 0x28, 0xcd, 0x5e, 0x65, 0x21, 0x27, 0x37, 0xa1, 0x86, 0xc4, 0x88,
	0xdc, 0xf7, 0x42, 0x48, 0xb3, 0x01, 0xfb, 0xf9, 0x0c, 0xcf, 0x28, 0xfc, 0xc2, 0xac, 0xc2, 0xdf,
	0x86, 0x3a, 0xc6, 0xf1, 0x53, 0x4f, 0x0b, 0x35, 0x86, 0x7d, 0x99, 0x7a, 0xc8, 0x48, 0x11, 0x69,
	0x12, 0x09, 0xc9, 0x88, 0x3a, 0x72, 0x45, 0xa8, 0x83, 0x48, 0xb0, 0x01, 0x33, 0xbf, 0x33, 0xa0,
	0xf3, 0x0f, 0xce, 0x4f, 0x7e, 0xed, 0x79, 0xfe, 0x58, 0x81, 0xe5, 0x61, 0xc2, 0x5d, 0x17, 0x29,
	0xf6, 0x86, 0xc7, 0x41, 0x38, 0x2b, 0xd7, 0x47, 0xb0, 0x18, 0x2b, 0x23, 0x7b, 0xc2, 0x3d, 0x19,
	0x50, 0xdd, 0x2d, 0x1d, 0x0d, 0x1f, 0x70, 0x0f, 0xe3, 0x3e, 0x84, 0x6e, 0x1c, 0xa4, 0x91, 0xc3,
	0x0b, 0x33, 0x55, 0x80, 0xb6, 0x42, 0xb5, 0x95, 0x09, 0x1d, 0x7e, 0x9a, 0x44, 0xb4, 0x30, 0x52,
	0x55, 0x68, 0x49, 0x50, 0xdb, 0x3c, 0x80, 0xce, 0x44, 0x8c, 0x93, 0x42, 0xf8, 0xf4, 0xd9, 0x68,
	0x23, 0x98, 0x2b, 0x1e, 0x79, 0x0c, 0xcb, 0x48, 0xc1, 0x65, 0x43, 0x55, 0x89, 0xc5, 0x51, 0x9a,
	0x1d, 0x94, 0x6d, 0xff, 0x00, 0x37, 0xcb, 0x29, 0xa0, 0x42, 0xdb, 0x85, 0xe4, 0x36, 0x2d, 0x72,
	0x91, 0x08, 0x0a, 0xf5, 0x4b, 0x14, 0xe0, 0xdf, 0x42, 0x37, 0x4c, 0x23, 0xe7, 0x98, 0xc6, 0xdc,
	0x0e, 0x23, 0xe1, 0xf0, 0x5e, 0x43, 0xfa, 0xee, 0xe4, 0xe8, 0x11, 0x82, 0x28, 0x85, 0x89, 0x52,
	0x5d, 0x74, 0x24, 0xc7, 0x78, 0x67, 0xc9, 0xaf, 0x92, 0x0b, 0x20, 0x17, 0x1a, 0x08, 0xbc, 0xa2,
	0x93, 0xd8, 0xfc, 0x6f, 0x15, 0xda, 0x47, 0x34, 0x8e, 0x79, 0xac, 0xf9, 0xbe, 0x5a, 0xee, 0x2e,
	0x54, 0xdc, 0x69, 0x7e, 0x07, 0xb9, 0x53, 0xbc, 0xad, 0xf5, 0xb5, 0x2e, 0xbb, 0x4d, 0xdf, 0xd6,
	0x0a, 0x92, 0x0d, 0xb7, 0x07, 0x2d, 0x54, 0xe5, 0x72, 0x57, 0xb5, 0xb6, 0x1e, 0xe6, 0xfa, 0x5f,
	0x8e, 0xb5, 0xb1, 0x1f, 0x71, 0x7d, 0x94, 0xd5, 0x0d, 0x0d, 0xe3, 0x02, 0x40, 0x37, 0x28, 0xe4,
	0x65, 0xe5, 0xfc, 0x98, 0x9b, 0x23, 0x2a, 0xd8, 0x25, 0x37, 0x61, 0x01, 0x90, 0xdf, 0x40, 0x3b,
	0xe2, 0xff, 0x4a, 0x45, 0xc4, 0x99, 0xcd, 0x4f, 0x43, 0xcd, 0x48, 0x2b, 0xc7, 0xf6, 0x4e, 0x43,
	0x3c, 0x3c, 0xee, 0xd4, 0x8e, 0xa8, 0x3f, 0x41, 0x02, 0x90, 0xfd, 0xba, 0x3b, 0xb5, 0x70, 0xba,
	0xfa, 0x1c, 0x16, 0xaf, 0x7c, 0xe3, 0xa7, 0x5c, 0xeb, 0xb8, 0xfd, 0xca, 0xb7, 0x7d, 0xd2, 0xab,
	0xe0, 0xff, 0x55, 0x00, 0x95, 0xe8, 0x2e, 0x4d, 0xe8, 0x35, 0x26, 0xf0, 0xde, 0x3f, 0x0d, 0x35,
	0x03, 0x38, 0x24, 0xbf, 0x87, 0x5a, 0x9c, 0xd0, 0x24, 0x8d, 0xa5, 0xb4, 0x77, 0xb7, 0x56, 0x2e,
	0x97, 0x6b, 0x28, 0xd7, 0x2c, 0x6d, 0x43, 0x76, 0x34, 0x51, 0xa9, 0xef, 0x06, 0xce, 0x89, 0xae,
	0xb0, 0x79, 0x79, 0x0b, 0x06, 0x96, 0x34, 0xfd, 0x4d, 0x1a, 0x95, 0x68, 0x52, 0x00, 0x3a, 0x91,
	0x34, 0x69, 0x27, 0xb5, 0x8f, 0x3a, 0xc1, 0x42, 0x5c, 0x72, 0x12, 0x16, 0x80, 0x7a, 0x06, 0xc4,
	0x3c, 0xb1, 0x69, 0xa2, 0xa5, 0xa1, 0x2e, 0xe7, 0xdb, 0xc9, 0xea, 0x50, 0x31, 0x50, 0xda, 0x39,
	0xa3, 0x84, 0x8f, 0xcb, 0x25, 0x2c, 0xa5, 0xad, 0x0a, 0xaf, 0xd3, 0x2e, 0xf1, 0x32, 0x54, 0xbc,
	0xfc, 0xa2, 0x4e, 0xcd, 0xff, 0x18, 0x50, 0x53, 0xf9, 0x92, 0x47, 0x30, 0xcf, 0x68, 0x42, 0xa5,
	0xb7, 0xd6, 0x16, 0xb9, 0x5e, 0x0d, 0x4b, 0xae, 0x93, 0x3f, 0x15, 0x67, 0xc9, 0x19, 0x4f, 0xf2,
	0x27, 0xec, 0xca, 0xac, 0x1e, 0xcf, 0x4f, 0xd8, 0xce, 0x78, 0x12, 0xa3, 0x1e, 0x51, 0x36, 0xa5,
	0xbe, 0x93, 0x4b, 0x81, 0x6a, 0x81, 0xb6, 0x06, 0xa5, 0x12, 0x98, 0x6b, 0x50, 0x7f, 0xcd, 0xa3,
	0xe0, 0x45, 0x9a, 0xe1, 0x15, 0x80, 0xd2, 0x44, 0x93, 0x9e, 0xa1, 0xae, 0x80, 0x51, 0x9a, 0x6d,
	0x27, 0xe6, 0x97, 0x06, 0x80, 0x36, 0x99, 0xa5, 0xb3, 0x57, 0x9e, 0xe5, 0x95, 0xab, 0xcf, 0xf2,
	0xfc, 0xa1, 0x50, 0xbd, 0x78, 0x28, 0x3c, 0x01, 0xa2, 0xf3, 0x11, 0x9e, 0xc7, 0x99, 0xa0, 0x09,
	0x77, 0x33, 0xad, 0xa8, 0xcb, 0x6a, 0x65, 0x70, 0xb1, 0x50, 0x96, 0x92, 0xc0, 0x0b, 0xf4, 0xe3,
	0x28, 0x97, 0x92, 0xc0, 0x0b, 0xe4, 0x53, 0x3d, 0x88, 0x13, 0x1b, 0x6f, 0x1a, 0xfd, 0xe4, 0x68,
	0x20, 0x20, 0x5f, 0x82, 0xf7, 0x00, 0x4a, 0x77, 0x52, 0x5d, 0xfe, 0xbc, 0x34, 0xc3, 0xfc, 0x3e,
	0x7a, 0xfc, 0xcf, 0x5c, 0xd7, 0x14, 0x53, 0xe4, 0x16, 0x90, 0xf2, 0xfc, 0x30, 0x70, 0x4e, 0x38,
	0x5b, 0x9a, 0x23, 0xb7, 0xe1, 0x46, 0x19, 0x3f, 0xe0, 0x3e, 0x8f, 0xa8, 0xbb, 0x64, 0x90, 0x1e,
	0xac, 0x94, 0x17, 0xb6, 0x55, 0x71, 0xd9, 0x52, 0xe5, 0xc5, 0x5f, 0x3e, 0x7c, 0xd3, 0x9f, 0xfb,
	0xdf, 0x59, 0xdf, 0x78, 0x77, 0xd6, 0x37, 0xde, 0x9f, 0xf5, 0x8d, 0xaf, 0xcf, 0xfa, 0xc6, 0xf7,
	0x67, 0xfd, 0xb9, 0x1f, 0xce, 0xfa, 0xc6, 0xdb, 0xf3, 0xfe, 0xdc, 0xbb, 0xf3, 0xbe, 0xf1, 0xfe,
	0xbc, 0x3f, 0xf7, 0xe1, 0xbc, 0x3f, 0xf7, 0xfa, 0xbe, 0x13, 0x08, 0xff, 0x49, 0xcc, 0xa3, 0x29,
	0x8f, 0x36, 0x9d, 0xc0, 0xf3, 0x02, 0x7f, 0xb3, 0xfc, 0x23, 0x39, 0xaa, 0xc9, 0xd9, 0x1f, 0x7f,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x0e, 0x75, 0x46, 0x84, 0x0e, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolActivity.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolSevenDaysInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolGiftBag.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolLimitedTimePackage.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolLevelGrowthFundItem.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolLevelGrowthFundCfg.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolFirstPayCfg.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolAccRechargeCfg.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolDailySaleCfg.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolWeeklySaleCfg.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolStellargemShopCfg.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPassesReward.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPassesData.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolPasses.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolZeroBuy.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolZeroBuyCfg.Get().(proto.Message)
	})
}

var poolActivity = &sync.Pool{New: func() interface{} { return &Activity{} }}

func (m *Activity) ReleasePool() { m.Reset(); poolActivity.Put(m); m = nil }

var poolSevenDaysInfo = &sync.Pool{New: func() interface{} { return &SevenDaysInfo{} }}

func (m *SevenDaysInfo) ReleasePool() { m.Reset(); poolSevenDaysInfo.Put(m); m = nil }

var poolGiftBag = &sync.Pool{New: func() interface{} { return &GiftBag{} }}

func (m *GiftBag) ReleasePool() { m.Reset(); poolGiftBag.Put(m); m = nil }

var poolLimitedTimePackage = &sync.Pool{New: func() interface{} { return &LimitedTimePackage{} }}

func (m *LimitedTimePackage) ReleasePool() { m.Reset(); poolLimitedTimePackage.Put(m); m = nil }

var poolLevelGrowthFundItem = &sync.Pool{New: func() interface{} { return &LevelGrowthFundItem{} }}

func (m *LevelGrowthFundItem) ReleasePool() { m.Reset(); poolLevelGrowthFundItem.Put(m); m = nil }

var poolLevelGrowthFundCfg = &sync.Pool{New: func() interface{} { return &LevelGrowthFundCfg{} }}

func (m *LevelGrowthFundCfg) ReleasePool() { m.Reset(); poolLevelGrowthFundCfg.Put(m); m = nil }

var poolFirstPayCfg = &sync.Pool{New: func() interface{} { return &FirstPayCfg{} }}

func (m *FirstPayCfg) ReleasePool() { m.Reset(); poolFirstPayCfg.Put(m); m = nil }

var poolAccRechargeCfg = &sync.Pool{New: func() interface{} { return &AccRechargeCfg{} }}

func (m *AccRechargeCfg) ReleasePool() { m.Reset(); poolAccRechargeCfg.Put(m); m = nil }

var poolDailySaleCfg = &sync.Pool{New: func() interface{} { return &DailySaleCfg{} }}

func (m *DailySaleCfg) ReleasePool() { m.Reset(); poolDailySaleCfg.Put(m); m = nil }

var poolWeeklySaleCfg = &sync.Pool{New: func() interface{} { return &WeeklySaleCfg{} }}

func (m *WeeklySaleCfg) ReleasePool() { m.Reset(); poolWeeklySaleCfg.Put(m); m = nil }

var poolStellargemShopCfg = &sync.Pool{New: func() interface{} { return &StellargemShopCfg{} }}

func (m *StellargemShopCfg) ReleasePool() { m.Reset(); poolStellargemShopCfg.Put(m); m = nil }

var poolPassesReward = &sync.Pool{New: func() interface{} { return &PassesReward{} }}

func (m *PassesReward) ReleasePool() { m.Reset(); poolPassesReward.Put(m); m = nil }

var poolPassesData = &sync.Pool{New: func() interface{} { return &PassesData{} }}

func (m *PassesData) ReleasePool() { m.Reset(); poolPassesData.Put(m); m = nil }

var poolPasses = &sync.Pool{New: func() interface{} { return &Passes{} }}

func (m *Passes) ReleasePool() { m.Reset(); poolPasses.Put(m); m = nil }

var poolZeroBuy = &sync.Pool{New: func() interface{} { return &ZeroBuy{} }}

func (m *ZeroBuy) ReleasePool() { m.Reset(); poolZeroBuy.Put(m); m = nil }

var poolZeroBuyCfg = &sync.Pool{New: func() interface{} { return &ZeroBuyCfg{} }}

func (m *ZeroBuyCfg) ReleasePool() { m.Reset(); poolZeroBuyCfg.Put(m); m = nil }
func (x PassesStatus) String() string {
	s, ok := PassesStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Activity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Activity)
	if !ok {
		that2, ok := that.(Activity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if len(this.ActivityDescribeLanguageId) != len(that1.ActivityDescribeLanguageId) {
		return false
	}
	for i := range this.ActivityDescribeLanguageId {
		if this.ActivityDescribeLanguageId[i] != that1.ActivityDescribeLanguageId[i] {
			return false
		}
	}
	if this.Begin != that1.Begin {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if this.SystemId != that1.SystemId {
		return false
	}
	if len(this.ChargeId) != len(that1.ChargeId) {
		return false
	}
	for i := range this.ChargeId {
		if this.ChargeId[i] != that1.ChargeId[i] {
			return false
		}
	}
	return true
}
func (this *SevenDaysInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SevenDaysInfo)
	if !ok {
		that2, ok := that.(SevenDaysInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SignedInDay != that1.SignedInDay {
		return false
	}
	if len(this.ReceivedRewardDays) != len(that1.ReceivedRewardDays) {
		return false
	}
	for i := range this.ReceivedRewardDays {
		if this.ReceivedRewardDays[i] != that1.ReceivedRewardDays[i] {
			return false
		}
	}
	if this.ActivityId != that1.ActivityId {
		return false
	}
	return true
}
func (this *GiftBag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GiftBag)
	if !ok {
		that2, ok := that.(GiftBag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if this.Items[i] != that1.Items[i] {
			return false
		}
	}
	if this.ChargeId != that1.ChargeId {
		return false
	}
	if this.IsSoldOut != that1.IsSoldOut {
		return false
	}
	if this.PayValue != that1.PayValue {
		return false
	}
	return true
}
func (this *LimitedTimePackage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LimitedTimePackage)
	if !ok {
		that2, ok := that.(LimitedTimePackage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Begin != that1.Begin {
		return false
	}
	if this.End != that1.End {
		return false
	}
	if this.MainCityIcon != that1.MainCityIcon {
		return false
	}
	if this.Banner != that1.Banner {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.DescribeLanguageId) != len(that1.DescribeLanguageId) {
		return false
	}
	for i := range this.DescribeLanguageId {
		if this.DescribeLanguageId[i] != that1.DescribeLanguageId[i] {
			return false
		}
	}
	if len(this.Bags) != len(that1.Bags) {
		return false
	}
	for i := range this.Bags {
		if !this.Bags[i].Equal(that1.Bags[i]) {
			return false
		}
	}
	if this.RealEnd != that1.RealEnd {
		return false
	}
	return true
}
func (this *LevelGrowthFundItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LevelGrowthFundItem)
	if !ok {
		that2, ok := that.(LevelGrowthFundItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Free != that1.Free {
		return false
	}
	if this.Paid != that1.Paid {
		return false
	}
	return true
}
func (this *LevelGrowthFundCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LevelGrowthFundCfg)
	if !ok {
		that2, ok := that.(LevelGrowthFundCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.TypeId != that1.TypeId {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if len(this.ActivityReward) != len(that1.ActivityReward) {
		return false
	}
	for i := range this.ActivityReward {
		if this.ActivityReward[i] != that1.ActivityReward[i] {
			return false
		}
	}
	if len(this.ActivityPayReward) != len(that1.ActivityPayReward) {
		return false
	}
	for i := range this.ActivityPayReward {
		if this.ActivityPayReward[i] != that1.ActivityPayReward[i] {
			return false
		}
	}
	return true
}
func (this *FirstPayCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FirstPayCfg)
	if !ok {
		that2, ok := that.(FirstPayCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.TypeId != that1.TypeId {
		return false
	}
	if this.ItemPictureId != that1.ItemPictureId {
		return false
	}
	if this.SpecialFieldId != that1.SpecialFieldId {
		return false
	}
	if this.Day != that1.Day {
		return false
	}
	if len(this.ActivityReward) != len(that1.ActivityReward) {
		return false
	}
	for i := range this.ActivityReward {
		if this.ActivityReward[i] != that1.ActivityReward[i] {
			return false
		}
	}
	return true
}
func (this *AccRechargeCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccRechargeCfg)
	if !ok {
		that2, ok := that.(AccRechargeCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DemandAmount != that1.DemandAmount {
		return false
	}
	if len(this.RechargeReward) != len(that1.RechargeReward) {
		return false
	}
	for i := range this.RechargeReward {
		if this.RechargeReward[i] != that1.RechargeReward[i] {
			return false
		}
	}
	return true
}
func (this *DailySaleCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DailySaleCfg)
	if !ok {
		that2, ok := that.(DailySaleCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.BuyType != that1.BuyType {
		return false
	}
	if len(this.PayId) != len(that1.PayId) {
		return false
	}
	for i := range this.PayId {
		if this.PayId[i] != that1.PayId[i] {
			return false
		}
	}
	if len(this.ActivityReward) != len(that1.ActivityReward) {
		return false
	}
	for i := range this.ActivityReward {
		if this.ActivityReward[i] != that1.ActivityReward[i] {
			return false
		}
	}
	if this.ItemPictureId != that1.ItemPictureId {
		return false
	}
	if this.PayNum != that1.PayNum {
		return false
	}
	if this.ActivityGridId != that1.ActivityGridId {
		return false
	}
	return true
}
func (this *WeeklySaleCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WeeklySaleCfg)
	if !ok {
		that2, ok := that.(WeeklySaleCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.BuyType != that1.BuyType {
		return false
	}
	if len(this.PayId) != len(that1.PayId) {
		return false
	}
	for i := range this.PayId {
		if this.PayId[i] != that1.PayId[i] {
			return false
		}
	}
	if len(this.ActivityReward) != len(that1.ActivityReward) {
		return false
	}
	for i := range this.ActivityReward {
		if this.ActivityReward[i] != that1.ActivityReward[i] {
			return false
		}
	}
	if this.ItemPictureId != that1.ItemPictureId {
		return false
	}
	if this.PayNum != that1.PayNum {
		return false
	}
	if this.ActivityGridId != that1.ActivityGridId {
		return false
	}
	return true
}
func (this *StellargemShopCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StellargemShopCfg)
	if !ok {
		that2, ok := that.(StellargemShopCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.StellarGemNum) != len(that1.StellarGemNum) {
		return false
	}
	for i := range this.StellarGemNum {
		if this.StellarGemNum[i] != that1.StellarGemNum[i] {
			return false
		}
	}
	if len(this.SourceGemNum) != len(that1.SourceGemNum) {
		return false
	}
	for i := range this.SourceGemNum {
		if this.SourceGemNum[i] != that1.SourceGemNum[i] {
			return false
		}
	}
	if len(this.ExtraGemNum) != len(that1.ExtraGemNum) {
		return false
	}
	for i := range this.ExtraGemNum {
		if this.ExtraGemNum[i] != that1.ExtraGemNum[i] {
			return false
		}
	}
	if this.GiftLanguage != that1.GiftLanguage {
		return false
	}
	if this.BuyGiftLanguage != that1.BuyGiftLanguage {
		return false
	}
	if this.StellarGemIconName != that1.StellarGemIconName {
		return false
	}
	if this.PurchasePrice != that1.PurchasePrice {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	if this.GiftTags != that1.GiftTags {
		return false
	}
	return true
}
func (this *PassesReward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PassesReward)
	if !ok {
		that2, ok := that.(PassesReward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Lv != that1.Lv {
		return false
	}
	if this.RewardType != that1.RewardType {
		return false
	}
	if len(this.FreeReward) != len(that1.FreeReward) {
		return false
	}
	for i := range this.FreeReward {
		if this.FreeReward[i] != that1.FreeReward[i] {
			return false
		}
	}
	if len(this.PaidReward) != len(that1.PaidReward) {
		return false
	}
	for i := range this.PaidReward {
		if this.PaidReward[i] != that1.PaidReward[i] {
			return false
		}
	}
	if this.RequiredExp != that1.RequiredExp {
		return false
	}
	if len(this.LvRange) != len(that1.LvRange) {
		return false
	}
	for i := range this.LvRange {
		if this.LvRange[i] != that1.LvRange[i] {
			return false
		}
	}
	return true
}
func (this *PassesData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PassesData)
	if !ok {
		that2, ok := that.(PassesData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lv != that1.Lv {
		return false
	}
	if this.Exp != that1.Exp {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.FreeUnlock) != len(that1.FreeUnlock) {
		return false
	}
	for i := range this.FreeUnlock {
		if this.FreeUnlock[i] != that1.FreeUnlock[i] {
			return false
		}
	}
	if len(this.PaidUnlock) != len(that1.PaidUnlock) {
		return false
	}
	for i := range this.PaidUnlock {
		if this.PaidUnlock[i] != that1.PaidUnlock[i] {
			return false
		}
	}
	if this.ResetAt != that1.ResetAt {
		return false
	}
	return true
}
func (this *Passes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passes)
	if !ok {
		that2, ok := that.(Passes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if len(this.RewardCfgs) != len(that1.RewardCfgs) {
		return false
	}
	for i := range this.RewardCfgs {
		if !this.RewardCfgs[i].Equal(that1.RewardCfgs[i]) {
			return false
		}
	}
	if this.AdvancePrice != that1.AdvancePrice {
		return false
	}
	return true
}
func (this *ZeroBuy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ZeroBuy)
	if !ok {
		that2, ok := that.(ZeroBuy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.BuyAt) != len(that1.BuyAt) {
		return false
	}
	for i := range this.BuyAt {
		if this.BuyAt[i] != that1.BuyAt[i] {
			return false
		}
	}
	return true
}
func (this *ZeroBuyCfg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ZeroBuyCfg)
	if !ok {
		that2, ok := that.(ZeroBuyCfg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ActivityId != that1.ActivityId {
		return false
	}
	if this.Day != that1.Day {
		return false
	}
	if len(this.RewardImmediately) != len(that1.RewardImmediately) {
		return false
	}
	for i := range this.RewardImmediately {
		if this.RewardImmediately[i] != that1.RewardImmediately[i] {
			return false
		}
	}
	if len(this.RewardTomo) != len(that1.RewardTomo) {
		return false
	}
	for i := range this.RewardTomo {
		if this.RewardTomo[i] != that1.RewardTomo[i] {
			return false
		}
	}
	if len(this.CostItem) != len(that1.CostItem) {
		return false
	}
	for i := range this.CostItem {
		if this.CostItem[i] != that1.CostItem[i] {
			return false
		}
	}
	if len(this.PictureId) != len(that1.PictureId) {
		return false
	}
	for i := range this.PictureId {
		if this.PictureId[i] != that1.PictureId[i] {
			return false
		}
	}
	return true
}
func (m *Activity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Activity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Activity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChargeId) > 0 {
		for iNdEx := len(m.ChargeId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChargeId[iNdEx])
			copy(dAtA[i:], m.ChargeId[iNdEx])
			i = encodeVarintActivity(dAtA, i, uint64(len(m.ChargeId[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.SystemId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.SystemId))
		i--
		dAtA[i] = 0x48
	}
	if m.End != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x38
	}
	if m.Begin != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ActivityDescribeLanguageId) > 0 {
		for iNdEx := len(m.ActivityDescribeLanguageId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ActivityDescribeLanguageId[iNdEx])
			copy(dAtA[i:], m.ActivityDescribeLanguageId[iNdEx])
			i = encodeVarintActivity(dAtA, i, uint64(len(m.ActivityDescribeLanguageId[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Sort != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SevenDaysInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SevenDaysInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SevenDaysInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivityId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReceivedRewardDays) > 0 {
		dAtA2 := make([]byte, len(m.ReceivedRewardDays)*10)
		var j1 int
		for _, num1 := range m.ReceivedRewardDays {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintActivity(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if m.SignedInDay != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.SignedInDay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GiftBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GiftBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayValue != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.PayValue))
		i--
		dAtA[i] = 0x28
	}
	if m.IsSoldOut {
		i--
		if m.IsSoldOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ChargeId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.ChargeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			i = encodeVarintActivity(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintActivity(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintActivity(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimitedTimePackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimitedTimePackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimitedTimePackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RealEnd != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.RealEnd))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Bags) > 0 {
		for iNdEx := len(m.Bags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Bags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintActivity(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.DescribeLanguageId) > 0 {
		dAtA4 := make([]byte, len(m.DescribeLanguageId)*10)
		var j3 int
		for _, num1 := range m.DescribeLanguageId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintActivity(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x42
	}
	if m.Name != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Name))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Banner) > 0 {
		i -= len(m.Banner)
		copy(dAtA[i:], m.Banner)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.Banner)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MainCityIcon) > 0 {
		i -= len(m.MainCityIcon)
		copy(dAtA[i:], m.MainCityIcon)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.MainCityIcon)))
		i--
		dAtA[i] = 0x2a
	}
	if m.End != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Begin != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *LevelGrowthFundItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelGrowthFundItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LevelGrowthFundItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Paid {
		i--
		if m.Paid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Free {
		i--
		if m.Free {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LevelGrowthFundCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelGrowthFundCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LevelGrowthFundCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActivityPayReward) > 0 {
		dAtA6 := make([]byte, len(m.ActivityPayReward)*10)
		var j5 int
		for _, num1 := range m.ActivityPayReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintActivity(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActivityReward) > 0 {
		dAtA8 := make([]byte, len(m.ActivityReward)*10)
		var j7 int
		for _, num1 := range m.ActivityReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintActivity(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.TypeId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.TypeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FirstPayCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirstPayCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirstPayCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActivityReward) > 0 {
		dAtA10 := make([]byte, len(m.ActivityReward)*10)
		var j9 int
		for _, num1 := range m.ActivityReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintActivity(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x32
	}
	if m.Day != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Day))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SpecialFieldId) > 0 {
		i -= len(m.SpecialFieldId)
		copy(dAtA[i:], m.SpecialFieldId)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.SpecialFieldId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ItemPictureId) > 0 {
		i -= len(m.ItemPictureId)
		copy(dAtA[i:], m.ItemPictureId)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.ItemPictureId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TypeId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.TypeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccRechargeCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccRechargeCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccRechargeCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RechargeReward) > 0 {
		dAtA12 := make([]byte, len(m.RechargeReward)*10)
		var j11 int
		for _, num1 := range m.RechargeReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintActivity(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if m.DemandAmount != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.DemandAmount))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DailySaleCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailySaleCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DailySaleCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivityGridId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityGridId))
		i--
		dAtA[i] = 0x38
	}
	if m.PayNum != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.PayNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ItemPictureId) > 0 {
		i -= len(m.ItemPictureId)
		copy(dAtA[i:], m.ItemPictureId)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.ItemPictureId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActivityReward) > 0 {
		dAtA14 := make([]byte, len(m.ActivityReward)*10)
		var j13 int
		for _, num1 := range m.ActivityReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintActivity(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PayId) > 0 {
		dAtA16 := make([]byte, len(m.PayId)*10)
		var j15 int
		for _, num1 := range m.PayId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintActivity(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x1a
	}
	if m.BuyType != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.BuyType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WeeklySaleCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeeklySaleCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WeeklySaleCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivityGridId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityGridId))
		i--
		dAtA[i] = 0x38
	}
	if m.PayNum != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.PayNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ItemPictureId) > 0 {
		i -= len(m.ItemPictureId)
		copy(dAtA[i:], m.ItemPictureId)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.ItemPictureId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActivityReward) > 0 {
		dAtA18 := make([]byte, len(m.ActivityReward)*10)
		var j17 int
		for _, num1 := range m.ActivityReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintActivity(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PayId) > 0 {
		dAtA20 := make([]byte, len(m.PayId)*10)
		var j19 int
		for _, num1 := range m.PayId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintActivity(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1a
	}
	if m.BuyType != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.BuyType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StellargemShopCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StellargemShopCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StellargemShopCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GiftTags) > 0 {
		i -= len(m.GiftTags)
		copy(dAtA[i:], m.GiftTags)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.GiftTags)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PurchasePrice != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.PurchasePrice))
		i--
		dAtA[i] = 0x40
	}
	if len(m.StellarGemIconName) > 0 {
		i -= len(m.StellarGemIconName)
		copy(dAtA[i:], m.StellarGemIconName)
		i = encodeVarintActivity(dAtA, i, uint64(len(m.StellarGemIconName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.BuyGiftLanguage != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.BuyGiftLanguage))
		i--
		dAtA[i] = 0x30
	}
	if m.GiftLanguage != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.GiftLanguage))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExtraGemNum) > 0 {
		dAtA22 := make([]byte, len(m.ExtraGemNum)*10)
		var j21 int
		for _, num1 := range m.ExtraGemNum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintActivity(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SourceGemNum) > 0 {
		dAtA24 := make([]byte, len(m.SourceGemNum)*10)
		var j23 int
		for _, num1 := range m.SourceGemNum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintActivity(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StellarGemNum) > 0 {
		dAtA26 := make([]byte, len(m.StellarGemNum)*10)
		var j25 int
		for _, num1 := range m.StellarGemNum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintActivity(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PassesReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassesReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PassesReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LvRange) > 0 {
		dAtA28 := make([]byte, len(m.LvRange)*10)
		var j27 int
		for _, num1 := range m.LvRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintActivity(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x3a
	}
	if m.RequiredExp != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.RequiredExp))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PaidReward) > 0 {
		for k := range m.PaidReward {
			v := m.PaidReward[k]
			baseI := i
			i = encodeVarintActivity(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintActivity(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintActivity(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.FreeReward) > 0 {
		for k := range m.FreeReward {
			v := m.FreeReward[k]
			baseI := i
			i = encodeVarintActivity(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintActivity(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintActivity(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.RewardType != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.RewardType))
		i--
		dAtA[i] = 0x18
	}
	if m.Lv != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PassesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassesData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PassesData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetAt != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.ResetAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PaidUnlock) > 0 {
		for k := range m.PaidUnlock {
			v := m.PaidUnlock[k]
			baseI := i
			i = encodeVarintActivity(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintActivity(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintActivity(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.FreeUnlock) > 0 {
		for k := range m.FreeUnlock {
			v := m.FreeUnlock[k]
			baseI := i
			i = encodeVarintActivity(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintActivity(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintActivity(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Status != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Exp != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x18
	}
	if m.Lv != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Passes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Passes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvancePrice != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.AdvancePrice))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RewardCfgs) > 0 {
		for iNdEx := len(m.RewardCfgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardCfgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintActivity(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintActivity(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroBuy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroBuy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BuyAt) > 0 {
		dAtA31 := make([]byte, len(m.BuyAt)*10)
		var j30 int
		for _, num1 := range m.BuyAt {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintActivity(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroBuyCfg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroBuyCfg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroBuyCfg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PictureId) > 0 {
		for iNdEx := len(m.PictureId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PictureId[iNdEx])
			copy(dAtA[i:], m.PictureId[iNdEx])
			i = encodeVarintActivity(dAtA, i, uint64(len(m.PictureId[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CostItem) > 0 {
		dAtA33 := make([]byte, len(m.CostItem)*10)
		var j32 int
		for _, num1 := range m.CostItem {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintActivity(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RewardTomo) > 0 {
		dAtA35 := make([]byte, len(m.RewardTomo)*10)
		var j34 int
		for _, num1 := range m.RewardTomo {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintActivity(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RewardImmediately) > 0 {
		dAtA37 := make([]byte, len(m.RewardImmediately)*10)
		var j36 int
		for _, num1 := range m.RewardImmediately {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintActivity(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x22
	}
	if m.Day != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Day))
		i--
		dAtA[i] = 0x18
	}
	if m.ActivityId != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintActivity(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintActivity(dAtA []byte, offset int, v uint64) int {
	offset -= sovActivity(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *Activity) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Sort != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("sort")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Sort))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activity_describe_language_id")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivityDescribeLanguageId == nil {
		w.RawString("null")
	} else if len(m.ActivityDescribeLanguageId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActivityDescribeLanguageId {
			w.String(v)
			if i != len(m.ActivityDescribeLanguageId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Begin != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("begin")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Begin))
		needWriteComma = true
	}
	if m.End != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("end")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.End))
		needWriteComma = true
	}
	if m.SystemId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("system_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SystemId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("ChargeId")
	w.RawByte('"')
	w.RawByte(':')
	if m.ChargeId == nil {
		w.RawString("null")
	} else if len(m.ChargeId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ChargeId {
			w.String(v)
			if i != len(m.ChargeId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *SevenDaysInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.SignedInDay != 0 {
		w.RawByte('"')
		w.RawString("signed_in_day")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SignedInDay))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("received_reward_days")
	w.RawByte('"')
	w.RawByte(':')
	if m.ReceivedRewardDays == nil {
		w.RawString("null")
	} else if len(m.ReceivedRewardDays) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ReceivedRewardDays {
			w.Int64(int64(v))
			if i != len(m.ReceivedRewardDays)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.ActivityId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("activity_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivityId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *GiftBag) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("items")
	w.RawByte('"')
	w.RawByte(':')
	if m.Items == nil {
		w.RawString("null")
	} else if len(m.Items) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlItems := len(m.Items)
		for k, v := range m.Items {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlItems--
			if mlItems != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.ChargeId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("charge_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ChargeId))
		needWriteComma = true
	}
	if m.IsSoldOut {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_sold_out")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsSoldOut)
		needWriteComma = true
	}
	if m.PayValue != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("pay_value")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PayValue))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *LimitedTimePackage) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Begin != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("begin")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Begin))
		needWriteComma = true
	}
	if m.End != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("end")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.End))
		needWriteComma = true
	}
	if m.MainCityIcon != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("main_city_icon")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.MainCityIcon)
		needWriteComma = true
	}
	if m.Banner != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("banner")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Banner)
		needWriteComma = true
	}
	if m.Name != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("name")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Name))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("describe_language_id")
	w.RawByte('"')
	w.RawByte(':')
	if m.DescribeLanguageId == nil {
		w.RawString("null")
	} else if len(m.DescribeLanguageId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.DescribeLanguageId {
			w.Int64(int64(v))
			if i != len(m.DescribeLanguageId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("bags")
	w.RawByte('"')
	w.RawByte(':')
	if m.Bags == nil {
		w.RawString("null")
	} else if len(m.Bags) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Bags {
			v.JsonBytes(w)
			if i != len(m.Bags)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.RealEnd != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("real_end")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RealEnd))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *LevelGrowthFundItem) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Free {
		w.RawByte('"')
		w.RawString("free")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.Free)
		needWriteComma = true
	}
	if m.Paid {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("paid")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.Paid)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *LevelGrowthFundCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.TypeId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("type_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.TypeId))
		needWriteComma = true
	}
	if m.Level != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Level))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activity_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivityReward == nil {
		w.RawString("null")
	} else if len(m.ActivityReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActivityReward {
			w.Int64(int64(v))
			if i != len(m.ActivityReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activity_pay_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivityPayReward == nil {
		w.RawString("null")
	} else if len(m.ActivityPayReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActivityPayReward {
			w.Int64(int64(v))
			if i != len(m.ActivityPayReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *FirstPayCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.TypeId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("type_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.TypeId))
		needWriteComma = true
	}
	if m.ItemPictureId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("item_picture_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ItemPictureId)
		needWriteComma = true
	}
	if m.SpecialFieldId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("special_field_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.SpecialFieldId)
		needWriteComma = true
	}
	if m.Day != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("day")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Day))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activity_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivityReward == nil {
		w.RawString("null")
	} else if len(m.ActivityReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActivityReward {
			w.Int64(int64(v))
			if i != len(m.ActivityReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *AccRechargeCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.DemandAmount != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("demand_amount")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DemandAmount))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("recharge_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.RechargeReward == nil {
		w.RawString("null")
	} else if len(m.RechargeReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.RechargeReward {
			w.Int64(int64(v))
			if i != len(m.RechargeReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *DailySaleCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.BuyType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("buy_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuyType))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("pay_id")
	w.RawByte('"')
	w.RawByte(':')
	if m.PayId == nil {
		w.RawString("null")
	} else if len(m.PayId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.PayId {
			w.Int64(int64(v))
			if i != len(m.PayId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activity_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivityReward == nil {
		w.RawString("null")
	} else if len(m.ActivityReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActivityReward {
			w.Int64(int64(v))
			if i != len(m.ActivityReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.ItemPictureId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("item_picture_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ItemPictureId)
		needWriteComma = true
	}
	if m.PayNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("pay_num")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PayNum))
		needWriteComma = true
	}
	if m.ActivityGridId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("activity_grid_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivityGridId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *WeeklySaleCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.BuyType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("buy_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuyType))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("pay_id")
	w.RawByte('"')
	w.RawByte(':')
	if m.PayId == nil {
		w.RawString("null")
	} else if len(m.PayId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.PayId {
			w.Int64(int64(v))
			if i != len(m.PayId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activity_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivityReward == nil {
		w.RawString("null")
	} else if len(m.ActivityReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActivityReward {
			w.Int64(int64(v))
			if i != len(m.ActivityReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.ItemPictureId != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("item_picture_id")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.ItemPictureId)
		needWriteComma = true
	}
	if m.PayNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("pay_num")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PayNum))
		needWriteComma = true
	}
	if m.ActivityGridId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("activity_grid_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivityGridId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *StellargemShopCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("stellar_gem_num")
	w.RawByte('"')
	w.RawByte(':')
	if m.StellarGemNum == nil {
		w.RawString("null")
	} else if len(m.StellarGemNum) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.StellarGemNum {
			w.Int64(int64(v))
			if i != len(m.StellarGemNum)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("source_gem_num")
	w.RawByte('"')
	w.RawByte(':')
	if m.SourceGemNum == nil {
		w.RawString("null")
	} else if len(m.SourceGemNum) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.SourceGemNum {
			w.Int64(int64(v))
			if i != len(m.SourceGemNum)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("extra_gem_num")
	w.RawByte('"')
	w.RawByte(':')
	if m.ExtraGemNum == nil {
		w.RawString("null")
	} else if len(m.ExtraGemNum) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ExtraGemNum {
			w.Int64(int64(v))
			if i != len(m.ExtraGemNum)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.GiftLanguage != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("gift_language")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.GiftLanguage))
		needWriteComma = true
	}
	if m.BuyGiftLanguage != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("buy_gift_language")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuyGiftLanguage))
		needWriteComma = true
	}
	if m.StellarGemIconName != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("stellar_gem_icon_name")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.StellarGemIconName)
		needWriteComma = true
	}
	if m.PurchasePrice != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("purchase_price")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PurchasePrice))
		needWriteComma = true
	}
	if m.Tags != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("tags")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Tags)
		needWriteComma = true
	}
	if m.GiftTags != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("gift_tags")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.GiftTags)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *PassesReward) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Lv != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("lv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Lv))
		needWriteComma = true
	}
	if m.RewardType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("reward_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RewardType))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("free_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.FreeReward == nil {
		w.RawString("null")
	} else if len(m.FreeReward) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlFreeReward := len(m.FreeReward)
		for k, v := range m.FreeReward {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlFreeReward--
			if mlFreeReward != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("paid_reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.PaidReward == nil {
		w.RawString("null")
	} else if len(m.PaidReward) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlPaidReward := len(m.PaidReward)
		for k, v := range m.PaidReward {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlPaidReward--
			if mlPaidReward != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.RequiredExp != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("required_exp")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RequiredExp))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("lv_range")
	w.RawByte('"')
	w.RawByte(':')
	if m.LvRange == nil {
		w.RawString("null")
	} else if len(m.LvRange) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.LvRange {
			w.Int64(int64(v))
			if i != len(m.LvRange)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *PassesData) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Lv != 0 {
		w.RawByte('"')
		w.RawString("lv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Lv))
		needWriteComma = true
	}
	if m.Exp != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("exp")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Exp))
		needWriteComma = true
	}
	if m.Status != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("status")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Status))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("free_unlock")
	w.RawByte('"')
	w.RawByte(':')
	if m.FreeUnlock == nil {
		w.RawString("null")
	} else if len(m.FreeUnlock) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlFreeUnlock := len(m.FreeUnlock)
		for k, v := range m.FreeUnlock {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlFreeUnlock--
			if mlFreeUnlock != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("paid_unlock")
	w.RawByte('"')
	w.RawByte(':')
	if m.PaidUnlock == nil {
		w.RawString("null")
	} else if len(m.PaidUnlock) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlPaidUnlock := len(m.PaidUnlock)
		for k, v := range m.PaidUnlock {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlPaidUnlock--
			if mlPaidUnlock != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.ResetAt != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("reset_at")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ResetAt))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Passes) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("data")
	w.RawByte('"')
	w.RawByte(':')
	m.Data.JsonBytes(w)
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("reward_cfgs")
	w.RawByte('"')
	w.RawByte(':')
	if m.RewardCfgs == nil {
		w.RawString("null")
	} else if len(m.RewardCfgs) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.RewardCfgs {
			v.JsonBytes(w)
			if i != len(m.RewardCfgs)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.AdvancePrice != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("advance_price")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AdvancePrice))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *ZeroBuy) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("buy_at")
	w.RawByte('"')
	w.RawByte(':')
	if m.BuyAt == nil {
		w.RawString("null")
	} else if len(m.BuyAt) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.BuyAt {
			w.Int64(int64(v))
			if i != len(m.BuyAt)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *ZeroBuyCfg) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.ActivityId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("activity_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivityId))
		needWriteComma = true
	}
	if m.Day != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("day")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Day))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("reward_immediately")
	w.RawByte('"')
	w.RawByte(':')
	if m.RewardImmediately == nil {
		w.RawString("null")
	} else if len(m.RewardImmediately) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.RewardImmediately {
			w.Int64(int64(v))
			if i != len(m.RewardImmediately)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("reward_tomo")
	w.RawByte('"')
	w.RawByte(':')
	if m.RewardTomo == nil {
		w.RawString("null")
	} else if len(m.RewardTomo) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.RewardTomo {
			w.Int64(int64(v))
			if i != len(m.RewardTomo)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("cost_item")
	w.RawByte('"')
	w.RawByte(':')
	if m.CostItem == nil {
		w.RawString("null")
	} else if len(m.CostItem) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.CostItem {
			w.Int64(int64(v))
			if i != len(m.CostItem)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("picture_id")
	w.RawByte('"')
	w.RawByte(':')
	if m.PictureId == nil {
		w.RawString("null")
	} else if len(m.PictureId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.PictureId {
			w.String(v)
			if i != len(m.PictureId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Activity) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Activity) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Activity) GoString() string {
	return m.String()
}

func (m *SevenDaysInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *SevenDaysInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *SevenDaysInfo) GoString() string {
	return m.String()
}

func (m *GiftBag) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *GiftBag) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *GiftBag) GoString() string {
	return m.String()
}

func (m *LimitedTimePackage) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *LimitedTimePackage) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *LimitedTimePackage) GoString() string {
	return m.String()
}

func (m *LevelGrowthFundItem) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *LevelGrowthFundItem) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *LevelGrowthFundItem) GoString() string {
	return m.String()
}

func (m *LevelGrowthFundCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *LevelGrowthFundCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *LevelGrowthFundCfg) GoString() string {
	return m.String()
}

func (m *FirstPayCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *FirstPayCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *FirstPayCfg) GoString() string {
	return m.String()
}

func (m *AccRechargeCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *AccRechargeCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *AccRechargeCfg) GoString() string {
	return m.String()
}

func (m *DailySaleCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *DailySaleCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *DailySaleCfg) GoString() string {
	return m.String()
}

func (m *WeeklySaleCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *WeeklySaleCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *WeeklySaleCfg) GoString() string {
	return m.String()
}

func (m *StellargemShopCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *StellargemShopCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *StellargemShopCfg) GoString() string {
	return m.String()
}

func (m *PassesReward) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *PassesReward) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *PassesReward) GoString() string {
	return m.String()
}

func (m *PassesData) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *PassesData) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *PassesData) GoString() string {
	return m.String()
}

func (m *Passes) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Passes) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Passes) GoString() string {
	return m.String()
}

func (m *ZeroBuy) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *ZeroBuy) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *ZeroBuy) GoString() string {
	return m.String()
}

func (m *ZeroBuyCfg) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *ZeroBuyCfg) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *ZeroBuyCfg) GoString() string {
	return m.String()
}

func (m *Activity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.Sort != 0 {
		n += 1 + sovActivity(uint64(m.Sort))
	}
	if len(m.ActivityDescribeLanguageId) > 0 {
		for _, s := range m.ActivityDescribeLanguageId {
			l = len(s)
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	if m.Begin != 0 {
		n += 1 + sovActivity(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovActivity(uint64(m.End))
	}
	if m.SystemId != 0 {
		n += 1 + sovActivity(uint64(m.SystemId))
	}
	if len(m.ChargeId) > 0 {
		for _, s := range m.ChargeId {
			l = len(s)
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	return n
}

func (m *SevenDaysInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignedInDay != 0 {
		n += 1 + sovActivity(uint64(m.SignedInDay))
	}
	if len(m.ReceivedRewardDays) > 0 {
		l = 0
		for _, e := range m.ReceivedRewardDays {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if m.ActivityId != 0 {
		n += 1 + sovActivity(uint64(m.ActivityId))
	}
	return n
}

func (m *GiftBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			mapEntrySize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if m.ChargeId != 0 {
		n += 1 + sovActivity(uint64(m.ChargeId))
	}
	if m.IsSoldOut {
		n += 2
	}
	if m.PayValue != 0 {
		n += 1 + sovActivity(uint64(m.PayValue))
	}
	return n
}

func (m *LimitedTimePackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.Begin != 0 {
		n += 1 + sovActivity(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovActivity(uint64(m.End))
	}
	l = len(m.MainCityIcon)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	l = len(m.Banner)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	if m.Name != 0 {
		n += 1 + sovActivity(uint64(m.Name))
	}
	if len(m.DescribeLanguageId) > 0 {
		l = 0
		for _, e := range m.DescribeLanguageId {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.Bags) > 0 {
		for _, e := range m.Bags {
			l = e.Size()
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	if m.RealEnd != 0 {
		n += 1 + sovActivity(uint64(m.RealEnd))
	}
	return n
}

func (m *LevelGrowthFundItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Free {
		n += 2
	}
	if m.Paid {
		n += 2
	}
	return n
}

func (m *LevelGrowthFundCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.TypeId != 0 {
		n += 1 + sovActivity(uint64(m.TypeId))
	}
	if m.Level != 0 {
		n += 1 + sovActivity(uint64(m.Level))
	}
	if len(m.ActivityReward) > 0 {
		l = 0
		for _, e := range m.ActivityReward {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.ActivityPayReward) > 0 {
		l = 0
		for _, e := range m.ActivityPayReward {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	return n
}

func (m *FirstPayCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.TypeId != 0 {
		n += 1 + sovActivity(uint64(m.TypeId))
	}
	l = len(m.ItemPictureId)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	l = len(m.SpecialFieldId)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	if m.Day != 0 {
		n += 1 + sovActivity(uint64(m.Day))
	}
	if len(m.ActivityReward) > 0 {
		l = 0
		for _, e := range m.ActivityReward {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	return n
}

func (m *AccRechargeCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.DemandAmount != 0 {
		n += 1 + sovActivity(uint64(m.DemandAmount))
	}
	if len(m.RechargeReward) > 0 {
		l = 0
		for _, e := range m.RechargeReward {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	return n
}

func (m *DailySaleCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.BuyType != 0 {
		n += 1 + sovActivity(uint64(m.BuyType))
	}
	if len(m.PayId) > 0 {
		l = 0
		for _, e := range m.PayId {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.ActivityReward) > 0 {
		l = 0
		for _, e := range m.ActivityReward {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	l = len(m.ItemPictureId)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	if m.PayNum != 0 {
		n += 1 + sovActivity(uint64(m.PayNum))
	}
	if m.ActivityGridId != 0 {
		n += 1 + sovActivity(uint64(m.ActivityGridId))
	}
	return n
}

func (m *WeeklySaleCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.BuyType != 0 {
		n += 1 + sovActivity(uint64(m.BuyType))
	}
	if len(m.PayId) > 0 {
		l = 0
		for _, e := range m.PayId {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.ActivityReward) > 0 {
		l = 0
		for _, e := range m.ActivityReward {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	l = len(m.ItemPictureId)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	if m.PayNum != 0 {
		n += 1 + sovActivity(uint64(m.PayNum))
	}
	if m.ActivityGridId != 0 {
		n += 1 + sovActivity(uint64(m.ActivityGridId))
	}
	return n
}

func (m *StellargemShopCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if len(m.StellarGemNum) > 0 {
		l = 0
		for _, e := range m.StellarGemNum {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.SourceGemNum) > 0 {
		l = 0
		for _, e := range m.SourceGemNum {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.ExtraGemNum) > 0 {
		l = 0
		for _, e := range m.ExtraGemNum {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if m.GiftLanguage != 0 {
		n += 1 + sovActivity(uint64(m.GiftLanguage))
	}
	if m.BuyGiftLanguage != 0 {
		n += 1 + sovActivity(uint64(m.BuyGiftLanguage))
	}
	l = len(m.StellarGemIconName)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	if m.PurchasePrice != 0 {
		n += 1 + sovActivity(uint64(m.PurchasePrice))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	l = len(m.GiftTags)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	return n
}

func (m *PassesReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovActivity(uint64(m.Lv))
	}
	if m.RewardType != 0 {
		n += 1 + sovActivity(uint64(m.RewardType))
	}
	if len(m.FreeReward) > 0 {
		for k, v := range m.FreeReward {
			_ = k
			_ = v
			mapEntrySize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if len(m.PaidReward) > 0 {
		for k, v := range m.PaidReward {
			_ = k
			_ = v
			mapEntrySize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if m.RequiredExp != 0 {
		n += 1 + sovActivity(uint64(m.RequiredExp))
	}
	if len(m.LvRange) > 0 {
		l = 0
		for _, e := range m.LvRange {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	return n
}

func (m *PassesData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovActivity(uint64(m.Lv))
	}
	if m.Exp != 0 {
		n += 1 + sovActivity(uint64(m.Exp))
	}
	if m.Status != 0 {
		n += 1 + sovActivity(uint64(m.Status))
	}
	if len(m.FreeUnlock) > 0 {
		for k, v := range m.FreeUnlock {
			_ = k
			_ = v
			mapEntrySize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if len(m.PaidUnlock) > 0 {
		for k, v := range m.PaidUnlock {
			_ = k
			_ = v
			mapEntrySize := 1 + sovActivity(uint64(k)) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if m.ResetAt != 0 {
		n += 1 + sovActivity(uint64(m.ResetAt))
	}
	return n
}

func (m *Passes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovActivity(uint64(l))
	}
	if len(m.RewardCfgs) > 0 {
		for _, e := range m.RewardCfgs {
			l = e.Size()
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	if m.AdvancePrice != 0 {
		n += 1 + sovActivity(uint64(m.AdvancePrice))
	}
	return n
}

func (m *ZeroBuy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BuyAt) > 0 {
		l = 0
		for _, e := range m.BuyAt {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	return n
}

func (m *ZeroBuyCfg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovActivity(uint64(m.Id))
	}
	if m.ActivityId != 0 {
		n += 1 + sovActivity(uint64(m.ActivityId))
	}
	if m.Day != 0 {
		n += 1 + sovActivity(uint64(m.Day))
	}
	if len(m.RewardImmediately) > 0 {
		l = 0
		for _, e := range m.RewardImmediately {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.RewardTomo) > 0 {
		l = 0
		for _, e := range m.RewardTomo {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.CostItem) > 0 {
		l = 0
		for _, e := range m.CostItem {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	if len(m.PictureId) > 0 {
		for _, s := range m.PictureId {
			l = len(s)
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	return n
}

func sovActivity(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozActivity(x uint64) (n int) {
	return sovActivity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Activity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Activity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Activity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityDescribeLanguageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivityDescribeLanguageId = append(m.ActivityDescribeLanguageId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemId", wireType)
			}
			m.SystemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChargeId = append(m.ChargeId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SevenDaysInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SevenDaysInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SevenDaysInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedInDay", wireType)
			}
			m.SignedInDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignedInDay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReceivedRewardDays = append(m.ReceivedRewardDays, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReceivedRewardDays) == 0 {
					m.ReceivedRewardDays = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReceivedRewardDays = append(m.ReceivedRewardDays, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedRewardDays", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityId", wireType)
			}
			m.ActivityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftBag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftBag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeId", wireType)
			}
			m.ChargeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSoldOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSoldOut = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayValue", wireType)
			}
			m.PayValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimitedTimePackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimitedTimePackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimitedTimePackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainCityIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainCityIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Banner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			m.Name = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DescribeLanguageId = append(m.DescribeLanguageId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DescribeLanguageId) == 0 {
					m.DescribeLanguageId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DescribeLanguageId = append(m.DescribeLanguageId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DescribeLanguageId", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bags = append(m.Bags, &GiftBag{})
			if err := m.Bags[len(m.Bags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealEnd", wireType)
			}
			m.RealEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelGrowthFundItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LevelGrowthFundItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LevelGrowthFundItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Free = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelGrowthFundCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LevelGrowthFundCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LevelGrowthFundCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivityReward = append(m.ActivityReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivityReward) == 0 {
					m.ActivityReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivityReward = append(m.ActivityReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityReward", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivityPayReward = append(m.ActivityPayReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivityPayReward) == 0 {
					m.ActivityPayReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivityPayReward = append(m.ActivityPayReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityPayReward", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirstPayCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirstPayCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirstPayCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemPictureId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemPictureId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialFieldId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecialFieldId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
			m.Day = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Day |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivityReward = append(m.ActivityReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivityReward) == 0 {
					m.ActivityReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivityReward = append(m.ActivityReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityReward", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccRechargeCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccRechargeCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccRechargeCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DemandAmount", wireType)
			}
			m.DemandAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DemandAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RechargeReward = append(m.RechargeReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RechargeReward) == 0 {
					m.RechargeReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RechargeReward = append(m.RechargeReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeReward", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailySaleCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailySaleCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailySaleCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyType", wireType)
			}
			m.BuyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PayId = append(m.PayId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PayId) == 0 {
					m.PayId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PayId = append(m.PayId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PayId", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivityReward = append(m.ActivityReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivityReward) == 0 {
					m.ActivityReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivityReward = append(m.ActivityReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityReward", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemPictureId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemPictureId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			m.PayNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityGridId", wireType)
			}
			m.ActivityGridId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityGridId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeeklySaleCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeeklySaleCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeeklySaleCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyType", wireType)
			}
			m.BuyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PayId = append(m.PayId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PayId) == 0 {
					m.PayId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PayId = append(m.PayId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PayId", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivityReward = append(m.ActivityReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivityReward) == 0 {
					m.ActivityReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivityReward = append(m.ActivityReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityReward", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemPictureId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemPictureId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			m.PayNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityGridId", wireType)
			}
			m.ActivityGridId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityGridId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StellargemShopCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StellargemShopCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StellargemShopCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StellarGemNum = append(m.StellarGemNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StellarGemNum) == 0 {
					m.StellarGemNum = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StellarGemNum = append(m.StellarGemNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StellarGemNum", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SourceGemNum = append(m.SourceGemNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SourceGemNum) == 0 {
					m.SourceGemNum = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SourceGemNum = append(m.SourceGemNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGemNum", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExtraGemNum = append(m.ExtraGemNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExtraGemNum) == 0 {
					m.ExtraGemNum = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExtraGemNum = append(m.ExtraGemNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraGemNum", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftLanguage", wireType)
			}
			m.GiftLanguage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftLanguage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGiftLanguage", wireType)
			}
			m.BuyGiftLanguage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyGiftLanguage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StellarGemIconName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StellarGemIconName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchasePrice", wireType)
			}
			m.PurchasePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurchasePrice |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftTags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassesReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassesReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassesReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardType", wireType)
			}
			m.RewardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FreeReward == nil {
				m.FreeReward = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FreeReward[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaidReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaidReward == nil {
				m.PaidReward = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PaidReward[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredExp", wireType)
			}
			m.RequiredExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredExp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LvRange = append(m.LvRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LvRange) == 0 {
					m.LvRange = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LvRange = append(m.LvRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LvRange", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PassesStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeUnlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FreeUnlock == nil {
				m.FreeUnlock = make(map[int64]RewardStatus)
			}
			var mapkey int64
			var mapvalue RewardStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= RewardStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FreeUnlock[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaidUnlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaidUnlock == nil {
				m.PaidUnlock = make(map[int64]RewardStatus)
			}
			var mapkey int64
			var mapvalue RewardStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= RewardStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PaidUnlock[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetAt", wireType)
			}
			m.ResetAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Passes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PassesData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardCfgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardCfgs = append(m.RewardCfgs, &PassesReward{})
			if err := m.RewardCfgs[len(m.RewardCfgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancePrice", wireType)
			}
			m.AdvancePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvancePrice |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroBuy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroBuy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroBuy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuyAt = append(m.BuyAt, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuyAt) == 0 {
					m.BuyAt = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuyAt = append(m.BuyAt, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyAt", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroBuyCfg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroBuyCfg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroBuyCfg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityId", wireType)
			}
			m.ActivityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
			m.Day = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Day |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RewardImmediately = append(m.RewardImmediately, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RewardImmediately) == 0 {
					m.RewardImmediately = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RewardImmediately = append(m.RewardImmediately, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardImmediately", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RewardTomo = append(m.RewardTomo, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RewardTomo) == 0 {
					m.RewardTomo = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RewardTomo = append(m.RewardTomo, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTomo", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CostItem = append(m.CostItem, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthActivity
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CostItem) == 0 {
					m.CostItem = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CostItem = append(m.CostItem, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CostItem", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PictureId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthActivity
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PictureId = append(m.PictureId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipActivity(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthActivity
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupActivity
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthActivity
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthActivity        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowActivity          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupActivity = fmt.Errorf("proto: unexpected end of group")
)
