// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/models/moothly_card.proto

package models

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MoonthlyCardType int32

const (
	MoonthlyCardType_Free      MoonthlyCardType = 0
	MoonthlyCardType_Purchase  MoonthlyCardType = 1
	MoonthlyCardType_Subscribe MoonthlyCardType = 2
)

var MoonthlyCardType_name = map[int32]string{
	0: "Free",
	1: "Purchase",
	2: "Subscribe",
}

var MoonthlyCardType_value = map[string]int32{
	"Free":      0,
	"Purchase":  1,
	"Subscribe": 2,
}

func (MoonthlyCardType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_912f13a1167d603b, []int{0}
}

type MoonthlyCardInfo struct {
	Id             int64            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StartTime      int64            `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	ReceiveTimes   int64            `protobuf:"varint,3,opt,name=receive_times,json=receiveTimes,proto3" json:"receive_times,omitempty"`
	RemainingTimes int64            `protobuf:"varint,4,opt,name=remaining_times,json=remainingTimes,proto3" json:"remaining_times,omitempty"`
	CardType       MoonthlyCardType `protobuf:"varint,5,opt,name=card_type,json=cardType,proto3,enum=models.MoonthlyCardType" json:"card_type,omitempty"`
	CanReceive     bool             `protobuf:"varint,6,opt,name=can_receive,json=canReceive,proto3" json:"can_receive,omitempty"`
	IsSub          bool             `protobuf:"varint,7,opt,name=is_sub,json=isSub,proto3" json:"is_sub,omitempty"`
}

func (m *MoonthlyCardInfo) Reset()      { *m = MoonthlyCardInfo{} }
func (*MoonthlyCardInfo) ProtoMessage() {}
func (*MoonthlyCardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_912f13a1167d603b, []int{0}
}
func (m *MoonthlyCardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoonthlyCardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoonthlyCardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoonthlyCardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoonthlyCardInfo.Merge(m, src)
}
func (m *MoonthlyCardInfo) XXX_Size() int {
	return m.Size()
}
func (m *MoonthlyCardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MoonthlyCardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MoonthlyCardInfo proto.InternalMessageInfo

func (m *MoonthlyCardInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MoonthlyCardInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MoonthlyCardInfo) GetReceiveTimes() int64 {
	if m != nil {
		return m.ReceiveTimes
	}
	return 0
}

func (m *MoonthlyCardInfo) GetRemainingTimes() int64 {
	if m != nil {
		return m.RemainingTimes
	}
	return 0
}

func (m *MoonthlyCardInfo) GetCardType() MoonthlyCardType {
	if m != nil {
		return m.CardType
	}
	return MoonthlyCardType_Free
}

func (m *MoonthlyCardInfo) GetCanReceive() bool {
	if m != nil {
		return m.CanReceive
	}
	return false
}

func (m *MoonthlyCardInfo) GetIsSub() bool {
	if m != nil {
		return m.IsSub
	}
	return false
}

func (*MoonthlyCardInfo) XXX_MessageName() string {
	return "models.MoonthlyCardInfo"
}

type MoonthlyCardPurchaseTimes struct {
	DetailTimes map[int64]int64 `protobuf:"bytes,19,rep,name=detail_times,json=detailTimes,proto3" json:"detail_times,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *MoonthlyCardPurchaseTimes) Reset()      { *m = MoonthlyCardPurchaseTimes{} }
func (*MoonthlyCardPurchaseTimes) ProtoMessage() {}
func (*MoonthlyCardPurchaseTimes) Descriptor() ([]byte, []int) {
	return fileDescriptor_912f13a1167d603b, []int{1}
}
func (m *MoonthlyCardPurchaseTimes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoonthlyCardPurchaseTimes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoonthlyCardPurchaseTimes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoonthlyCardPurchaseTimes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoonthlyCardPurchaseTimes.Merge(m, src)
}
func (m *MoonthlyCardPurchaseTimes) XXX_Size() int {
	return m.Size()
}
func (m *MoonthlyCardPurchaseTimes) XXX_DiscardUnknown() {
	xxx_messageInfo_MoonthlyCardPurchaseTimes.DiscardUnknown(m)
}

var xxx_messageInfo_MoonthlyCardPurchaseTimes proto.InternalMessageInfo

func (m *MoonthlyCardPurchaseTimes) GetDetailTimes() map[int64]int64 {
	if m != nil {
		return m.DetailTimes
	}
	return nil
}

func (*MoonthlyCardPurchaseTimes) XXX_MessageName() string {
	return "models.MoonthlyCardPurchaseTimes"
}

type MoonthlyCardActivityInfo struct {
	ActivityId         int64                                `protobuf:"varint,1,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	IsInvalid          bool                                 `protobuf:"varint,2,opt,name=is_invalid,json=isInvalid,proto3" json:"is_invalid,omitempty"`
	StartTime          int64                                `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	Progress           map[int64]int64                      `protobuf:"bytes,4,rep,name=progress,proto3" json:"progress,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	InvalidCards       []int64                              `protobuf:"varint,5,rep,packed,name=invalid_cards,json=invalidCards,proto3" json:"invalid_cards,omitempty"`
	CanActivationCards []int64                              `protobuf:"varint,6,rep,packed,name=can_activation_cards,json=canActivationCards,proto3" json:"can_activation_cards,omitempty"`
	ActivationCards    map[int64]*MoonthlyCardInfo          `protobuf:"bytes,7,rep,name=activation_cards,json=activationCards,proto3" json:"activation_cards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LastLoginTime      map[int64]int64                      `protobuf:"bytes,8,rep,name=last_login_time,json=lastLoginTime,proto3" json:"last_login_time,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	PurchaseTimes      map[int64]*MoonthlyCardPurchaseTimes `protobuf:"bytes,9,rep,name=purchase_times,json=purchaseTimes,proto3" json:"purchase_times,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MoonthlyCardActivityInfo) Reset()      { *m = MoonthlyCardActivityInfo{} }
func (*MoonthlyCardActivityInfo) ProtoMessage() {}
func (*MoonthlyCardActivityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_912f13a1167d603b, []int{2}
}
func (m *MoonthlyCardActivityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoonthlyCardActivityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoonthlyCardActivityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoonthlyCardActivityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoonthlyCardActivityInfo.Merge(m, src)
}
func (m *MoonthlyCardActivityInfo) XXX_Size() int {
	return m.Size()
}
func (m *MoonthlyCardActivityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MoonthlyCardActivityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MoonthlyCardActivityInfo proto.InternalMessageInfo

func (m *MoonthlyCardActivityInfo) GetActivityId() int64 {
	if m != nil {
		return m.ActivityId
	}
	return 0
}

func (m *MoonthlyCardActivityInfo) GetIsInvalid() bool {
	if m != nil {
		return m.IsInvalid
	}
	return false
}

func (m *MoonthlyCardActivityInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *MoonthlyCardActivityInfo) GetProgress() map[int64]int64 {
	if m != nil {
		return m.Progress
	}
	return nil
}

func (m *MoonthlyCardActivityInfo) GetInvalidCards() []int64 {
	if m != nil {
		return m.InvalidCards
	}
	return nil
}

func (m *MoonthlyCardActivityInfo) GetCanActivationCards() []int64 {
	if m != nil {
		return m.CanActivationCards
	}
	return nil
}

func (m *MoonthlyCardActivityInfo) GetActivationCards() map[int64]*MoonthlyCardInfo {
	if m != nil {
		return m.ActivationCards
	}
	return nil
}

func (m *MoonthlyCardActivityInfo) GetLastLoginTime() map[int64]int64 {
	if m != nil {
		return m.LastLoginTime
	}
	return nil
}

func (m *MoonthlyCardActivityInfo) GetPurchaseTimes() map[int64]*MoonthlyCardPurchaseTimes {
	if m != nil {
		return m.PurchaseTimes
	}
	return nil
}

func (*MoonthlyCardActivityInfo) XXX_MessageName() string {
	return "models.MoonthlyCardActivityInfo"
}

type MoonthlyCardProgress struct {
	CanActivationCards []int64         `protobuf:"varint,1,rep,packed,name=can_activation_cards,json=canActivationCards,proto3" json:"can_activation_cards,omitempty"`
	Progress           map[int64]int64 `protobuf:"bytes,2,rep,name=progress,proto3" json:"progress,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *MoonthlyCardProgress) Reset()      { *m = MoonthlyCardProgress{} }
func (*MoonthlyCardProgress) ProtoMessage() {}
func (*MoonthlyCardProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_912f13a1167d603b, []int{3}
}
func (m *MoonthlyCardProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoonthlyCardProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoonthlyCardProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoonthlyCardProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoonthlyCardProgress.Merge(m, src)
}
func (m *MoonthlyCardProgress) XXX_Size() int {
	return m.Size()
}
func (m *MoonthlyCardProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_MoonthlyCardProgress.DiscardUnknown(m)
}

var xxx_messageInfo_MoonthlyCardProgress proto.InternalMessageInfo

func (m *MoonthlyCardProgress) GetCanActivationCards() []int64 {
	if m != nil {
		return m.CanActivationCards
	}
	return nil
}

func (m *MoonthlyCardProgress) GetProgress() map[int64]int64 {
	if m != nil {
		return m.Progress
	}
	return nil
}

func (*MoonthlyCardProgress) XXX_MessageName() string {
	return "models.MoonthlyCardProgress"
}

type MoonthlyCardCnf struct {
	Id              int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Language1       string  `protobuf:"bytes,2,opt,name=Language1,proto3" json:"Language1,omitempty"`
	ActivityId      int64   `protobuf:"varint,3,opt,name=ActivityId,proto3" json:"ActivityId,omitempty"`
	UnlockCondition []int64 `protobuf:"varint,4,rep,packed,name=UnlockCondition,proto3" json:"UnlockCondition,omitempty"`
	Banner          string  `protobuf:"bytes,5,opt,name=Banner,proto3" json:"Banner,omitempty"`
	Timeliness      int64   `protobuf:"varint,6,opt,name=Timeliness,proto3" json:"Timeliness,omitempty"`
	Duration        int64   `protobuf:"varint,7,opt,name=Duration,proto3" json:"Duration,omitempty"`
	ActivateType    int64   `protobuf:"varint,8,opt,name=ActivateType,proto3" json:"ActivateType,omitempty"`
	PurchaseOptions []int64 `protobuf:"varint,9,rep,packed,name=PurchaseOptions,proto3" json:"PurchaseOptions,omitempty"`
	Price           []int64 `protobuf:"varint,10,rep,packed,name=Price,proto3" json:"Price,omitempty"`
	FirstPrice      []int64 `protobuf:"varint,11,rep,packed,name=FirstPrice,proto3" json:"FirstPrice,omitempty"`
	ShowPrice       []int64 `protobuf:"varint,12,rep,packed,name=ShowPrice,proto3" json:"ShowPrice,omitempty"`
	AveragePrice    int64   `protobuf:"varint,13,opt,name=AveragePrice,proto3" json:"AveragePrice,omitempty"`
	Discount        int64   `protobuf:"varint,14,opt,name=Discount,proto3" json:"Discount,omitempty"`
	DailyReward     []int64 `protobuf:"varint,15,rep,packed,name=DailyReward,proto3" json:"DailyReward,omitempty"`
	PurchaseReward  []int64 `protobuf:"varint,16,rep,packed,name=PurchaseReward,proto3" json:"PurchaseReward,omitempty"`
	RenewalReward   []int64 `protobuf:"varint,17,rep,packed,name=RenewalReward,proto3" json:"RenewalReward,omitempty"`
	Value           int64   `protobuf:"varint,18,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *MoonthlyCardCnf) Reset()      { *m = MoonthlyCardCnf{} }
func (*MoonthlyCardCnf) ProtoMessage() {}
func (*MoonthlyCardCnf) Descriptor() ([]byte, []int) {
	return fileDescriptor_912f13a1167d603b, []int{4}
}
func (m *MoonthlyCardCnf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoonthlyCardCnf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoonthlyCardCnf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoonthlyCardCnf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoonthlyCardCnf.Merge(m, src)
}
func (m *MoonthlyCardCnf) XXX_Size() int {
	return m.Size()
}
func (m *MoonthlyCardCnf) XXX_DiscardUnknown() {
	xxx_messageInfo_MoonthlyCardCnf.DiscardUnknown(m)
}

var xxx_messageInfo_MoonthlyCardCnf proto.InternalMessageInfo

func (m *MoonthlyCardCnf) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MoonthlyCardCnf) GetLanguage1() string {
	if m != nil {
		return m.Language1
	}
	return ""
}

func (m *MoonthlyCardCnf) GetActivityId() int64 {
	if m != nil {
		return m.ActivityId
	}
	return 0
}

func (m *MoonthlyCardCnf) GetUnlockCondition() []int64 {
	if m != nil {
		return m.UnlockCondition
	}
	return nil
}

func (m *MoonthlyCardCnf) GetBanner() string {
	if m != nil {
		return m.Banner
	}
	return ""
}

func (m *MoonthlyCardCnf) GetTimeliness() int64 {
	if m != nil {
		return m.Timeliness
	}
	return 0
}

func (m *MoonthlyCardCnf) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *MoonthlyCardCnf) GetActivateType() int64 {
	if m != nil {
		return m.ActivateType
	}
	return 0
}

func (m *MoonthlyCardCnf) GetPurchaseOptions() []int64 {
	if m != nil {
		return m.PurchaseOptions
	}
	return nil
}

func (m *MoonthlyCardCnf) GetPrice() []int64 {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *MoonthlyCardCnf) GetFirstPrice() []int64 {
	if m != nil {
		return m.FirstPrice
	}
	return nil
}

func (m *MoonthlyCardCnf) GetShowPrice() []int64 {
	if m != nil {
		return m.ShowPrice
	}
	return nil
}

func (m *MoonthlyCardCnf) GetAveragePrice() int64 {
	if m != nil {
		return m.AveragePrice
	}
	return 0
}

func (m *MoonthlyCardCnf) GetDiscount() int64 {
	if m != nil {
		return m.Discount
	}
	return 0
}

func (m *MoonthlyCardCnf) GetDailyReward() []int64 {
	if m != nil {
		return m.DailyReward
	}
	return nil
}

func (m *MoonthlyCardCnf) GetPurchaseReward() []int64 {
	if m != nil {
		return m.PurchaseReward
	}
	return nil
}

func (m *MoonthlyCardCnf) GetRenewalReward() []int64 {
	if m != nil {
		return m.RenewalReward
	}
	return nil
}

func (m *MoonthlyCardCnf) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (*MoonthlyCardCnf) XXX_MessageName() string {
	return "models.MoonthlyCardCnf"
}
func init() {
	proto.RegisterEnum("models.MoonthlyCardType", MoonthlyCardType_name, MoonthlyCardType_value)
	proto.RegisterType((*MoonthlyCardInfo)(nil), "models.MoonthlyCardInfo")
	proto.RegisterType((*MoonthlyCardPurchaseTimes)(nil), "models.MoonthlyCardPurchaseTimes")
	proto.RegisterMapType((map[int64]int64)(nil), "models.MoonthlyCardPurchaseTimes.DetailTimesEntry")
	proto.RegisterType((*MoonthlyCardActivityInfo)(nil), "models.MoonthlyCardActivityInfo")
	proto.RegisterMapType((map[int64]*MoonthlyCardInfo)(nil), "models.MoonthlyCardActivityInfo.ActivationCardsEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "models.MoonthlyCardActivityInfo.LastLoginTimeEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "models.MoonthlyCardActivityInfo.ProgressEntry")
	proto.RegisterMapType((map[int64]*MoonthlyCardPurchaseTimes)(nil), "models.MoonthlyCardActivityInfo.PurchaseTimesEntry")
	proto.RegisterType((*MoonthlyCardProgress)(nil), "models.MoonthlyCardProgress")
	proto.RegisterMapType((map[int64]int64)(nil), "models.MoonthlyCardProgress.ProgressEntry")
	proto.RegisterType((*MoonthlyCardCnf)(nil), "models.MoonthlyCardCnf")
}

func init() { proto.RegisterFile("proto/models/moothly_card.proto", fileDescriptor_912f13a1167d603b) }

var fileDescriptor_912f13a1167d603b = []byte{
	// 959 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0x7a, 0x13, 0x77, 0xfd, 0xfc, 0x93, 0x21, 0x54, 0x8b, 0x55, 0x36, 0xc6, 0x20, 0xb0,
	0x2a, 0xe1, 0x40, 0xaa, 0x8a, 0x5f, 0x12, 0xa2, 0x4d, 0x88, 0x14, 0x94, 0x8a, 0x68, 0xd3, 0x72,
	0x28, 0x48, 0x66, 0xbc, 0x3b, 0x71, 0x46, 0x5d, 0xcf, 0x58, 0x33, 0x6b, 0x47, 0xfe, 0x2f, 0xf8,
	0x33, 0x38, 0xf3, 0x3f, 0x20, 0xf5, 0x82, 0xd4, 0x63, 0x8f, 0xe0, 0x5c, 0x38, 0x72, 0xe5, 0x82,
	0xd0, 0xfc, 0xb0, 0xb3, 0xeb, 0x38, 0x0a, 0x55, 0x6f, 0x3b, 0xdf, 0xfb, 0xe6, 0xbd, 0x6f, 0xbe,
	0xf7, 0x66, 0x77, 0x61, 0x7b, 0x2c, 0x78, 0xca, 0x77, 0x46, 0x3c, 0x26, 0x89, 0xdc, 0x19, 0x71,
	0x9e, 0x9e, 0x25, 0xb3, 0x7e, 0x84, 0x45, 0xdc, 0xd3, 0x11, 0x54, 0x32, 0xa1, 0xd6, 0xed, 0x1c,
	0x71, 0x80, 0x87, 0x26, 0xde, 0xba, 0x93, 0xc3, 0x4f, 0xb9, 0x18, 0xe1, 0x94, 0x72, 0x66, 0xa2,
	0x9d, 0x7f, 0x1d, 0x68, 0x3e, 0xe2, 0x9c, 0xa9, 0xac, 0x7b, 0x58, 0xc4, 0x87, 0xec, 0x94, 0xa3,
	0x3a, 0x14, 0x69, 0xec, 0x3b, 0x6d, 0xa7, 0xeb, 0x86, 0x45, 0x1a, 0xa3, 0x77, 0x00, 0x64, 0x8a,
	0x45, 0xda, 0x4f, 0xe9, 0x88, 0xf8, 0x45, 0x8d, 0x97, 0x35, 0xf2, 0x98, 0x8e, 0x08, 0x7a, 0x0f,
	0x6a, 0x82, 0x44, 0x84, 0x4e, 0x89, 0x26, 0x48, 0xdf, 0xd5, 0x8c, 0xaa, 0x05, 0x15, 0x47, 0xa2,
	0x0f, 0xa1, 0x21, 0xc8, 0x08, 0x53, 0x46, 0xd9, 0xd0, 0xd2, 0x36, 0x34, 0xad, 0xbe, 0x84, 0x0d,
	0xf1, 0x3e, 0x94, 0xd5, 0xe9, 0xfa, 0xe9, 0x6c, 0x4c, 0xfc, 0xcd, 0xb6, 0xd3, 0xad, 0xef, 0xfa,
	0x3d, 0xa3, 0xbe, 0x97, 0x55, 0xfa, 0x78, 0x36, 0x26, 0xa1, 0x17, 0xd9, 0x27, 0xb4, 0x0d, 0x95,
	0x08, 0xb3, 0xbe, 0xad, 0xe9, 0x97, 0xda, 0x4e, 0xd7, 0x0b, 0x21, 0xc2, 0x2c, 0x34, 0x08, 0x7a,
	0x0b, 0x4a, 0x54, 0xf6, 0xe5, 0x64, 0xe0, 0xdf, 0xd2, 0xb1, 0x4d, 0x2a, 0x4f, 0x26, 0x83, 0xce,
	0xaf, 0x0e, 0xbc, 0x9d, 0x4d, 0x7b, 0x3c, 0x11, 0xd1, 0x19, 0x96, 0x56, 0xf5, 0x13, 0xa8, 0xc6,
	0x24, 0xc5, 0x34, 0xb1, 0x92, 0xdf, 0x6c, 0xbb, 0xdd, 0xca, 0xee, 0xee, 0x3a, 0x3d, 0xb9, 0x8d,
	0xbd, 0x7d, 0xbd, 0x4b, 0x3f, 0x7f, 0xc3, 0x52, 0x31, 0x0b, 0x2b, 0xf1, 0x25, 0xd2, 0xfa, 0x0a,
	0x9a, 0xab, 0x04, 0xd4, 0x04, 0xf7, 0x19, 0x99, 0x59, 0xd7, 0xd5, 0x23, 0xda, 0x82, 0xcd, 0x29,
	0x4e, 0x26, 0x0b, 0xc7, 0xcd, 0xe2, 0x8b, 0xe2, 0x67, 0x4e, 0xe7, 0x9f, 0x12, 0xf8, 0xd9, 0xda,
	0x0f, 0xa2, 0x94, 0x4e, 0x69, 0x3a, 0xd3, 0xdd, 0xdb, 0x86, 0x0a, 0xb6, 0xeb, 0xfe, 0xb2, 0x8d,
	0xb0, 0x80, 0x0e, 0x75, 0x3b, 0xa9, 0xec, 0x53, 0x36, 0xc5, 0x09, 0x8d, 0x75, 0x72, 0x2f, 0x2c,
	0x53, 0x79, 0x68, 0x80, 0x95, 0x6e, 0xbb, 0xab, 0xdd, 0xfe, 0x16, 0xbc, 0xb1, 0xe0, 0x43, 0x41,
	0xa4, 0xea, 0xa0, 0xb2, 0xa3, 0xb7, 0xce, 0x8e, 0xac, 0xa4, 0xde, 0xb1, 0xdd, 0x60, 0xac, 0x58,
	0xee, 0x57, 0x93, 0x63, 0x65, 0xe8, 0x89, 0x96, 0xfe, 0x66, 0xdb, 0x55, 0x93, 0x63, 0x41, 0x95,
	0x47, 0xa2, 0x8f, 0x61, 0x4b, 0x75, 0x56, 0x1f, 0x40, 0x8f, 0xae, 0xe5, 0x96, 0x34, 0x17, 0x45,
	0x98, 0x3d, 0x58, 0x86, 0xcc, 0x8e, 0x9f, 0xa0, 0x79, 0x85, 0x7d, 0x4b, 0x4b, 0xbd, 0x7f, 0xa3,
	0xd4, 0x95, 0x5c, 0x46, 0x71, 0x03, 0xaf, 0x54, 0xf8, 0x01, 0x1a, 0x09, 0x96, 0x69, 0x3f, 0xe1,
	0x43, 0xca, 0x8c, 0x51, 0x9e, 0x2e, 0x70, 0xef, 0xc6, 0x02, 0x47, 0x58, 0xa6, 0x47, 0x6a, 0x9b,
	0x72, 0xd3, 0xa4, 0xaf, 0x25, 0x59, 0x0c, 0x3d, 0x85, 0xfa, 0xd8, 0x0e, 0x93, 0x1d, 0xbb, 0xf2,
	0xff, 0xcc, 0x9d, 0x9b, 0x41, 0x9b, 0x7b, 0x9c, 0xc5, 0x5a, 0x5f, 0x42, 0x2d, 0xd7, 0x8c, 0x57,
	0x19, 0xbb, 0xd6, 0x8f, 0xb0, 0xb5, 0xce, 0x9e, 0x35, 0x39, 0x7a, 0xd9, 0x1c, 0x95, 0xf5, 0x17,
	0x58, 0x29, 0xce, 0x66, 0xff, 0x1a, 0xd0, 0x55, 0x6f, 0x5e, 0x49, 0x5f, 0x04, 0xe8, 0xaa, 0x03,
	0x6b, 0x32, 0x7c, 0x9a, 0x57, 0xf7, 0xee, 0x8d, 0xd7, 0x39, 0x7b, 0xf7, 0x7e, 0x77, 0x60, 0x2b,
	0x47, 0x5c, 0x0c, 0xf3, 0x75, 0x73, 0xea, 0x5c, 0x3b, 0xa7, 0x07, 0x99, 0xab, 0x54, 0xd4, 0x2d,
	0xbe, 0xbb, 0x56, 0x8a, 0xe5, 0x5c, 0x77, 0x8d, 0x5e, 0xab, 0xa9, 0x9d, 0xdf, 0x36, 0xa0, 0x91,
	0xad, 0xb6, 0xc7, 0x4e, 0xaf, 0x7c, 0x00, 0xee, 0x40, 0xf9, 0x08, 0xb3, 0xe1, 0x04, 0x0f, 0xc9,
	0x27, 0x3a, 0x43, 0x39, 0xbc, 0x04, 0x50, 0x00, 0xb0, 0x9c, 0xc2, 0xd8, 0xbe, 0x30, 0x32, 0x08,
	0xea, 0x42, 0xe3, 0x09, 0x4b, 0x78, 0xf4, 0x6c, 0x8f, 0xb3, 0x98, 0xaa, 0xe3, 0xeb, 0x17, 0x87,
	0x1b, 0xae, 0xc2, 0xe8, 0x36, 0x94, 0x1e, 0x62, 0xc6, 0x88, 0xd0, 0x2f, 0xfe, 0x72, 0x68, 0x57,
	0xaa, 0x82, 0xea, 0x43, 0x42, 0x99, 0xb2, 0xaa, 0x64, 0x2a, 0x5c, 0x22, 0xa8, 0x05, 0xde, 0xfe,
	0x44, 0x68, 0x67, 0xf5, 0xdb, 0xdd, 0x0d, 0x97, 0x6b, 0xd4, 0x81, 0xaa, 0xf5, 0x9d, 0xa8, 0x0f,
	0x85, 0xef, 0x99, 0x8f, 0x53, 0x16, 0x53, 0x0a, 0x17, 0xfd, 0xfe, 0x6e, 0xac, 0x76, 0x99, 0x2b,
	0xe7, 0x86, 0xab, 0xb0, 0xf2, 0xf1, 0x58, 0xd0, 0x88, 0xf8, 0xa0, 0xe3, 0x66, 0xa1, 0xf4, 0x1d,
	0x50, 0x21, 0x53, 0x13, 0xaa, 0xe8, 0x50, 0x06, 0x51, 0xfe, 0x9d, 0x9c, 0xf1, 0x73, 0x13, 0xae,
	0xea, 0xf0, 0x25, 0xa0, 0x15, 0x4e, 0x89, 0xc0, 0x43, 0x62, 0x08, 0x35, 0xab, 0x30, 0x83, 0xe9,
	0x13, 0x52, 0x19, 0xf1, 0x09, 0x4b, 0xfd, 0xba, 0x3d, 0xa1, 0x5d, 0xa3, 0x36, 0x54, 0xf6, 0x31,
	0x4d, 0x66, 0x21, 0x39, 0xc7, 0x22, 0xf6, 0x1b, 0x3a, 0x7f, 0x16, 0x42, 0x1f, 0x40, 0x7d, 0x71,
	0x10, 0x4b, 0x6a, 0x6a, 0xd2, 0x0a, 0x8a, 0xde, 0x87, 0x5a, 0x48, 0x18, 0x39, 0xc7, 0x89, 0xa5,
	0xbd, 0xa1, 0x69, 0x79, 0x50, 0x79, 0xf0, 0xbd, 0x9e, 0x25, 0x64, 0x66, 0x49, 0x2f, 0xee, 0x7e,
	0x9e, 0xff, 0x91, 0xd0, 0xbe, 0x7a, 0xb0, 0x71, 0x20, 0x08, 0x69, 0x16, 0x50, 0x15, 0xbc, 0x45,
	0xad, 0xa6, 0x83, 0x6a, 0x50, 0x3e, 0x99, 0x0c, 0x64, 0x24, 0xe8, 0x80, 0x34, 0x8b, 0x0f, 0x1f,
	0xbd, 0xfc, 0x33, 0x28, 0xfc, 0x32, 0x0f, 0x9c, 0xe7, 0xf3, 0xc0, 0x79, 0x31, 0x0f, 0x9c, 0x3f,
	0xe6, 0x81, 0xf3, 0xd7, 0x3c, 0x28, 0xfc, 0x3d, 0x0f, 0x9c, 0x9f, 0x2f, 0x82, 0xc2, 0xf3, 0x8b,
	0xc0, 0x79, 0x71, 0x11, 0x14, 0x5e, 0x5e, 0x04, 0x85, 0xa7, 0xdb, 0x11, 0xa7, 0xec, 0x23, 0x49,
	0xc4, 0x94, 0x88, 0x9d, 0x88, 0x8f, 0x46, 0x9c, 0xed, 0x64, 0xff, 0x71, 0x06, 0x25, 0xbd, 0xba,
	0xf7, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x66, 0x54, 0xe6, 0xb5, 0x3b, 0x09, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMoonthlyCardInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMoonthlyCardPurchaseTimes.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMoonthlyCardActivityInfo.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMoonthlyCardProgress.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMoonthlyCardCnf.Get().(proto.Message)
	})
}

var poolMoonthlyCardInfo = &sync.Pool{New: func() interface{} { return &MoonthlyCardInfo{} }}

func (m *MoonthlyCardInfo) ReleasePool() { m.Reset(); poolMoonthlyCardInfo.Put(m); m = nil }

var poolMoonthlyCardPurchaseTimes = &sync.Pool{New: func() interface{} { return &MoonthlyCardPurchaseTimes{} }}

func (m *MoonthlyCardPurchaseTimes) ReleasePool() {
	m.Reset()
	poolMoonthlyCardPurchaseTimes.Put(m)
	m = nil
}

var poolMoonthlyCardActivityInfo = &sync.Pool{New: func() interface{} { return &MoonthlyCardActivityInfo{} }}

func (m *MoonthlyCardActivityInfo) ReleasePool() {
	m.Reset()
	poolMoonthlyCardActivityInfo.Put(m)
	m = nil
}

var poolMoonthlyCardProgress = &sync.Pool{New: func() interface{} { return &MoonthlyCardProgress{} }}

func (m *MoonthlyCardProgress) ReleasePool() { m.Reset(); poolMoonthlyCardProgress.Put(m); m = nil }

var poolMoonthlyCardCnf = &sync.Pool{New: func() interface{} { return &MoonthlyCardCnf{} }}

func (m *MoonthlyCardCnf) ReleasePool() { m.Reset(); poolMoonthlyCardCnf.Put(m); m = nil }
func (x MoonthlyCardType) String() string {
	s, ok := MoonthlyCardType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MoonthlyCardInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MoonthlyCardInfo)
	if !ok {
		that2, ok := that.(MoonthlyCardInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.ReceiveTimes != that1.ReceiveTimes {
		return false
	}
	if this.RemainingTimes != that1.RemainingTimes {
		return false
	}
	if this.CardType != that1.CardType {
		return false
	}
	if this.CanReceive != that1.CanReceive {
		return false
	}
	if this.IsSub != that1.IsSub {
		return false
	}
	return true
}
func (this *MoonthlyCardPurchaseTimes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MoonthlyCardPurchaseTimes)
	if !ok {
		that2, ok := that.(MoonthlyCardPurchaseTimes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DetailTimes) != len(that1.DetailTimes) {
		return false
	}
	for i := range this.DetailTimes {
		if this.DetailTimes[i] != that1.DetailTimes[i] {
			return false
		}
	}
	return true
}
func (this *MoonthlyCardActivityInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MoonthlyCardActivityInfo)
	if !ok {
		that2, ok := that.(MoonthlyCardActivityInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ActivityId != that1.ActivityId {
		return false
	}
	if this.IsInvalid != that1.IsInvalid {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if len(this.Progress) != len(that1.Progress) {
		return false
	}
	for i := range this.Progress {
		if this.Progress[i] != that1.Progress[i] {
			return false
		}
	}
	if len(this.InvalidCards) != len(that1.InvalidCards) {
		return false
	}
	for i := range this.InvalidCards {
		if this.InvalidCards[i] != that1.InvalidCards[i] {
			return false
		}
	}
	if len(this.CanActivationCards) != len(that1.CanActivationCards) {
		return false
	}
	for i := range this.CanActivationCards {
		if this.CanActivationCards[i] != that1.CanActivationCards[i] {
			return false
		}
	}
	if len(this.ActivationCards) != len(that1.ActivationCards) {
		return false
	}
	for i := range this.ActivationCards {
		if !this.ActivationCards[i].Equal(that1.ActivationCards[i]) {
			return false
		}
	}
	if len(this.LastLoginTime) != len(that1.LastLoginTime) {
		return false
	}
	for i := range this.LastLoginTime {
		if this.LastLoginTime[i] != that1.LastLoginTime[i] {
			return false
		}
	}
	if len(this.PurchaseTimes) != len(that1.PurchaseTimes) {
		return false
	}
	for i := range this.PurchaseTimes {
		if !this.PurchaseTimes[i].Equal(that1.PurchaseTimes[i]) {
			return false
		}
	}
	return true
}
func (this *MoonthlyCardProgress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MoonthlyCardProgress)
	if !ok {
		that2, ok := that.(MoonthlyCardProgress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CanActivationCards) != len(that1.CanActivationCards) {
		return false
	}
	for i := range this.CanActivationCards {
		if this.CanActivationCards[i] != that1.CanActivationCards[i] {
			return false
		}
	}
	if len(this.Progress) != len(that1.Progress) {
		return false
	}
	for i := range this.Progress {
		if this.Progress[i] != that1.Progress[i] {
			return false
		}
	}
	return true
}
func (this *MoonthlyCardCnf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MoonthlyCardCnf)
	if !ok {
		that2, ok := that.(MoonthlyCardCnf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Language1 != that1.Language1 {
		return false
	}
	if this.ActivityId != that1.ActivityId {
		return false
	}
	if len(this.UnlockCondition) != len(that1.UnlockCondition) {
		return false
	}
	for i := range this.UnlockCondition {
		if this.UnlockCondition[i] != that1.UnlockCondition[i] {
			return false
		}
	}
	if this.Banner != that1.Banner {
		return false
	}
	if this.Timeliness != that1.Timeliness {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.ActivateType != that1.ActivateType {
		return false
	}
	if len(this.PurchaseOptions) != len(that1.PurchaseOptions) {
		return false
	}
	for i := range this.PurchaseOptions {
		if this.PurchaseOptions[i] != that1.PurchaseOptions[i] {
			return false
		}
	}
	if len(this.Price) != len(that1.Price) {
		return false
	}
	for i := range this.Price {
		if this.Price[i] != that1.Price[i] {
			return false
		}
	}
	if len(this.FirstPrice) != len(that1.FirstPrice) {
		return false
	}
	for i := range this.FirstPrice {
		if this.FirstPrice[i] != that1.FirstPrice[i] {
			return false
		}
	}
	if len(this.ShowPrice) != len(that1.ShowPrice) {
		return false
	}
	for i := range this.ShowPrice {
		if this.ShowPrice[i] != that1.ShowPrice[i] {
			return false
		}
	}
	if this.AveragePrice != that1.AveragePrice {
		return false
	}
	if this.Discount != that1.Discount {
		return false
	}
	if len(this.DailyReward) != len(that1.DailyReward) {
		return false
	}
	for i := range this.DailyReward {
		if this.DailyReward[i] != that1.DailyReward[i] {
			return false
		}
	}
	if len(this.PurchaseReward) != len(that1.PurchaseReward) {
		return false
	}
	for i := range this.PurchaseReward {
		if this.PurchaseReward[i] != that1.PurchaseReward[i] {
			return false
		}
	}
	if len(this.RenewalReward) != len(that1.RenewalReward) {
		return false
	}
	for i := range this.RenewalReward {
		if this.RenewalReward[i] != that1.RenewalReward[i] {
			return false
		}
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (m *MoonthlyCardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoonthlyCardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoonthlyCardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSub {
		i--
		if m.IsSub {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.CanReceive {
		i--
		if m.CanReceive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CardType != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.CardType))
		i--
		dAtA[i] = 0x28
	}
	if m.RemainingTimes != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.RemainingTimes))
		i--
		dAtA[i] = 0x20
	}
	if m.ReceiveTimes != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.ReceiveTimes))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTime != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoonthlyCardPurchaseTimes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoonthlyCardPurchaseTimes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoonthlyCardPurchaseTimes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DetailTimes) > 0 {
		for k := range m.DetailTimes {
			v := m.DetailTimes[k]
			baseI := i
			i = encodeVarintMoothlyCard(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMoothlyCard(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMoothlyCard(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	return len(dAtA) - i, nil
}

func (m *MoonthlyCardActivityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoonthlyCardActivityInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoonthlyCardActivityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PurchaseTimes) > 0 {
		for k := range m.PurchaseTimes {
			v := m.PurchaseTimes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMoothlyCard(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintMoothlyCard(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMoothlyCard(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.LastLoginTime) > 0 {
		for k := range m.LastLoginTime {
			v := m.LastLoginTime[k]
			baseI := i
			i = encodeVarintMoothlyCard(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMoothlyCard(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMoothlyCard(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ActivationCards) > 0 {
		for k := range m.ActivationCards {
			v := m.ActivationCards[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMoothlyCard(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintMoothlyCard(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMoothlyCard(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CanActivationCards) > 0 {
		dAtA4 := make([]byte, len(m.CanActivationCards)*10)
		var j3 int
		for _, num1 := range m.CanActivationCards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x32
	}
	if len(m.InvalidCards) > 0 {
		dAtA6 := make([]byte, len(m.InvalidCards)*10)
		var j5 int
		for _, num1 := range m.InvalidCards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Progress) > 0 {
		for k := range m.Progress {
			v := m.Progress[k]
			baseI := i
			i = encodeVarintMoothlyCard(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMoothlyCard(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMoothlyCard(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.StartTime != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.IsInvalid {
		i--
		if m.IsInvalid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ActivityId != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.ActivityId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoonthlyCardProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoonthlyCardProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoonthlyCardProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Progress) > 0 {
		for k := range m.Progress {
			v := m.Progress[k]
			baseI := i
			i = encodeVarintMoothlyCard(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintMoothlyCard(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintMoothlyCard(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanActivationCards) > 0 {
		dAtA8 := make([]byte, len(m.CanActivationCards)*10)
		var j7 int
		for _, num1 := range m.CanActivationCards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MoonthlyCardCnf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoonthlyCardCnf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoonthlyCardCnf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.RenewalReward) > 0 {
		dAtA10 := make([]byte, len(m.RenewalReward)*10)
		var j9 int
		for _, num1 := range m.RenewalReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PurchaseReward) > 0 {
		dAtA12 := make([]byte, len(m.PurchaseReward)*10)
		var j11 int
		for _, num1 := range m.PurchaseReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DailyReward) > 0 {
		dAtA14 := make([]byte, len(m.DailyReward)*10)
		var j13 int
		for _, num1 := range m.DailyReward {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x7a
	}
	if m.Discount != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.Discount))
		i--
		dAtA[i] = 0x70
	}
	if m.AveragePrice != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.AveragePrice))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ShowPrice) > 0 {
		dAtA16 := make([]byte, len(m.ShowPrice)*10)
		var j15 int
		for _, num1 := range m.ShowPrice {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x62
	}
	if len(m.FirstPrice) > 0 {
		dAtA18 := make([]byte, len(m.FirstPrice)*10)
		var j17 int
		for _, num1 := range m.FirstPrice {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Price) > 0 {
		dAtA20 := make([]byte, len(m.Price)*10)
		var j19 int
		for _, num1 := range m.Price {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PurchaseOptions) > 0 {
		dAtA22 := make([]byte, len(m.PurchaseOptions)*10)
		var j21 int
		for _, num1 := range m.PurchaseOptions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x4a
	}
	if m.ActivateType != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.ActivateType))
		i--
		dAtA[i] = 0x40
	}
	if m.Duration != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x38
	}
	if m.Timeliness != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.Timeliness))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Banner) > 0 {
		i -= len(m.Banner)
		copy(dAtA[i:], m.Banner)
		i = encodeVarintMoothlyCard(dAtA, i, uint64(len(m.Banner)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UnlockCondition) > 0 {
		dAtA24 := make([]byte, len(m.UnlockCondition)*10)
		var j23 int
		for _, num1 := range m.UnlockCondition {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintMoothlyCard(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x22
	}
	if m.ActivityId != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.ActivityId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Language1) > 0 {
		i -= len(m.Language1)
		copy(dAtA[i:], m.Language1)
		i = encodeVarintMoothlyCard(dAtA, i, uint64(len(m.Language1)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintMoothlyCard(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMoothlyCard(dAtA []byte, offset int, v uint64) int {
	offset -= sovMoothlyCard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *MoonthlyCardInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.StartTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("start_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.StartTime))
		needWriteComma = true
	}
	if m.ReceiveTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("receive_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ReceiveTimes))
		needWriteComma = true
	}
	if m.RemainingTimes != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("remaining_times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RemainingTimes))
		needWriteComma = true
	}
	if m.CardType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("card_type")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CardType))
		needWriteComma = true
	}
	if m.CanReceive {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("can_receive")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.CanReceive)
		needWriteComma = true
	}
	if m.IsSub {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_sub")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsSub)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MoonthlyCardPurchaseTimes) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("detail_times")
	w.RawByte('"')
	w.RawByte(':')
	if m.DetailTimes == nil {
		w.RawString("null")
	} else if len(m.DetailTimes) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDetailTimes := len(m.DetailTimes)
		for k, v := range m.DetailTimes {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlDetailTimes--
			if mlDetailTimes != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MoonthlyCardActivityInfo) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.ActivityId != 0 {
		w.RawByte('"')
		w.RawString("activity_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivityId))
		needWriteComma = true
	}
	if m.IsInvalid {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("is_invalid")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsInvalid)
		needWriteComma = true
	}
	if m.StartTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("start_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.StartTime))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("progress")
	w.RawByte('"')
	w.RawByte(':')
	if m.Progress == nil {
		w.RawString("null")
	} else if len(m.Progress) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlProgress := len(m.Progress)
		for k, v := range m.Progress {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlProgress--
			if mlProgress != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("invalid_cards")
	w.RawByte('"')
	w.RawByte(':')
	if m.InvalidCards == nil {
		w.RawString("null")
	} else if len(m.InvalidCards) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.InvalidCards {
			w.Int64(int64(v))
			if i != len(m.InvalidCards)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("can_activation_cards")
	w.RawByte('"')
	w.RawByte(':')
	if m.CanActivationCards == nil {
		w.RawString("null")
	} else if len(m.CanActivationCards) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.CanActivationCards {
			w.Int64(int64(v))
			if i != len(m.CanActivationCards)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("activation_cards")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActivationCards == nil {
		w.RawString("null")
	} else if len(m.ActivationCards) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlActivationCards := len(m.ActivationCards)
		for k, v := range m.ActivationCards {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlActivationCards--
			if mlActivationCards != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("last_login_time")
	w.RawByte('"')
	w.RawByte(':')
	if m.LastLoginTime == nil {
		w.RawString("null")
	} else if len(m.LastLoginTime) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlLastLoginTime := len(m.LastLoginTime)
		for k, v := range m.LastLoginTime {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlLastLoginTime--
			if mlLastLoginTime != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("purchase_times")
	w.RawByte('"')
	w.RawByte(':')
	if m.PurchaseTimes == nil {
		w.RawString("null")
	} else if len(m.PurchaseTimes) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlPurchaseTimes := len(m.PurchaseTimes)
		for k, v := range m.PurchaseTimes {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlPurchaseTimes--
			if mlPurchaseTimes != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MoonthlyCardProgress) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("can_activation_cards")
	w.RawByte('"')
	w.RawByte(':')
	if m.CanActivationCards == nil {
		w.RawString("null")
	} else if len(m.CanActivationCards) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.CanActivationCards {
			w.Int64(int64(v))
			if i != len(m.CanActivationCards)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("progress")
	w.RawByte('"')
	w.RawByte(':')
	if m.Progress == nil {
		w.RawString("null")
	} else if len(m.Progress) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlProgress := len(m.Progress)
		for k, v := range m.Progress {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlProgress--
			if mlProgress != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MoonthlyCardCnf) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Language1 != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Language1")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Language1)
		needWriteComma = true
	}
	if m.ActivityId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ActivityId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivityId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("UnlockCondition")
	w.RawByte('"')
	w.RawByte(':')
	if m.UnlockCondition == nil {
		w.RawString("null")
	} else if len(m.UnlockCondition) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.UnlockCondition {
			w.Int64(int64(v))
			if i != len(m.UnlockCondition)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Banner != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Banner")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Banner)
		needWriteComma = true
	}
	if m.Timeliness != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Timeliness")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Timeliness))
		needWriteComma = true
	}
	if m.Duration != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Duration")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Duration))
		needWriteComma = true
	}
	if m.ActivateType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ActivateType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ActivateType))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("PurchaseOptions")
	w.RawByte('"')
	w.RawByte(':')
	if m.PurchaseOptions == nil {
		w.RawString("null")
	} else if len(m.PurchaseOptions) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.PurchaseOptions {
			w.Int64(int64(v))
			if i != len(m.PurchaseOptions)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("Price")
	w.RawByte('"')
	w.RawByte(':')
	if m.Price == nil {
		w.RawString("null")
	} else if len(m.Price) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Price {
			w.Int64(int64(v))
			if i != len(m.Price)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("FirstPrice")
	w.RawByte('"')
	w.RawByte(':')
	if m.FirstPrice == nil {
		w.RawString("null")
	} else if len(m.FirstPrice) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.FirstPrice {
			w.Int64(int64(v))
			if i != len(m.FirstPrice)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("ShowPrice")
	w.RawByte('"')
	w.RawByte(':')
	if m.ShowPrice == nil {
		w.RawString("null")
	} else if len(m.ShowPrice) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ShowPrice {
			w.Int64(int64(v))
			if i != len(m.ShowPrice)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.AveragePrice != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AveragePrice")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AveragePrice))
		needWriteComma = true
	}
	if m.Discount != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Discount")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Discount))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("DailyReward")
	w.RawByte('"')
	w.RawByte(':')
	if m.DailyReward == nil {
		w.RawString("null")
	} else if len(m.DailyReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.DailyReward {
			w.Int64(int64(v))
			if i != len(m.DailyReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("PurchaseReward")
	w.RawByte('"')
	w.RawByte(':')
	if m.PurchaseReward == nil {
		w.RawString("null")
	} else if len(m.PurchaseReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.PurchaseReward {
			w.Int64(int64(v))
			if i != len(m.PurchaseReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("RenewalReward")
	w.RawByte('"')
	w.RawByte(':')
	if m.RenewalReward == nil {
		w.RawString("null")
	} else if len(m.RenewalReward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.RenewalReward {
			w.Int64(int64(v))
			if i != len(m.RenewalReward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Value != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Value")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Value))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MoonthlyCardInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MoonthlyCardInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MoonthlyCardInfo) GoString() string {
	return m.String()
}

func (m *MoonthlyCardPurchaseTimes) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MoonthlyCardPurchaseTimes) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MoonthlyCardPurchaseTimes) GoString() string {
	return m.String()
}

func (m *MoonthlyCardActivityInfo) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MoonthlyCardActivityInfo) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MoonthlyCardActivityInfo) GoString() string {
	return m.String()
}

func (m *MoonthlyCardProgress) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MoonthlyCardProgress) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MoonthlyCardProgress) GoString() string {
	return m.String()
}

func (m *MoonthlyCardCnf) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MoonthlyCardCnf) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MoonthlyCardCnf) GoString() string {
	return m.String()
}

func (m *MoonthlyCardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMoothlyCard(uint64(m.Id))
	}
	if m.StartTime != 0 {
		n += 1 + sovMoothlyCard(uint64(m.StartTime))
	}
	if m.ReceiveTimes != 0 {
		n += 1 + sovMoothlyCard(uint64(m.ReceiveTimes))
	}
	if m.RemainingTimes != 0 {
		n += 1 + sovMoothlyCard(uint64(m.RemainingTimes))
	}
	if m.CardType != 0 {
		n += 1 + sovMoothlyCard(uint64(m.CardType))
	}
	if m.CanReceive {
		n += 2
	}
	if m.IsSub {
		n += 2
	}
	return n
}

func (m *MoonthlyCardPurchaseTimes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DetailTimes) > 0 {
		for k, v := range m.DetailTimes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMoothlyCard(uint64(k)) + 1 + sovMoothlyCard(uint64(v))
			n += mapEntrySize + 2 + sovMoothlyCard(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MoonthlyCardActivityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActivityId != 0 {
		n += 1 + sovMoothlyCard(uint64(m.ActivityId))
	}
	if m.IsInvalid {
		n += 2
	}
	if m.StartTime != 0 {
		n += 1 + sovMoothlyCard(uint64(m.StartTime))
	}
	if len(m.Progress) > 0 {
		for k, v := range m.Progress {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMoothlyCard(uint64(k)) + 1 + sovMoothlyCard(uint64(v))
			n += mapEntrySize + 1 + sovMoothlyCard(uint64(mapEntrySize))
		}
	}
	if len(m.InvalidCards) > 0 {
		l = 0
		for _, e := range m.InvalidCards {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.CanActivationCards) > 0 {
		l = 0
		for _, e := range m.CanActivationCards {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.ActivationCards) > 0 {
		for k, v := range m.ActivationCards {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMoothlyCard(uint64(l))
			}
			mapEntrySize := 1 + sovMoothlyCard(uint64(k)) + l
			n += mapEntrySize + 1 + sovMoothlyCard(uint64(mapEntrySize))
		}
	}
	if len(m.LastLoginTime) > 0 {
		for k, v := range m.LastLoginTime {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMoothlyCard(uint64(k)) + 1 + sovMoothlyCard(uint64(v))
			n += mapEntrySize + 1 + sovMoothlyCard(uint64(mapEntrySize))
		}
	}
	if len(m.PurchaseTimes) > 0 {
		for k, v := range m.PurchaseTimes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMoothlyCard(uint64(l))
			}
			mapEntrySize := 1 + sovMoothlyCard(uint64(k)) + l
			n += mapEntrySize + 1 + sovMoothlyCard(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MoonthlyCardProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanActivationCards) > 0 {
		l = 0
		for _, e := range m.CanActivationCards {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.Progress) > 0 {
		for k, v := range m.Progress {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMoothlyCard(uint64(k)) + 1 + sovMoothlyCard(uint64(v))
			n += mapEntrySize + 1 + sovMoothlyCard(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MoonthlyCardCnf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMoothlyCard(uint64(m.Id))
	}
	l = len(m.Language1)
	if l > 0 {
		n += 1 + l + sovMoothlyCard(uint64(l))
	}
	if m.ActivityId != 0 {
		n += 1 + sovMoothlyCard(uint64(m.ActivityId))
	}
	if len(m.UnlockCondition) > 0 {
		l = 0
		for _, e := range m.UnlockCondition {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	l = len(m.Banner)
	if l > 0 {
		n += 1 + l + sovMoothlyCard(uint64(l))
	}
	if m.Timeliness != 0 {
		n += 1 + sovMoothlyCard(uint64(m.Timeliness))
	}
	if m.Duration != 0 {
		n += 1 + sovMoothlyCard(uint64(m.Duration))
	}
	if m.ActivateType != 0 {
		n += 1 + sovMoothlyCard(uint64(m.ActivateType))
	}
	if len(m.PurchaseOptions) > 0 {
		l = 0
		for _, e := range m.PurchaseOptions {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.Price) > 0 {
		l = 0
		for _, e := range m.Price {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.FirstPrice) > 0 {
		l = 0
		for _, e := range m.FirstPrice {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.ShowPrice) > 0 {
		l = 0
		for _, e := range m.ShowPrice {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if m.AveragePrice != 0 {
		n += 1 + sovMoothlyCard(uint64(m.AveragePrice))
	}
	if m.Discount != 0 {
		n += 1 + sovMoothlyCard(uint64(m.Discount))
	}
	if len(m.DailyReward) > 0 {
		l = 0
		for _, e := range m.DailyReward {
			l += sovMoothlyCard(uint64(e))
		}
		n += 1 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.PurchaseReward) > 0 {
		l = 0
		for _, e := range m.PurchaseReward {
			l += sovMoothlyCard(uint64(e))
		}
		n += 2 + sovMoothlyCard(uint64(l)) + l
	}
	if len(m.RenewalReward) > 0 {
		l = 0
		for _, e := range m.RenewalReward {
			l += sovMoothlyCard(uint64(e))
		}
		n += 2 + sovMoothlyCard(uint64(l)) + l
	}
	if m.Value != 0 {
		n += 2 + sovMoothlyCard(uint64(m.Value))
	}
	return n
}

func sovMoothlyCard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMoothlyCard(x uint64) (n int) {
	return sovMoothlyCard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MoonthlyCardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoothlyCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoonthlyCardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoonthlyCardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveTimes", wireType)
			}
			m.ReceiveTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingTimes", wireType)
			}
			m.RemainingTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingTimes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardType", wireType)
			}
			m.CardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardType |= MoonthlyCardType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanReceive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanReceive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSub", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSub = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMoothlyCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoonthlyCardPurchaseTimes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoothlyCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoonthlyCardPurchaseTimes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoonthlyCardPurchaseTimes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetailTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetailTimes == nil {
				m.DetailTimes = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoothlyCard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DetailTimes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoothlyCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoonthlyCardActivityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoothlyCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoonthlyCardActivityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoonthlyCardActivityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityId", wireType)
			}
			m.ActivityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInvalid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInvalid = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoothlyCard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Progress[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InvalidCards = append(m.InvalidCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InvalidCards) == 0 {
					m.InvalidCards = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InvalidCards = append(m.InvalidCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidCards", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CanActivationCards = append(m.CanActivationCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CanActivationCards) == 0 {
					m.CanActivationCards = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CanActivationCards = append(m.CanActivationCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CanActivationCards", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActivationCards == nil {
				m.ActivationCards = make(map[int64]*MoonthlyCardInfo)
			}
			var mapkey int64
			var mapvalue *MoonthlyCardInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MoonthlyCardInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoothlyCard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ActivationCards[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLoginTime == nil {
				m.LastLoginTime = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoothlyCard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LastLoginTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PurchaseTimes == nil {
				m.PurchaseTimes = make(map[int64]*MoonthlyCardPurchaseTimes)
			}
			var mapkey int64
			var mapvalue *MoonthlyCardPurchaseTimes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MoonthlyCardPurchaseTimes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoothlyCard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PurchaseTimes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoothlyCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoonthlyCardProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoothlyCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoonthlyCardProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoonthlyCardProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CanActivationCards = append(m.CanActivationCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CanActivationCards) == 0 {
					m.CanActivationCards = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CanActivationCards = append(m.CanActivationCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CanActivationCards", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoothlyCard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMoothlyCard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Progress[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoothlyCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoonthlyCardCnf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoothlyCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoonthlyCardCnf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoonthlyCardCnf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityId", wireType)
			}
			m.ActivityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnlockCondition = append(m.UnlockCondition, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnlockCondition) == 0 {
					m.UnlockCondition = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnlockCondition = append(m.UnlockCondition, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockCondition", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Banner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeliness", wireType)
			}
			m.Timeliness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeliness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivateType", wireType)
			}
			m.ActivateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivateType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PurchaseOptions = append(m.PurchaseOptions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PurchaseOptions) == 0 {
					m.PurchaseOptions = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PurchaseOptions = append(m.PurchaseOptions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseOptions", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Price = append(m.Price, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Price) == 0 {
					m.Price = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Price = append(m.Price, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FirstPrice = append(m.FirstPrice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FirstPrice) == 0 {
					m.FirstPrice = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FirstPrice = append(m.FirstPrice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPrice", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShowPrice = append(m.ShowPrice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShowPrice) == 0 {
					m.ShowPrice = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShowPrice = append(m.ShowPrice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrice", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AveragePrice", wireType)
			}
			m.AveragePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AveragePrice |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DailyReward = append(m.DailyReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DailyReward) == 0 {
					m.DailyReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DailyReward = append(m.DailyReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyReward", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PurchaseReward = append(m.PurchaseReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PurchaseReward) == 0 {
					m.PurchaseReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PurchaseReward = append(m.PurchaseReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseReward", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RenewalReward = append(m.RenewalReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoothlyCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMoothlyCard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RenewalReward) == 0 {
					m.RenewalReward = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoothlyCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RenewalReward = append(m.RenewalReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewalReward", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMoothlyCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMoothlyCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMoothlyCard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMoothlyCard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMoothlyCard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMoothlyCard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMoothlyCard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMoothlyCard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMoothlyCard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMoothlyCard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMoothlyCard = fmt.Errorf("proto: unexpected end of group")
)
