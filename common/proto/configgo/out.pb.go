// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/configgo/out.proto

package configgo

import (
	coin_server_common_buffer "github.com/ywh147906/load-test/common/buffer"
	coin_server_common_jwriter "github.com/ywh147906/load-test/common/jwriter"
	coin_server_common_msgcreate "github.com/ywh147906/load-test/common/msgcreate"
	coin_server_common_proto_jsonany "github.com/ywh147906/load-test/common/proto/jsonany"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_json_iterator_go "github.com/json-iterator/go"
	io "io"
	math "math"
	math_bits "math/bits"
	sync "sync"
	unsafe "unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RptInt64 struct {
	Slice []int64 `protobuf:"varint,1,rep,packed,name=slice,proto3" json:"slice,omitempty" rpt_int64`
}

func (m *RptInt64) Reset()      { *m = RptInt64{} }
func (*RptInt64) ProtoMessage() {}
func (*RptInt64) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{0}
}
func (m *RptInt64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RptInt64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RptInt64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RptInt64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RptInt64.Merge(m, src)
}
func (m *RptInt64) XXX_Size() int {
	return m.Size()
}
func (m *RptInt64) XXX_DiscardUnknown() {
	xxx_messageInfo_RptInt64.DiscardUnknown(m)
}

var xxx_messageInfo_RptInt64 proto.InternalMessageInfo

func (m *RptInt64) GetSlice() []int64 {
	if m != nil {
		return m.Slice
	}
	return nil
}

func (*RptInt64) XXX_MessageName() string {
	return "configgo.RptInt64"
}

type Tables struct {
	KeyValue          map[string]*KeyValue         `protobuf:"bytes,1,rep,name=key_value,json=keyValue,proto3" json:"key_value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attr              map[int64]*Attr              `protobuf:"bytes,2,rep,name=attr,proto3" json:"attr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AttrTrans         map[int64]*AttrTrans         `protobuf:"bytes,3,rep,name=attr_trans,json=attrTrans,proto3" json:"attr_trans,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Buff              map[int64]*Buff              `protobuf:"bytes,4,rep,name=buff,proto3" json:"buff,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	BuffEffect        map[int64]*BuffEffect        `protobuf:"bytes,5,rep,name=buff_effect,json=buffEffect,proto3" json:"buff_effect,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Drop              map[int64]*Drop              `protobuf:"bytes,6,rep,name=drop,proto3" json:"drop,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DropLists         map[int64]*DropLists         `protobuf:"bytes,7,rep,name=drop_lists,json=dropLists,proto3" json:"drop_lists,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Dungeon           map[int64]*Dungeon           `protobuf:"bytes,8,rep,name=dungeon,proto3" json:"dungeon,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	InhibitAtk        map[int64]*InhibitAtk        `protobuf:"bytes,9,rep,name=inhibit_atk,json=inhibitAtk,proto3" json:"inhibit_atk,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapScene          map[int64]*MapScene          `protobuf:"bytes,10,rep,name=map_scene,json=mapScene,proto3" json:"map_scene,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Mechanics         map[int64]*Mechanics         `protobuf:"bytes,11,rep,name=mechanics,proto3" json:"mechanics,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Medicament        map[int64]*Medicament        `protobuf:"bytes,12,rep,name=medicament,proto3" json:"medicament,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Monster           map[int64]*Monster           `protobuf:"bytes,13,rep,name=monster,proto3" json:"monster,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MonsterGroup      map[int64]*MonsterGroup      `protobuf:"bytes,14,rep,name=monster_group,json=monsterGroup,proto3" json:"monster_group,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Robot             map[int64]*Robot             `protobuf:"bytes,15,rep,name=robot,proto3" json:"robot,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RoguelikeArtifact map[int64]*RoguelikeArtifact `protobuf:"bytes,16,rep,name=roguelike_artifact,json=roguelikeArtifact,proto3" json:"roguelike_artifact,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RoguelikeDungeon  map[int64]*RoguelikeDungeon  `protobuf:"bytes,17,rep,name=roguelike_dungeon,json=roguelikeDungeon,proto3" json:"roguelike_dungeon,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RoleLv            map[int64]*RoleLv            `protobuf:"bytes,18,rep,name=role_lv,json=roleLv,proto3" json:"role_lv,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RoleReachDungeon  map[int64]*RoleReachDungeon  `protobuf:"bytes,19,rep,name=role_reach_dungeon,json=roleReachDungeon,proto3" json:"role_reach_dungeon,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RowHero           map[int64]*RowHero           `protobuf:"bytes,20,rep,name=row_hero,json=rowHero,proto3" json:"row_hero,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Skill             map[int64]*Skill             `protobuf:"bytes,21,rep,name=skill,proto3" json:"skill,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Summoned          map[int64]*Summoned          `protobuf:"bytes,22,rep,name=summoned,proto3" json:"summoned,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TempBag           map[int64]*TempBag           `protobuf:"bytes,23,rep,name=temp_bag,json=tempBag,proto3" json:"temp_bag,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Tables) Reset()      { *m = Tables{} }
func (*Tables) ProtoMessage() {}
func (*Tables) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{1}
}
func (m *Tables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tables.Merge(m, src)
}
func (m *Tables) XXX_Size() int {
	return m.Size()
}
func (m *Tables) XXX_DiscardUnknown() {
	xxx_messageInfo_Tables.DiscardUnknown(m)
}

var xxx_messageInfo_Tables proto.InternalMessageInfo

func (m *Tables) GetKeyValue() map[string]*KeyValue {
	if m != nil {
		return m.KeyValue
	}
	return nil
}

func (m *Tables) GetAttr() map[int64]*Attr {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *Tables) GetAttrTrans() map[int64]*AttrTrans {
	if m != nil {
		return m.AttrTrans
	}
	return nil
}

func (m *Tables) GetBuff() map[int64]*Buff {
	if m != nil {
		return m.Buff
	}
	return nil
}

func (m *Tables) GetBuffEffect() map[int64]*BuffEffect {
	if m != nil {
		return m.BuffEffect
	}
	return nil
}

func (m *Tables) GetDrop() map[int64]*Drop {
	if m != nil {
		return m.Drop
	}
	return nil
}

func (m *Tables) GetDropLists() map[int64]*DropLists {
	if m != nil {
		return m.DropLists
	}
	return nil
}

func (m *Tables) GetDungeon() map[int64]*Dungeon {
	if m != nil {
		return m.Dungeon
	}
	return nil
}

func (m *Tables) GetInhibitAtk() map[int64]*InhibitAtk {
	if m != nil {
		return m.InhibitAtk
	}
	return nil
}

func (m *Tables) GetMapScene() map[int64]*MapScene {
	if m != nil {
		return m.MapScene
	}
	return nil
}

func (m *Tables) GetMechanics() map[int64]*Mechanics {
	if m != nil {
		return m.Mechanics
	}
	return nil
}

func (m *Tables) GetMedicament() map[int64]*Medicament {
	if m != nil {
		return m.Medicament
	}
	return nil
}

func (m *Tables) GetMonster() map[int64]*Monster {
	if m != nil {
		return m.Monster
	}
	return nil
}

func (m *Tables) GetMonsterGroup() map[int64]*MonsterGroup {
	if m != nil {
		return m.MonsterGroup
	}
	return nil
}

func (m *Tables) GetRobot() map[int64]*Robot {
	if m != nil {
		return m.Robot
	}
	return nil
}

func (m *Tables) GetRoguelikeArtifact() map[int64]*RoguelikeArtifact {
	if m != nil {
		return m.RoguelikeArtifact
	}
	return nil
}

func (m *Tables) GetRoguelikeDungeon() map[int64]*RoguelikeDungeon {
	if m != nil {
		return m.RoguelikeDungeon
	}
	return nil
}

func (m *Tables) GetRoleLv() map[int64]*RoleLv {
	if m != nil {
		return m.RoleLv
	}
	return nil
}

func (m *Tables) GetRoleReachDungeon() map[int64]*RoleReachDungeon {
	if m != nil {
		return m.RoleReachDungeon
	}
	return nil
}

func (m *Tables) GetRowHero() map[int64]*RowHero {
	if m != nil {
		return m.RowHero
	}
	return nil
}

func (m *Tables) GetSkill() map[int64]*Skill {
	if m != nil {
		return m.Skill
	}
	return nil
}

func (m *Tables) GetSummoned() map[int64]*Summoned {
	if m != nil {
		return m.Summoned
	}
	return nil
}

func (m *Tables) GetTempBag() map[int64]*TempBag {
	if m != nil {
		return m.TempBag
	}
	return nil
}

func (*Tables) XXX_MessageName() string {
	return "configgo.Tables"
}

type KeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Type  string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *KeyValue) Reset()      { *m = KeyValue{} }
func (*KeyValue) ProtoMessage() {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{2}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *KeyValue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (*KeyValue) XXX_MessageName() string {
	return "configgo.KeyValue"
}

type Attr struct {
	Id           int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	AdvancedType int64 `protobuf:"varint,2,opt,name=AdvancedType,proto3" json:"advanced_type,omitempty"`
}

func (m *Attr) Reset()      { *m = Attr{} }
func (*Attr) ProtoMessage() {}
func (*Attr) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{3}
}
func (m *Attr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attr.Merge(m, src)
}
func (m *Attr) XXX_Size() int {
	return m.Size()
}
func (m *Attr) XXX_DiscardUnknown() {
	xxx_messageInfo_Attr.DiscardUnknown(m)
}

var xxx_messageInfo_Attr proto.InternalMessageInfo

func (m *Attr) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Attr) GetAdvancedType() int64 {
	if m != nil {
		return m.AdvancedType
	}
	return 0
}

func (*Attr) XXX_MessageName() string {
	return "configgo.Attr"
}

type AttrTrans struct {
	Id          int64   `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	AttrID      int64   `protobuf:"varint,2,opt,name=attrID,proto3" json:"attr_id,omitempty"`
	Transtype   int64   `protobuf:"varint,3,opt,name=transtype,proto3" json:"transtype,omitempty"`
	TransattrID int64   `protobuf:"varint,4,opt,name=transattrID,proto3" json:"transattr_id,omitempty"`
	Transnum    int64   `protobuf:"varint,5,opt,name=transnum,proto3" json:"transnum,omitempty"`
	Limithero   []int64 `protobuf:"varint,6,rep,packed,name=limithero,proto3" json:"limithero,omitempty"`
}

func (m *AttrTrans) Reset()      { *m = AttrTrans{} }
func (*AttrTrans) ProtoMessage() {}
func (*AttrTrans) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{4}
}
func (m *AttrTrans) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrTrans) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrTrans.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrTrans) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrTrans.Merge(m, src)
}
func (m *AttrTrans) XXX_Size() int {
	return m.Size()
}
func (m *AttrTrans) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrTrans.DiscardUnknown(m)
}

var xxx_messageInfo_AttrTrans proto.InternalMessageInfo

func (m *AttrTrans) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AttrTrans) GetAttrID() int64 {
	if m != nil {
		return m.AttrID
	}
	return 0
}

func (m *AttrTrans) GetTranstype() int64 {
	if m != nil {
		return m.Transtype
	}
	return 0
}

func (m *AttrTrans) GetTransattrID() int64 {
	if m != nil {
		return m.TransattrID
	}
	return 0
}

func (m *AttrTrans) GetTransnum() int64 {
	if m != nil {
		return m.Transnum
	}
	return 0
}

func (m *AttrTrans) GetLimithero() []int64 {
	if m != nil {
		return m.Limithero
	}
	return nil
}

func (*AttrTrans) XXX_MessageName() string {
	return "configgo.AttrTrans"
}

type Buff struct {
	Id                int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	BuffLv            int64           `protobuf:"varint,2,opt,name=BuffLv,proto3" json:"buff_lv,omitempty"`
	BuffConditionType int64           `protobuf:"varint,3,opt,name=BuffConditionType,proto3" json:"buff_condition_type,omitempty"`
	LogicId           int64           `protobuf:"varint,4,opt,name=LogicId,proto3" json:"logic_id,omitempty"`
	LogicArgs         string          `protobuf:"bytes,5,opt,name=LogicArgs,proto3" json:"logic_args,omitempty"`
	BuffEffectType    int64           `protobuf:"varint,6,opt,name=BuffEffectType,proto3" json:"buff_effect_type,omitempty"`
	BuffTime          int64           `protobuf:"varint,7,opt,name=BuffTime,proto3" json:"buff_time,omitempty"`
	BuffType          []int64         `protobuf:"varint,8,rep,packed,name=BuffType,proto3" json:"buff_type,omitempty"`
	AttrFixed         map[int64]int64 `protobuf:"bytes,9,rep,name=AttrFixed,proto3" json:"attr_fixed,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AttrPercentage    map[int64]int64 `protobuf:"bytes,10,rep,name=AttrPercentage,proto3" json:"attr_percentage,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Buff) Reset()      { *m = Buff{} }
func (*Buff) ProtoMessage() {}
func (*Buff) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{5}
}
func (m *Buff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Buff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Buff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Buff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Buff.Merge(m, src)
}
func (m *Buff) XXX_Size() int {
	return m.Size()
}
func (m *Buff) XXX_DiscardUnknown() {
	xxx_messageInfo_Buff.DiscardUnknown(m)
}

var xxx_messageInfo_Buff proto.InternalMessageInfo

func (m *Buff) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Buff) GetBuffLv() int64 {
	if m != nil {
		return m.BuffLv
	}
	return 0
}

func (m *Buff) GetBuffConditionType() int64 {
	if m != nil {
		return m.BuffConditionType
	}
	return 0
}

func (m *Buff) GetLogicId() int64 {
	if m != nil {
		return m.LogicId
	}
	return 0
}

func (m *Buff) GetLogicArgs() string {
	if m != nil {
		return m.LogicArgs
	}
	return ""
}

func (m *Buff) GetBuffEffectType() int64 {
	if m != nil {
		return m.BuffEffectType
	}
	return 0
}

func (m *Buff) GetBuffTime() int64 {
	if m != nil {
		return m.BuffTime
	}
	return 0
}

func (m *Buff) GetBuffType() []int64 {
	if m != nil {
		return m.BuffType
	}
	return nil
}

func (m *Buff) GetAttrFixed() map[int64]int64 {
	if m != nil {
		return m.AttrFixed
	}
	return nil
}

func (m *Buff) GetAttrPercentage() map[int64]int64 {
	if m != nil {
		return m.AttrPercentage
	}
	return nil
}

func (*Buff) XXX_MessageName() string {
	return "configgo.Buff"
}

type BuffEffect struct {
	Id          int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	AttributeID int64 `protobuf:"varint,2,opt,name=AttributeID,proto3" json:"attribute_id,omitempty"`
	LogicId     int64 `protobuf:"varint,3,opt,name=LogicId,proto3" json:"logic_id,omitempty"`
}

func (m *BuffEffect) Reset()      { *m = BuffEffect{} }
func (*BuffEffect) ProtoMessage() {}
func (*BuffEffect) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{6}
}
func (m *BuffEffect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuffEffect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuffEffect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuffEffect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuffEffect.Merge(m, src)
}
func (m *BuffEffect) XXX_Size() int {
	return m.Size()
}
func (m *BuffEffect) XXX_DiscardUnknown() {
	xxx_messageInfo_BuffEffect.DiscardUnknown(m)
}

var xxx_messageInfo_BuffEffect proto.InternalMessageInfo

func (m *BuffEffect) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuffEffect) GetAttributeID() int64 {
	if m != nil {
		return m.AttributeID
	}
	return 0
}

func (m *BuffEffect) GetLogicId() int64 {
	if m != nil {
		return m.LogicId
	}
	return 0
}

func (*BuffEffect) XXX_MessageName() string {
	return "configgo.BuffEffect"
}

type Drop struct {
	Id       int64               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Desc     string              `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	DropMini map[int64]*DropMini `protobuf:"bytes,3,rep,name=drop_mini,json=dropMini,proto3" json:"drop_mini,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Drop) Reset()      { *m = Drop{} }
func (*Drop) ProtoMessage() {}
func (*Drop) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{7}
}
func (m *Drop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Drop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Drop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Drop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Drop.Merge(m, src)
}
func (m *Drop) XXX_Size() int {
	return m.Size()
}
func (m *Drop) XXX_DiscardUnknown() {
	xxx_messageInfo_Drop.DiscardUnknown(m)
}

var xxx_messageInfo_Drop proto.InternalMessageInfo

func (m *Drop) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Drop) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *Drop) GetDropMini() map[int64]*DropMini {
	if m != nil {
		return m.DropMini
	}
	return nil
}

func (*Drop) XXX_MessageName() string {
	return "configgo.Drop"
}

type DropMini struct {
	DropId     int64           `protobuf:"varint,1,opt,name=drop_id,json=dropId,proto3" json:"drop_id,omitempty"`
	Id         int64           `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	ItemId     map[int64]int64 `protobuf:"bytes,3,rep,name=itemId,proto3" json:"item_id,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ItemWeight int64           `protobuf:"varint,4,opt,name=itemWeight,proto3" json:"item_weight,omitempty"`
}

func (m *DropMini) Reset()      { *m = DropMini{} }
func (*DropMini) ProtoMessage() {}
func (*DropMini) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{8}
}
func (m *DropMini) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropMini) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropMini.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropMini) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropMini.Merge(m, src)
}
func (m *DropMini) XXX_Size() int {
	return m.Size()
}
func (m *DropMini) XXX_DiscardUnknown() {
	xxx_messageInfo_DropMini.DiscardUnknown(m)
}

var xxx_messageInfo_DropMini proto.InternalMessageInfo

func (m *DropMini) GetDropId() int64 {
	if m != nil {
		return m.DropId
	}
	return 0
}

func (m *DropMini) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DropMini) GetItemId() map[int64]int64 {
	if m != nil {
		return m.ItemId
	}
	return nil
}

func (m *DropMini) GetItemWeight() int64 {
	if m != nil {
		return m.ItemWeight
	}
	return 0
}

func (*DropMini) XXX_MessageName() string {
	return "configgo.DropMini"
}

type DropLists struct {
	Id            int64                    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DropListsMini map[int64]*DropListsMini `protobuf:"bytes,2,rep,name=drop_lists_mini,json=dropListsMini,proto3" json:"drop_lists_mini,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DropLists) Reset()      { *m = DropLists{} }
func (*DropLists) ProtoMessage() {}
func (*DropLists) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{9}
}
func (m *DropLists) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropLists) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropLists.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropLists) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropLists.Merge(m, src)
}
func (m *DropLists) XXX_Size() int {
	return m.Size()
}
func (m *DropLists) XXX_DiscardUnknown() {
	xxx_messageInfo_DropLists.DiscardUnknown(m)
}

var xxx_messageInfo_DropLists proto.InternalMessageInfo

func (m *DropLists) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DropLists) GetDropListsMini() map[int64]*DropListsMini {
	if m != nil {
		return m.DropListsMini
	}
	return nil
}

func (*DropLists) XXX_MessageName() string {
	return "configgo.DropLists"
}

type DropListsMini struct {
	DropListsId int64 `protobuf:"varint,1,opt,name=drop_lists_id,json=dropListsId,proto3" json:"drop_lists_id,omitempty"`
	Id          int64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	DropId      int64 `protobuf:"varint,3,opt,name=dropId,proto3" json:"drop_id,omitempty"`
	DropProb    int64 `protobuf:"varint,4,opt,name=dropProb,proto3" json:"drop_prob,omitempty"`
}

func (m *DropListsMini) Reset()      { *m = DropListsMini{} }
func (*DropListsMini) ProtoMessage() {}
func (*DropListsMini) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{10}
}
func (m *DropListsMini) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropListsMini) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropListsMini.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropListsMini) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropListsMini.Merge(m, src)
}
func (m *DropListsMini) XXX_Size() int {
	return m.Size()
}
func (m *DropListsMini) XXX_DiscardUnknown() {
	xxx_messageInfo_DropListsMini.DiscardUnknown(m)
}

var xxx_messageInfo_DropListsMini proto.InternalMessageInfo

func (m *DropListsMini) GetDropListsId() int64 {
	if m != nil {
		return m.DropListsId
	}
	return 0
}

func (m *DropListsMini) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DropListsMini) GetDropId() int64 {
	if m != nil {
		return m.DropId
	}
	return 0
}

func (m *DropListsMini) GetDropProb() int64 {
	if m != nil {
		return m.DropProb
	}
	return 0
}

func (*DropListsMini) XXX_MessageName() string {
	return "configgo.DropListsMini"
}

type Dungeon struct {
	Id               int64  `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	Times            int64  `protobuf:"varint,2,opt,name=Times,proto3" json:"times,omitempty"`
	PlayersLv        int64  `protobuf:"varint,3,opt,name=PlayersLv,proto3" json:"players_lv,omitempty"`
	CombatCap        int64  `protobuf:"varint,4,opt,name=CombatCap,proto3" json:"combat_cap,omitempty"`
	DungeonPlayerNum int64  `protobuf:"varint,5,opt,name=DungeonPlayerNum,proto3" json:"dungeon_player_num,omitempty"`
	MapBehaviorTree  string `protobuf:"bytes,6,opt,name=MapBehaviorTree,proto3" json:"map_behavior_tree,omitempty"`
}

func (m *Dungeon) Reset()      { *m = Dungeon{} }
func (*Dungeon) ProtoMessage() {}
func (*Dungeon) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{11}
}
func (m *Dungeon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dungeon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dungeon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dungeon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dungeon.Merge(m, src)
}
func (m *Dungeon) XXX_Size() int {
	return m.Size()
}
func (m *Dungeon) XXX_DiscardUnknown() {
	xxx_messageInfo_Dungeon.DiscardUnknown(m)
}

var xxx_messageInfo_Dungeon proto.InternalMessageInfo

func (m *Dungeon) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Dungeon) GetTimes() int64 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *Dungeon) GetPlayersLv() int64 {
	if m != nil {
		return m.PlayersLv
	}
	return 0
}

func (m *Dungeon) GetCombatCap() int64 {
	if m != nil {
		return m.CombatCap
	}
	return 0
}

func (m *Dungeon) GetDungeonPlayerNum() int64 {
	if m != nil {
		return m.DungeonPlayerNum
	}
	return 0
}

func (m *Dungeon) GetMapBehaviorTree() string {
	if m != nil {
		return m.MapBehaviorTree
	}
	return ""
}

func (*Dungeon) XXX_MessageName() string {
	return "configgo.Dungeon"
}

type InhibitAtk struct {
	Id        int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	AtkType   int64 `protobuf:"varint,2,opt,name=AtkType,proto3" json:"atk_type,omitempty"`
	DefType   int64 `protobuf:"varint,3,opt,name=DefType,proto3" json:"def_type,omitempty"`
	AtkEffect int64 `protobuf:"varint,4,opt,name=AtkEffect,proto3" json:"atk_effect,omitempty"`
	SkillId   int64 `protobuf:"varint,5,opt,name=SkillId,proto3" json:"skill_id,omitempty"`
}

func (m *InhibitAtk) Reset()      { *m = InhibitAtk{} }
func (*InhibitAtk) ProtoMessage() {}
func (*InhibitAtk) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{12}
}
func (m *InhibitAtk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InhibitAtk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InhibitAtk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InhibitAtk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InhibitAtk.Merge(m, src)
}
func (m *InhibitAtk) XXX_Size() int {
	return m.Size()
}
func (m *InhibitAtk) XXX_DiscardUnknown() {
	xxx_messageInfo_InhibitAtk.DiscardUnknown(m)
}

var xxx_messageInfo_InhibitAtk proto.InternalMessageInfo

func (m *InhibitAtk) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *InhibitAtk) GetAtkType() int64 {
	if m != nil {
		return m.AtkType
	}
	return 0
}

func (m *InhibitAtk) GetDefType() int64 {
	if m != nil {
		return m.DefType
	}
	return 0
}

func (m *InhibitAtk) GetAtkEffect() int64 {
	if m != nil {
		return m.AtkEffect
	}
	return 0
}

func (m *InhibitAtk) GetSkillId() int64 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (*InhibitAtk) XXX_MessageName() string {
	return "configgo.InhibitAtk"
}

type MapScene struct {
	Id                int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MapType           int64   `protobuf:"varint,2,opt,name=MapType,proto3" json:"map_type,omitempty"`
	CfgMap            string  `protobuf:"bytes,3,opt,name=CfgMap,proto3" json:"cfg_map,omitempty"`
	BinMap            string  `protobuf:"bytes,4,opt,name=BinMap,proto3" json:"bin_map,omitempty"`
	DungeonID         int64   `protobuf:"varint,5,opt,name=DungeonID,proto3" json:"dungeon_id,omitempty"`
	LevelMapID        int64   `protobuf:"varint,6,opt,name=LevelMapID,proto3" json:"level_map_id,omitempty"`
	RoguelikeID       int64   `protobuf:"varint,7,opt,name=RoguelikeID,proto3" json:"roguelike_id,omitempty"`
	GoldProfit        int64   `protobuf:"varint,8,opt,name=GoldProfit,proto3" json:"gold_profit,omitempty"`
	LineMaxPersonsNum int64   `protobuf:"varint,9,opt,name=LineMaxPersonsNum,proto3" json:"line_max_persons_num,omitempty"`
	MedicamentId      []int64 `protobuf:"varint,10,rep,packed,name=MedicamentId,proto3" json:"medicament_id,omitempty"`
}

func (m *MapScene) Reset()      { *m = MapScene{} }
func (*MapScene) ProtoMessage() {}
func (*MapScene) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{13}
}
func (m *MapScene) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapScene) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapScene.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapScene) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapScene.Merge(m, src)
}
func (m *MapScene) XXX_Size() int {
	return m.Size()
}
func (m *MapScene) XXX_DiscardUnknown() {
	xxx_messageInfo_MapScene.DiscardUnknown(m)
}

var xxx_messageInfo_MapScene proto.InternalMessageInfo

func (m *MapScene) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MapScene) GetMapType() int64 {
	if m != nil {
		return m.MapType
	}
	return 0
}

func (m *MapScene) GetCfgMap() string {
	if m != nil {
		return m.CfgMap
	}
	return ""
}

func (m *MapScene) GetBinMap() string {
	if m != nil {
		return m.BinMap
	}
	return ""
}

func (m *MapScene) GetDungeonID() int64 {
	if m != nil {
		return m.DungeonID
	}
	return 0
}

func (m *MapScene) GetLevelMapID() int64 {
	if m != nil {
		return m.LevelMapID
	}
	return 0
}

func (m *MapScene) GetRoguelikeID() int64 {
	if m != nil {
		return m.RoguelikeID
	}
	return 0
}

func (m *MapScene) GetGoldProfit() int64 {
	if m != nil {
		return m.GoldProfit
	}
	return 0
}

func (m *MapScene) GetLineMaxPersonsNum() int64 {
	if m != nil {
		return m.LineMaxPersonsNum
	}
	return 0
}

func (m *MapScene) GetMedicamentId() []int64 {
	if m != nil {
		return m.MedicamentId
	}
	return nil
}

func (*MapScene) XXX_MessageName() string {
	return "configgo.MapScene"
}

type Mechanics struct {
	Id            int64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Idx           int64       `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	ActiveBegin   []int64     `protobuf:"varint,3,rep,packed,name=active_begin,json=activeBegin,proto3" json:"active_begin,omitempty"`
	Circulate     []int64     `protobuf:"varint,4,rep,packed,name=circulate,proto3" json:"circulate,omitempty"`
	DamagePercent []int64     `protobuf:"varint,5,rep,packed,name=damage_percent,json=damagePercent,proto3" json:"damage_percent,omitempty"`
	DueTime       int64       `protobuf:"varint,6,opt,name=due_time,json=dueTime,proto3" json:"due_time,omitempty"`
	Value         []*RptInt64 `protobuf:"bytes,7,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *Mechanics) Reset()      { *m = Mechanics{} }
func (*Mechanics) ProtoMessage() {}
func (*Mechanics) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{14}
}
func (m *Mechanics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mechanics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mechanics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mechanics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mechanics.Merge(m, src)
}
func (m *Mechanics) XXX_Size() int {
	return m.Size()
}
func (m *Mechanics) XXX_DiscardUnknown() {
	xxx_messageInfo_Mechanics.DiscardUnknown(m)
}

var xxx_messageInfo_Mechanics proto.InternalMessageInfo

func (m *Mechanics) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Mechanics) GetIdx() int64 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Mechanics) GetActiveBegin() []int64 {
	if m != nil {
		return m.ActiveBegin
	}
	return nil
}

func (m *Mechanics) GetCirculate() []int64 {
	if m != nil {
		return m.Circulate
	}
	return nil
}

func (m *Mechanics) GetDamagePercent() []int64 {
	if m != nil {
		return m.DamagePercent
	}
	return nil
}

func (m *Mechanics) GetDueTime() int64 {
	if m != nil {
		return m.DueTime
	}
	return 0
}

func (m *Mechanics) GetValue() []*RptInt64 {
	if m != nil {
		return m.Value
	}
	return nil
}

func (*Mechanics) XXX_MessageName() string {
	return "configgo.Mechanics"
}

type Medicament struct {
	Id     int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	Level  int64 `protobuf:"varint,2,opt,name=Level,proto3" json:"level,omitempty"`
	Typ    int64 `protobuf:"varint,3,opt,name=Typ,proto3" json:"typ,omitempty"`
	CD     int64 `protobuf:"varint,4,opt,name=CD,proto3" json:"cd,omitempty"`
	BuffId int64 `protobuf:"varint,5,opt,name=BuffId,proto3" json:"buff_id,omitempty"`
	Limit  int64 `protobuf:"varint,6,opt,name=Limit,proto3" json:"limit,omitempty"`
}

func (m *Medicament) Reset()      { *m = Medicament{} }
func (*Medicament) ProtoMessage() {}
func (*Medicament) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{15}
}
func (m *Medicament) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Medicament) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Medicament.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Medicament) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Medicament.Merge(m, src)
}
func (m *Medicament) XXX_Size() int {
	return m.Size()
}
func (m *Medicament) XXX_DiscardUnknown() {
	xxx_messageInfo_Medicament.DiscardUnknown(m)
}

var xxx_messageInfo_Medicament proto.InternalMessageInfo

func (m *Medicament) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Medicament) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Medicament) GetTyp() int64 {
	if m != nil {
		return m.Typ
	}
	return 0
}

func (m *Medicament) GetCD() int64 {
	if m != nil {
		return m.CD
	}
	return 0
}

func (m *Medicament) GetBuffId() int64 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *Medicament) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (*Medicament) XXX_MessageName() string {
	return "configgo.Medicament"
}

type Monster struct {
	Id                int64           `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	MonsterType       int64           `protobuf:"varint,2,opt,name=MonsterType,proto3" json:"monster_type,omitempty"`
	MonsterAttackType int64           `protobuf:"varint,3,opt,name=MonsterAttackType,proto3" json:"monster_attack_type,omitempty"`
	AtKSkill          []int64         `protobuf:"varint,4,rep,packed,name=AtKSkill,proto3" json:"at_k_skill,omitempty"`
	SkillId           []int64         `protobuf:"varint,5,rep,packed,name=SkillId,proto3" json:"skill_id,omitempty"`
	BuffId            []int64         `protobuf:"varint,6,rep,packed,name=BuffId,proto3" json:"buff_id,omitempty"`
	Modle3DSize       int64           `protobuf:"varint,7,opt,name=Modle3dSize,proto3" json:"modle3d_size,omitempty"`
	Inhibit           []int64         `protobuf:"varint,8,rep,packed,name=Inhibit,proto3" json:"inhibit,omitempty"`
	LockRange         int64           `protobuf:"varint,9,opt,name=LockRange,proto3" json:"lock_range,omitempty"`
	PursuitRange      int64           `protobuf:"varint,10,opt,name=PursuitRange,proto3" json:"pursuit_range,omitempty"`
	DeathRefreshTime  int64           `protobuf:"varint,11,opt,name=DeathRefreshTime,proto3" json:"death_refresh_time,omitempty"`
	CorpseTime        int64           `protobuf:"varint,12,opt,name=CorpseTime,proto3" json:"corpse_time,omitempty"`
	Move              int64           `protobuf:"varint,13,opt,name=Move,proto3" json:"move,omitempty"`
	BeHitFlyParam     int64           `protobuf:"varint,14,opt,name=BeHitFlyParam,proto3" json:"be_hit_fly_param,omitempty"`
	BeRepulseParam    int64           `protobuf:"varint,15,opt,name=BeRepulseParam,proto3" json:"be_repulse_param,omitempty"`
	DeadItemsRange    int64           `protobuf:"varint,16,opt,name=DeadItemsRange,proto3" json:"dead_items_range,omitempty"`
	DropListId        int64           `protobuf:"varint,17,opt,name=DropListId,proto3" json:"drop_list_id,omitempty"`
	NumHpBar          int64           `protobuf:"varint,18,opt,name=NumHpBar,proto3" json:"num_hp_bar,omitempty"`
	ParameterQuality  map[int64]int64 `protobuf:"bytes,19,rep,name=ParameterQuality,proto3" json:"parameter_quality,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Monster) Reset()      { *m = Monster{} }
func (*Monster) ProtoMessage() {}
func (*Monster) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{16}
}
func (m *Monster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Monster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Monster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Monster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Monster.Merge(m, src)
}
func (m *Monster) XXX_Size() int {
	return m.Size()
}
func (m *Monster) XXX_DiscardUnknown() {
	xxx_messageInfo_Monster.DiscardUnknown(m)
}

var xxx_messageInfo_Monster proto.InternalMessageInfo

func (m *Monster) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Monster) GetMonsterType() int64 {
	if m != nil {
		return m.MonsterType
	}
	return 0
}

func (m *Monster) GetMonsterAttackType() int64 {
	if m != nil {
		return m.MonsterAttackType
	}
	return 0
}

func (m *Monster) GetAtKSkill() []int64 {
	if m != nil {
		return m.AtKSkill
	}
	return nil
}

func (m *Monster) GetSkillId() []int64 {
	if m != nil {
		return m.SkillId
	}
	return nil
}

func (m *Monster) GetBuffId() []int64 {
	if m != nil {
		return m.BuffId
	}
	return nil
}

func (m *Monster) GetModle3DSize() int64 {
	if m != nil {
		return m.Modle3DSize
	}
	return 0
}

func (m *Monster) GetInhibit() []int64 {
	if m != nil {
		return m.Inhibit
	}
	return nil
}

func (m *Monster) GetLockRange() int64 {
	if m != nil {
		return m.LockRange
	}
	return 0
}

func (m *Monster) GetPursuitRange() int64 {
	if m != nil {
		return m.PursuitRange
	}
	return 0
}

func (m *Monster) GetDeathRefreshTime() int64 {
	if m != nil {
		return m.DeathRefreshTime
	}
	return 0
}

func (m *Monster) GetCorpseTime() int64 {
	if m != nil {
		return m.CorpseTime
	}
	return 0
}

func (m *Monster) GetMove() int64 {
	if m != nil {
		return m.Move
	}
	return 0
}

func (m *Monster) GetBeHitFlyParam() int64 {
	if m != nil {
		return m.BeHitFlyParam
	}
	return 0
}

func (m *Monster) GetBeRepulseParam() int64 {
	if m != nil {
		return m.BeRepulseParam
	}
	return 0
}

func (m *Monster) GetDeadItemsRange() int64 {
	if m != nil {
		return m.DeadItemsRange
	}
	return 0
}

func (m *Monster) GetDropListId() int64 {
	if m != nil {
		return m.DropListId
	}
	return 0
}

func (m *Monster) GetNumHpBar() int64 {
	if m != nil {
		return m.NumHpBar
	}
	return 0
}

func (m *Monster) GetParameterQuality() map[int64]int64 {
	if m != nil {
		return m.ParameterQuality
	}
	return nil
}

func (*Monster) XXX_MessageName() string {
	return "configgo.Monster"
}

type MonsterGroup struct {
	Id        int64   `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	MonsterId []int64 `protobuf:"varint,2,rep,packed,name=MonsterId,proto3" json:"monster_id,omitempty"`
	AreaId    int64   `protobuf:"varint,3,opt,name=AreaId,proto3" json:"area_id,omitempty"`
}

func (m *MonsterGroup) Reset()      { *m = MonsterGroup{} }
func (*MonsterGroup) ProtoMessage() {}
func (*MonsterGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{17}
}
func (m *MonsterGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonsterGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonsterGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonsterGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonsterGroup.Merge(m, src)
}
func (m *MonsterGroup) XXX_Size() int {
	return m.Size()
}
func (m *MonsterGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_MonsterGroup.DiscardUnknown(m)
}

var xxx_messageInfo_MonsterGroup proto.InternalMessageInfo

func (m *MonsterGroup) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MonsterGroup) GetMonsterId() []int64 {
	if m != nil {
		return m.MonsterId
	}
	return nil
}

func (m *MonsterGroup) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (*MonsterGroup) XXX_MessageName() string {
	return "configgo.MonsterGroup"
}

type Robot struct {
	Id       int64           `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	ConfigId int64           `protobuf:"varint,2,opt,name=config_id,json=configId,proto3" json:"config_id,omitempty"`
	Attr     map[int64]int64 `protobuf:"bytes,3,rep,name=attr,proto3" json:"attr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SkillId  []int64         `protobuf:"varint,4,rep,packed,name=SkillId,proto3" json:"skill_id,omitempty"`
	BuffId   []int64         `protobuf:"varint,5,rep,packed,name=BuffId,proto3" json:"buff_id,omitempty"`
	Lv       int64           `protobuf:"varint,6,opt,name=lv,proto3" json:"lv,omitempty"`
}

func (m *Robot) Reset()      { *m = Robot{} }
func (*Robot) ProtoMessage() {}
func (*Robot) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{18}
}
func (m *Robot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Robot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Robot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Robot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Robot.Merge(m, src)
}
func (m *Robot) XXX_Size() int {
	return m.Size()
}
func (m *Robot) XXX_DiscardUnknown() {
	xxx_messageInfo_Robot.DiscardUnknown(m)
}

var xxx_messageInfo_Robot proto.InternalMessageInfo

func (m *Robot) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Robot) GetConfigId() int64 {
	if m != nil {
		return m.ConfigId
	}
	return 0
}

func (m *Robot) GetAttr() map[int64]int64 {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *Robot) GetSkillId() []int64 {
	if m != nil {
		return m.SkillId
	}
	return nil
}

func (m *Robot) GetBuffId() []int64 {
	if m != nil {
		return m.BuffId
	}
	return nil
}

func (m *Robot) GetLv() int64 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (*Robot) XXX_MessageName() string {
	return "configgo.Robot"
}

type RoguelikeArtifact struct {
	Id              int64   `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	QualityId       int64   `protobuf:"varint,2,opt,name=QualityId,proto3" json:"quality_id,omitempty"`
	Quality         int64   `protobuf:"varint,3,opt,name=Quality,proto3" json:"quality,omitempty"`
	OccupationFirst []int64 `protobuf:"varint,4,rep,packed,name=OccupationFirst,proto3" json:"occupation_first,omitempty"`
	Weight          int64   `protobuf:"varint,5,opt,name=Weight,proto3" json:"weight,omitempty"`
	AttrId          []int64 `protobuf:"varint,6,rep,packed,name=AttrId,proto3" json:"attr_id,omitempty"`
}

func (m *RoguelikeArtifact) Reset()      { *m = RoguelikeArtifact{} }
func (*RoguelikeArtifact) ProtoMessage() {}
func (*RoguelikeArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{19}
}
func (m *RoguelikeArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoguelikeArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoguelikeArtifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoguelikeArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoguelikeArtifact.Merge(m, src)
}
func (m *RoguelikeArtifact) XXX_Size() int {
	return m.Size()
}
func (m *RoguelikeArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_RoguelikeArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_RoguelikeArtifact proto.InternalMessageInfo

func (m *RoguelikeArtifact) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoguelikeArtifact) GetQualityId() int64 {
	if m != nil {
		return m.QualityId
	}
	return 0
}

func (m *RoguelikeArtifact) GetQuality() int64 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *RoguelikeArtifact) GetOccupationFirst() []int64 {
	if m != nil {
		return m.OccupationFirst
	}
	return nil
}

func (m *RoguelikeArtifact) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *RoguelikeArtifact) GetAttrId() []int64 {
	if m != nil {
		return m.AttrId
	}
	return nil
}

func (*RoguelikeArtifact) XXX_MessageName() string {
	return "configgo.RoguelikeArtifact"
}

type RoguelikeDungeon struct {
	Id                   int64                           `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	DungeonDay           int64                           `protobuf:"varint,2,opt,name=DungeonDay,proto3" json:"dungeon_day,omitempty"`
	BossCap              int64                           `protobuf:"varint,3,opt,name=BossCap,proto3" json:"boss_cap,omitempty"`
	BossMechanical       []int64                         `protobuf:"varint,4,rep,packed,name=BossMechanical,proto3" json:"boss_mechanical,omitempty"`
	Times                int64                           `protobuf:"varint,5,opt,name=Times,proto3" json:"times,omitempty"`
	DungeonLv            []int64                         `protobuf:"varint,6,rep,packed,name=DungeonLv,proto3" json:"dungeon_lv,omitempty"`
	DungeonSize          []int64                         `protobuf:"varint,7,rep,packed,name=DungeonSize,proto3" json:"dungeon_size,omitempty"`
	ResurrectionItem     map[int64]int64                 `protobuf:"bytes,8,rep,name=ResurrectionItem,proto3" json:"resurrection_item,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ResurrectionItemAdd  int64                           `protobuf:"varint,9,opt,name=ResurrectionItemAdd,proto3" json:"resurrection_item_add,omitempty"`
	ResurrectionItemMax  int64                           `protobuf:"varint,10,opt,name=ResurrectionItemMax,proto3" json:"resurrection_item_max,omitempty"`
	ResurrectionTime     int64                           `protobuf:"varint,11,opt,name=ResurrectionTime,proto3" json:"resurrection_time,omitempty"`
	ResurrectionTimeInc  int64                           `protobuf:"varint,12,opt,name=ResurrectionTimeInc,proto3" json:"resurrection_time_inc,omitempty"`
	ResurrectionTimeIMax int64                           `protobuf:"varint,13,opt,name=ResurrectionTimeIMax,proto3" json:"resurrection_time_i_max,omitempty"`
	DungeonRewardPro     int64                           `protobuf:"varint,14,opt,name=DungeonRewardPro,proto3" json:"dungeon_reward_pro,omitempty"`
	DungeonReward        map[int64]int64                 `protobuf:"bytes,15,rep,name=DungeonReward,proto3" json:"dungeon_reward,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DungeonRewardWei     []int64                         `protobuf:"varint,16,rep,packed,name=DungeonRewardWei,proto3" json:"dungeon_reward_wei,omitempty"`
	MapBehaviorTree      string                          `protobuf:"bytes,17,opt,name=MapBehaviorTree,proto3" json:"map_behavior_tree,omitempty"`
	RoguelikeDungeonRoom map[int64]*RoguelikeDungeonRoom `protobuf:"bytes,18,rep,name=roguelike_dungeon_room,json=roguelikeDungeonRoom,proto3" json:"roguelike_dungeon_room,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RoguelikeDungeon) Reset()      { *m = RoguelikeDungeon{} }
func (*RoguelikeDungeon) ProtoMessage() {}
func (*RoguelikeDungeon) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{20}
}
func (m *RoguelikeDungeon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoguelikeDungeon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoguelikeDungeon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoguelikeDungeon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoguelikeDungeon.Merge(m, src)
}
func (m *RoguelikeDungeon) XXX_Size() int {
	return m.Size()
}
func (m *RoguelikeDungeon) XXX_DiscardUnknown() {
	xxx_messageInfo_RoguelikeDungeon.DiscardUnknown(m)
}

var xxx_messageInfo_RoguelikeDungeon proto.InternalMessageInfo

func (m *RoguelikeDungeon) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoguelikeDungeon) GetDungeonDay() int64 {
	if m != nil {
		return m.DungeonDay
	}
	return 0
}

func (m *RoguelikeDungeon) GetBossCap() int64 {
	if m != nil {
		return m.BossCap
	}
	return 0
}

func (m *RoguelikeDungeon) GetBossMechanical() []int64 {
	if m != nil {
		return m.BossMechanical
	}
	return nil
}

func (m *RoguelikeDungeon) GetTimes() int64 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *RoguelikeDungeon) GetDungeonLv() []int64 {
	if m != nil {
		return m.DungeonLv
	}
	return nil
}

func (m *RoguelikeDungeon) GetDungeonSize() []int64 {
	if m != nil {
		return m.DungeonSize
	}
	return nil
}

func (m *RoguelikeDungeon) GetResurrectionItem() map[int64]int64 {
	if m != nil {
		return m.ResurrectionItem
	}
	return nil
}

func (m *RoguelikeDungeon) GetResurrectionItemAdd() int64 {
	if m != nil {
		return m.ResurrectionItemAdd
	}
	return 0
}

func (m *RoguelikeDungeon) GetResurrectionItemMax() int64 {
	if m != nil {
		return m.ResurrectionItemMax
	}
	return 0
}

func (m *RoguelikeDungeon) GetResurrectionTime() int64 {
	if m != nil {
		return m.ResurrectionTime
	}
	return 0
}

func (m *RoguelikeDungeon) GetResurrectionTimeInc() int64 {
	if m != nil {
		return m.ResurrectionTimeInc
	}
	return 0
}

func (m *RoguelikeDungeon) GetResurrectionTimeIMax() int64 {
	if m != nil {
		return m.ResurrectionTimeIMax
	}
	return 0
}

func (m *RoguelikeDungeon) GetDungeonRewardPro() int64 {
	if m != nil {
		return m.DungeonRewardPro
	}
	return 0
}

func (m *RoguelikeDungeon) GetDungeonReward() map[int64]int64 {
	if m != nil {
		return m.DungeonReward
	}
	return nil
}

func (m *RoguelikeDungeon) GetDungeonRewardWei() []int64 {
	if m != nil {
		return m.DungeonRewardWei
	}
	return nil
}

func (m *RoguelikeDungeon) GetMapBehaviorTree() string {
	if m != nil {
		return m.MapBehaviorTree
	}
	return ""
}

func (m *RoguelikeDungeon) GetRoguelikeDungeonRoom() map[int64]*RoguelikeDungeonRoom {
	if m != nil {
		return m.RoguelikeDungeonRoom
	}
	return nil
}

func (*RoguelikeDungeon) XXX_MessageName() string {
	return "configgo.RoguelikeDungeon"
}

type RoguelikeDungeonRoom struct {
	RoguelikeDungeonId int64       `protobuf:"varint,1,opt,name=roguelike_dungeon_id,json=roguelikeDungeonId,proto3" json:"roguelike_dungeon_id,omitempty"`
	Id                 int64       `protobuf:"varint,2,opt,name=Id,proto3" json:"id,omitempty"`
	RoomTyp            int64       `protobuf:"varint,3,opt,name=RoomTyp,proto3" json:"room_typ,omitempty"`
	Reward             []*RptInt64 `protobuf:"bytes,4,rep,name=Reward,proto3" json:"reward,omitempty"`
	RewardWeight       []int64     `protobuf:"varint,5,rep,packed,name=RewardWeight,proto3" json:"reward_weight,omitempty"`
}

func (m *RoguelikeDungeonRoom) Reset()      { *m = RoguelikeDungeonRoom{} }
func (*RoguelikeDungeonRoom) ProtoMessage() {}
func (*RoguelikeDungeonRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{21}
}
func (m *RoguelikeDungeonRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoguelikeDungeonRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoguelikeDungeonRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoguelikeDungeonRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoguelikeDungeonRoom.Merge(m, src)
}
func (m *RoguelikeDungeonRoom) XXX_Size() int {
	return m.Size()
}
func (m *RoguelikeDungeonRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_RoguelikeDungeonRoom.DiscardUnknown(m)
}

var xxx_messageInfo_RoguelikeDungeonRoom proto.InternalMessageInfo

func (m *RoguelikeDungeonRoom) GetRoguelikeDungeonId() int64 {
	if m != nil {
		return m.RoguelikeDungeonId
	}
	return 0
}

func (m *RoguelikeDungeonRoom) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoguelikeDungeonRoom) GetRoomTyp() int64 {
	if m != nil {
		return m.RoomTyp
	}
	return 0
}

func (m *RoguelikeDungeonRoom) GetReward() []*RptInt64 {
	if m != nil {
		return m.Reward
	}
	return nil
}

func (m *RoguelikeDungeonRoom) GetRewardWeight() []int64 {
	if m != nil {
		return m.RewardWeight
	}
	return nil
}

func (*RoguelikeDungeonRoom) XXX_MessageName() string {
	return "configgo.RoguelikeDungeonRoom"
}

type RoleLv struct {
	Id               int64           `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	AdvancedHero     int64           `protobuf:"varint,2,opt,name=AdvancedHero,proto3" json:"advanced_hero,omitempty"`
	AdvancedItem     map[int64]int64 `protobuf:"bytes,3,rep,name=AdvancedItem,proto3" json:"advanced_item,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CopyId           int64           `protobuf:"varint,4,opt,name=CopyId,proto3" json:"copy_id,omitempty"`
	LvHero           int64           `protobuf:"varint,5,opt,name=LvHero,proto3" json:"lv_hero,omitempty"`
	SmallLv          int64           `protobuf:"varint,6,opt,name=SmallLv,proto3" json:"small_lv,omitempty"`
	Exp              int64           `protobuf:"varint,7,opt,name=Exp,proto3" json:"exp,omitempty"`
	DivinationExp    int64           `protobuf:"varint,8,opt,name=DivinationExp,proto3" json:"divination_exp,omitempty"`
	DivinationWeight map[int64]int64 `protobuf:"bytes,9,rep,name=DivinationWeight,proto3" json:"divination_weight,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ParameterQuality map[int64]int64 `protobuf:"bytes,10,rep,name=ParameterQuality,proto3" json:"parameter_quality,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	PowerNum         int64           `protobuf:"varint,11,opt,name=PowerNum,proto3" json:"power_num,omitempty"`
	CompressLv       int64           `protobuf:"varint,12,opt,name=CompressLv,proto3" json:"compress_lv,omitempty"`
	SkillPowerNum    int64           `protobuf:"varint,13,opt,name=SkillPowerNum,proto3" json:"skill_power_num,omitempty"`
}

func (m *RoleLv) Reset()      { *m = RoleLv{} }
func (*RoleLv) ProtoMessage() {}
func (*RoleLv) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{22}
}
func (m *RoleLv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleLv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleLv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleLv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleLv.Merge(m, src)
}
func (m *RoleLv) XXX_Size() int {
	return m.Size()
}
func (m *RoleLv) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleLv.DiscardUnknown(m)
}

var xxx_messageInfo_RoleLv proto.InternalMessageInfo

func (m *RoleLv) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleLv) GetAdvancedHero() int64 {
	if m != nil {
		return m.AdvancedHero
	}
	return 0
}

func (m *RoleLv) GetAdvancedItem() map[int64]int64 {
	if m != nil {
		return m.AdvancedItem
	}
	return nil
}

func (m *RoleLv) GetCopyId() int64 {
	if m != nil {
		return m.CopyId
	}
	return 0
}

func (m *RoleLv) GetLvHero() int64 {
	if m != nil {
		return m.LvHero
	}
	return 0
}

func (m *RoleLv) GetSmallLv() int64 {
	if m != nil {
		return m.SmallLv
	}
	return 0
}

func (m *RoleLv) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *RoleLv) GetDivinationExp() int64 {
	if m != nil {
		return m.DivinationExp
	}
	return 0
}

func (m *RoleLv) GetDivinationWeight() map[int64]int64 {
	if m != nil {
		return m.DivinationWeight
	}
	return nil
}

func (m *RoleLv) GetParameterQuality() map[int64]int64 {
	if m != nil {
		return m.ParameterQuality
	}
	return nil
}

func (m *RoleLv) GetPowerNum() int64 {
	if m != nil {
		return m.PowerNum
	}
	return 0
}

func (m *RoleLv) GetCompressLv() int64 {
	if m != nil {
		return m.CompressLv
	}
	return 0
}

func (m *RoleLv) GetSkillPowerNum() int64 {
	if m != nil {
		return m.SkillPowerNum
	}
	return 0
}

func (*RoleLv) XXX_MessageName() string {
	return "configgo.RoleLv"
}

type RoleReachDungeon struct {
	Id               int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	Times            int64 `protobuf:"varint,2,opt,name=Times,proto3" json:"times,omitempty"`
	VictoryCondition int64 `protobuf:"varint,3,opt,name=VictoryCondition,proto3" json:"victory_condition,omitempty"`
	FailCondition    int64 `protobuf:"varint,4,opt,name=FailCondition,proto3" json:"fail_condition,omitempty"`
	MapSceneId       int64 `protobuf:"varint,5,opt,name=MapSceneId,proto3" json:"map_scene_id,omitempty"`
	BossId           int64 `protobuf:"varint,6,opt,name=BossId,proto3" json:"boss_id,omitempty"`
}

func (m *RoleReachDungeon) Reset()      { *m = RoleReachDungeon{} }
func (*RoleReachDungeon) ProtoMessage() {}
func (*RoleReachDungeon) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{23}
}
func (m *RoleReachDungeon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleReachDungeon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleReachDungeon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleReachDungeon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleReachDungeon.Merge(m, src)
}
func (m *RoleReachDungeon) XXX_Size() int {
	return m.Size()
}
func (m *RoleReachDungeon) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleReachDungeon.DiscardUnknown(m)
}

var xxx_messageInfo_RoleReachDungeon proto.InternalMessageInfo

func (m *RoleReachDungeon) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleReachDungeon) GetTimes() int64 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *RoleReachDungeon) GetVictoryCondition() int64 {
	if m != nil {
		return m.VictoryCondition
	}
	return 0
}

func (m *RoleReachDungeon) GetFailCondition() int64 {
	if m != nil {
		return m.FailCondition
	}
	return 0
}

func (m *RoleReachDungeon) GetMapSceneId() int64 {
	if m != nil {
		return m.MapSceneId
	}
	return 0
}

func (m *RoleReachDungeon) GetBossId() int64 {
	if m != nil {
		return m.BossId
	}
	return 0
}

func (*RoleReachDungeon) XXX_MessageName() string {
	return "configgo.RoleReachDungeon"
}

type RowHero struct {
	Id                 int64   `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	OriginID           int64   `protobuf:"varint,2,opt,name=OriginID,proto3" json:"origin_id,omitempty"`
	ArmsId             int64   `protobuf:"varint,3,opt,name=ArmsId,proto3" json:"arms_id,omitempty"`
	ArmorId            int64   `protobuf:"varint,4,opt,name=ArmorId,proto3" json:"armor_id,omitempty"`
	Modle3DSize        int64   `protobuf:"varint,5,opt,name=Modle3dSize,proto3" json:"modle3d_size,omitempty"`
	AtKSkill           []int64 `protobuf:"varint,6,rep,packed,name=AtKSkill,proto3" json:"at_k_skill,omitempty"`
	IntervalTime       int64   `protobuf:"varint,7,opt,name=IntervalTime,proto3" json:"interval_time,omitempty"`
	SkillId            []int64 `protobuf:"varint,8,rep,packed,name=SkillId,proto3" json:"skill_id,omitempty"`
	Inhibit            []int64 `protobuf:"varint,9,rep,packed,name=Inhibit,proto3" json:"inhibit,omitempty"`
	LockRange          int64   `protobuf:"varint,10,opt,name=LockRange,proto3" json:"lock_range,omitempty"`
	DeathAnimationTime int64   `protobuf:"varint,11,opt,name=DeathAnimationTime,proto3" json:"death_animation_time,omitempty"`
	Move               int64   `protobuf:"varint,12,opt,name=Move,proto3" json:"move,omitempty"`
	BeHitFlyParam      int64   `protobuf:"varint,13,opt,name=BeHitFlyParam,proto3" json:"be_hit_fly_param,omitempty"`
	BeRepulseParam     int64   `protobuf:"varint,14,opt,name=BeRepulseParam,proto3" json:"be_repulse_param,omitempty"`
}

func (m *RowHero) Reset()      { *m = RowHero{} }
func (*RowHero) ProtoMessage() {}
func (*RowHero) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{24}
}
func (m *RowHero) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowHero) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowHero.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowHero) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowHero.Merge(m, src)
}
func (m *RowHero) XXX_Size() int {
	return m.Size()
}
func (m *RowHero) XXX_DiscardUnknown() {
	xxx_messageInfo_RowHero.DiscardUnknown(m)
}

var xxx_messageInfo_RowHero proto.InternalMessageInfo

func (m *RowHero) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RowHero) GetOriginID() int64 {
	if m != nil {
		return m.OriginID
	}
	return 0
}

func (m *RowHero) GetArmsId() int64 {
	if m != nil {
		return m.ArmsId
	}
	return 0
}

func (m *RowHero) GetArmorId() int64 {
	if m != nil {
		return m.ArmorId
	}
	return 0
}

func (m *RowHero) GetModle3DSize() int64 {
	if m != nil {
		return m.Modle3DSize
	}
	return 0
}

func (m *RowHero) GetAtKSkill() []int64 {
	if m != nil {
		return m.AtKSkill
	}
	return nil
}

func (m *RowHero) GetIntervalTime() int64 {
	if m != nil {
		return m.IntervalTime
	}
	return 0
}

func (m *RowHero) GetSkillId() []int64 {
	if m != nil {
		return m.SkillId
	}
	return nil
}

func (m *RowHero) GetInhibit() []int64 {
	if m != nil {
		return m.Inhibit
	}
	return nil
}

func (m *RowHero) GetLockRange() int64 {
	if m != nil {
		return m.LockRange
	}
	return 0
}

func (m *RowHero) GetDeathAnimationTime() int64 {
	if m != nil {
		return m.DeathAnimationTime
	}
	return 0
}

func (m *RowHero) GetMove() int64 {
	if m != nil {
		return m.Move
	}
	return 0
}

func (m *RowHero) GetBeHitFlyParam() int64 {
	if m != nil {
		return m.BeHitFlyParam
	}
	return 0
}

func (m *RowHero) GetBeRepulseParam() int64 {
	if m != nil {
		return m.BeRepulseParam
	}
	return 0
}

func (*RowHero) XXX_MessageName() string {
	return "configgo.RowHero"
}

type Skill struct {
	Id             int64           `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	SkillBaseId    int64           `protobuf:"varint,2,opt,name=SkillBaseId,proto3" json:"skill_base_id,omitempty"`
	SkillView      string          `protobuf:"bytes,3,opt,name=SkillView,proto3" json:"skill_view,omitempty"`
	LogicId        int64           `protobuf:"varint,4,opt,name=LogicId,proto3" json:"logic_id,omitempty"`
	IsNomalSkill   bool            `protobuf:"varint,5,opt,name=IsNomalSkill,proto3" json:"is_nomal_skill,omitempty"`
	SkillWeight    int64           `protobuf:"varint,6,opt,name=SkillWeight,proto3" json:"skill_weight,omitempty"`
	SkillInterrupt bool            `protobuf:"varint,7,opt,name=SkillInterrupt,proto3" json:"skill_interrupt,omitempty"`
	AtkRange       int64           `protobuf:"varint,8,opt,name=AtkRange,proto3" json:"atk_range,omitempty"`
	SkillTarget    int64           `protobuf:"varint,9,opt,name=SkillTarget,proto3" json:"skill_target,omitempty"`
	Target         int64           `protobuf:"varint,10,opt,name=Target,proto3" json:"target,omitempty"`
	SkillCD        int64           `protobuf:"varint,11,opt,name=SkillCD,proto3" json:"skill_cd,omitempty"`
	SkillBaceDam   map[int64]int64 `protobuf:"bytes,12,rep,name=SkillBaceDam,proto3" json:"skill_bace_dam,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AtkAddition    map[int64]int64 `protobuf:"bytes,13,rep,name=AtkAddition,proto3" json:"atk_addition,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SkillAddBuff   string          `protobuf:"bytes,14,opt,name=SkillAddBuff,proto3" json:"skill_add_buff,omitempty"`
}

func (m *Skill) Reset()      { *m = Skill{} }
func (*Skill) ProtoMessage() {}
func (*Skill) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{25}
}
func (m *Skill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Skill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Skill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Skill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Skill.Merge(m, src)
}
func (m *Skill) XXX_Size() int {
	return m.Size()
}
func (m *Skill) XXX_DiscardUnknown() {
	xxx_messageInfo_Skill.DiscardUnknown(m)
}

var xxx_messageInfo_Skill proto.InternalMessageInfo

func (m *Skill) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Skill) GetSkillBaseId() int64 {
	if m != nil {
		return m.SkillBaseId
	}
	return 0
}

func (m *Skill) GetSkillView() string {
	if m != nil {
		return m.SkillView
	}
	return ""
}

func (m *Skill) GetLogicId() int64 {
	if m != nil {
		return m.LogicId
	}
	return 0
}

func (m *Skill) GetIsNomalSkill() bool {
	if m != nil {
		return m.IsNomalSkill
	}
	return false
}

func (m *Skill) GetSkillWeight() int64 {
	if m != nil {
		return m.SkillWeight
	}
	return 0
}

func (m *Skill) GetSkillInterrupt() bool {
	if m != nil {
		return m.SkillInterrupt
	}
	return false
}

func (m *Skill) GetAtkRange() int64 {
	if m != nil {
		return m.AtkRange
	}
	return 0
}

func (m *Skill) GetSkillTarget() int64 {
	if m != nil {
		return m.SkillTarget
	}
	return 0
}

func (m *Skill) GetTarget() int64 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *Skill) GetSkillCD() int64 {
	if m != nil {
		return m.SkillCD
	}
	return 0
}

func (m *Skill) GetSkillBaceDam() map[int64]int64 {
	if m != nil {
		return m.SkillBaceDam
	}
	return nil
}

func (m *Skill) GetAtkAddition() map[int64]int64 {
	if m != nil {
		return m.AtkAddition
	}
	return nil
}

func (m *Skill) GetSkillAddBuff() string {
	if m != nil {
		return m.SkillAddBuff
	}
	return ""
}

func (*Skill) XXX_MessageName() string {
	return "configgo.Skill"
}

type Summoned struct {
	Id           int64           `protobuf:"varint,1,opt,name=Id,proto3" json:"id,omitempty"`
	MonsterId    map[int64]int64 `protobuf:"bytes,2,rep,name=MonsterId,proto3" json:"monster_id,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MonsterAttr  map[int64]int64 `protobuf:"bytes,3,rep,name=MonsterAttr,proto3" json:"monster_attr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SurvivalTime map[int64]int64 `protobuf:"bytes,4,rep,name=SurvivalTime,proto3" json:"survival_time,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SummonedBuff []int64         `protobuf:"varint,5,rep,packed,name=SummonedBuff,proto3" json:"summoned_buff,omitempty"`
}

func (m *Summoned) Reset()      { *m = Summoned{} }
func (*Summoned) ProtoMessage() {}
func (*Summoned) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{26}
}
func (m *Summoned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Summoned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Summoned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Summoned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Summoned.Merge(m, src)
}
func (m *Summoned) XXX_Size() int {
	return m.Size()
}
func (m *Summoned) XXX_DiscardUnknown() {
	xxx_messageInfo_Summoned.DiscardUnknown(m)
}

var xxx_messageInfo_Summoned proto.InternalMessageInfo

func (m *Summoned) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Summoned) GetMonsterId() map[int64]int64 {
	if m != nil {
		return m.MonsterId
	}
	return nil
}

func (m *Summoned) GetMonsterAttr() map[int64]int64 {
	if m != nil {
		return m.MonsterAttr
	}
	return nil
}

func (m *Summoned) GetSurvivalTime() map[int64]int64 {
	if m != nil {
		return m.SurvivalTime
	}
	return nil
}

func (m *Summoned) GetSummonedBuff() []int64 {
	if m != nil {
		return m.SummonedBuff
	}
	return nil
}

func (*Summoned) XXX_MessageName() string {
	return "configgo.Summoned"
}

type TempBag struct {
	Id           int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TempBagLevel int64 `protobuf:"varint,2,opt,name=temp_bag_level,json=tempBagLevel,proto3" json:"temp_bag_level,omitempty"`
	RoleLevel    int64 `protobuf:"varint,3,opt,name=role_level,json=roleLevel,proto3" json:"role_level,omitempty"`
	ProfitUpper  int64 `protobuf:"varint,4,opt,name=profit_upper,json=profitUpper,proto3" json:"profit_upper,omitempty"`
}

func (m *TempBag) Reset()      { *m = TempBag{} }
func (*TempBag) ProtoMessage() {}
func (*TempBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_96ff00ade70c9f43, []int{27}
}
func (m *TempBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TempBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TempBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TempBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TempBag.Merge(m, src)
}
func (m *TempBag) XXX_Size() int {
	return m.Size()
}
func (m *TempBag) XXX_DiscardUnknown() {
	xxx_messageInfo_TempBag.DiscardUnknown(m)
}

var xxx_messageInfo_TempBag proto.InternalMessageInfo

func (m *TempBag) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TempBag) GetTempBagLevel() int64 {
	if m != nil {
		return m.TempBagLevel
	}
	return 0
}

func (m *TempBag) GetRoleLevel() int64 {
	if m != nil {
		return m.RoleLevel
	}
	return 0
}

func (m *TempBag) GetProfitUpper() int64 {
	if m != nil {
		return m.ProfitUpper
	}
	return 0
}

func (*TempBag) XXX_MessageName() string {
	return "configgo.TempBag"
}
func init() {
	proto.RegisterType((*RptInt64)(nil), "configgo.RptInt64")
	proto.RegisterType((*Tables)(nil), "configgo.Tables")
	proto.RegisterMapType((map[int64]*Attr)(nil), "configgo.Tables.AttrEntry")
	proto.RegisterMapType((map[int64]*AttrTrans)(nil), "configgo.Tables.AttrTransEntry")
	proto.RegisterMapType((map[int64]*BuffEffect)(nil), "configgo.Tables.BuffEffectEntry")
	proto.RegisterMapType((map[int64]*Buff)(nil), "configgo.Tables.BuffEntry")
	proto.RegisterMapType((map[int64]*Drop)(nil), "configgo.Tables.DropEntry")
	proto.RegisterMapType((map[int64]*DropLists)(nil), "configgo.Tables.DropListsEntry")
	proto.RegisterMapType((map[int64]*Dungeon)(nil), "configgo.Tables.DungeonEntry")
	proto.RegisterMapType((map[int64]*InhibitAtk)(nil), "configgo.Tables.InhibitAtkEntry")
	proto.RegisterMapType((map[string]*KeyValue)(nil), "configgo.Tables.KeyValueEntry")
	proto.RegisterMapType((map[int64]*MapScene)(nil), "configgo.Tables.MapSceneEntry")
	proto.RegisterMapType((map[int64]*Mechanics)(nil), "configgo.Tables.MechanicsEntry")
	proto.RegisterMapType((map[int64]*Medicament)(nil), "configgo.Tables.MedicamentEntry")
	proto.RegisterMapType((map[int64]*Monster)(nil), "configgo.Tables.MonsterEntry")
	proto.RegisterMapType((map[int64]*MonsterGroup)(nil), "configgo.Tables.MonsterGroupEntry")
	proto.RegisterMapType((map[int64]*Robot)(nil), "configgo.Tables.RobotEntry")
	proto.RegisterMapType((map[int64]*RoguelikeArtifact)(nil), "configgo.Tables.RoguelikeArtifactEntry")
	proto.RegisterMapType((map[int64]*RoguelikeDungeon)(nil), "configgo.Tables.RoguelikeDungeonEntry")
	proto.RegisterMapType((map[int64]*RoleLv)(nil), "configgo.Tables.RoleLvEntry")
	proto.RegisterMapType((map[int64]*RoleReachDungeon)(nil), "configgo.Tables.RoleReachDungeonEntry")
	proto.RegisterMapType((map[int64]*RowHero)(nil), "configgo.Tables.RowHeroEntry")
	proto.RegisterMapType((map[int64]*Skill)(nil), "configgo.Tables.SkillEntry")
	proto.RegisterMapType((map[int64]*Summoned)(nil), "configgo.Tables.SummonedEntry")
	proto.RegisterMapType((map[int64]*TempBag)(nil), "configgo.Tables.TempBagEntry")
	proto.RegisterType((*KeyValue)(nil), "configgo.KeyValue")
	proto.RegisterType((*Attr)(nil), "configgo.Attr")
	proto.RegisterType((*AttrTrans)(nil), "configgo.AttrTrans")
	proto.RegisterType((*Buff)(nil), "configgo.Buff")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Buff.AttrFixedEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Buff.AttrPercentageEntry")
	proto.RegisterType((*BuffEffect)(nil), "configgo.BuffEffect")
	proto.RegisterType((*Drop)(nil), "configgo.Drop")
	proto.RegisterMapType((map[int64]*DropMini)(nil), "configgo.Drop.DropMiniEntry")
	proto.RegisterType((*DropMini)(nil), "configgo.DropMini")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.DropMini.ItemIdEntry")
	proto.RegisterType((*DropLists)(nil), "configgo.DropLists")
	proto.RegisterMapType((map[int64]*DropListsMini)(nil), "configgo.DropLists.DropListsMiniEntry")
	proto.RegisterType((*DropListsMini)(nil), "configgo.DropListsMini")
	proto.RegisterType((*Dungeon)(nil), "configgo.Dungeon")
	proto.RegisterType((*InhibitAtk)(nil), "configgo.InhibitAtk")
	proto.RegisterType((*MapScene)(nil), "configgo.MapScene")
	proto.RegisterType((*Mechanics)(nil), "configgo.Mechanics")
	proto.RegisterType((*Medicament)(nil), "configgo.Medicament")
	proto.RegisterType((*Monster)(nil), "configgo.Monster")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Monster.ParameterQualityEntry")
	proto.RegisterType((*MonsterGroup)(nil), "configgo.MonsterGroup")
	proto.RegisterType((*Robot)(nil), "configgo.Robot")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Robot.AttrEntry")
	proto.RegisterType((*RoguelikeArtifact)(nil), "configgo.RoguelikeArtifact")
	proto.RegisterType((*RoguelikeDungeon)(nil), "configgo.RoguelikeDungeon")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.RoguelikeDungeon.DungeonRewardEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.RoguelikeDungeon.ResurrectionItemEntry")
	proto.RegisterMapType((map[int64]*RoguelikeDungeonRoom)(nil), "configgo.RoguelikeDungeon.RoguelikeDungeonRoomEntry")
	proto.RegisterType((*RoguelikeDungeonRoom)(nil), "configgo.RoguelikeDungeonRoom")
	proto.RegisterType((*RoleLv)(nil), "configgo.RoleLv")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.RoleLv.AdvancedItemEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.RoleLv.DivinationWeightEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.RoleLv.ParameterQualityEntry")
	proto.RegisterType((*RoleReachDungeon)(nil), "configgo.RoleReachDungeon")
	proto.RegisterType((*RowHero)(nil), "configgo.RowHero")
	proto.RegisterType((*Skill)(nil), "configgo.Skill")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Skill.AtkAdditionEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Skill.SkillBaceDamEntry")
	proto.RegisterType((*Summoned)(nil), "configgo.Summoned")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Summoned.MonsterAttrEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Summoned.MonsterIdEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "configgo.Summoned.SurvivalTimeEntry")
	proto.RegisterType((*TempBag)(nil), "configgo.TempBag")
}

func init() { proto.RegisterFile("proto/configgo/out.proto", fileDescriptor_96ff00ade70c9f43) }

var fileDescriptor_96ff00ade70c9f43 = []byte{
	// 4424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x7b, 0x4d, 0x6c, 0x1c, 0x47,
	0x76, 0xbf, 0x86, 0x9f, 0x33, 0x8f, 0x1f, 0x22, 0x4b, 0x94, 0x3c, 0xa6, 0x6d, 0x8e, 0x3c, 0xda,
	0xb5, 0xbd, 0x7f, 0x58, 0x94, 0x6c, 0x69, 0xed, 0xb5, 0xff, 0xd6, 0xda, 0x33, 0xa4, 0x64, 0x0d,
	0x44, 0x5a, 0x5a, 0x8a, 0xb6, 0xe1, 0x1c, 0xd2, 0x28, 0x76, 0xd7, 0x0c, 0x3b, 0xec, 0x9e, 0xee,
	0xed, 0xee, 0x19, 0x91, 0x0b, 0xe4, 0x92, 0xcb, 0x5e, 0x73, 0xcb, 0x21, 0x40, 0x80, 0xdc, 0x72,
	0xcf, 0x75, 0x6f, 0x41, 0x80, 0x3d, 0x6e, 0x2e, 0x81, 0x81, 0x04, 0x93, 0x44, 0x3e, 0x24, 0x98,
	0x20, 0x40, 0x10, 0xe4, 0x14, 0x04, 0x48, 0x50, 0xaf, 0xaa, 0xbb, 0xab, 0xaa, 0x7b, 0xa4, 0x19,
	0xc7, 0x17, 0x89, 0xfd, 0xea, 0xf7, 0x5e, 0x7d, 0xbd, 0x7a, 0x5f, 0x55, 0x03, 0xf5, 0x30, 0x0a,
	0x92, 0xe0, 0x96, 0x1d, 0xf4, 0xbb, 0x6e, 0xaf, 0x17, 0xdc, 0x0a, 0x06, 0xc9, 0x2e, 0x92, 0x48,
	0x35, 0xa5, 0x6d, 0x6f, 0xf5, 0x82, 0x5e, 0x20, 0x70, 0xfc, 0x2f, 0xd1, 0xde, 0xbc, 0x05, 0xd5,
	0xa3, 0x30, 0xe9, 0xf4, 0x93, 0x0f, 0xee, 0x92, 0x1b, 0xb0, 0x18, 0x7b, 0xae, 0xcd, 0xea, 0x95,
	0xeb, 0xf3, 0xef, 0xcc, 0xb7, 0xd7, 0xfe, 0x63, 0xd4, 0xa8, 0x45, 0x61, 0x62, 0xb9, 0xbc, 0xf5,
	0x48, 0xb4, 0x35, 0x7f, 0xbd, 0x0d, 0x4b, 0xc7, 0xf4, 0xc4, 0x63, 0x31, 0xf9, 0xff, 0x50, 0x3b,
	0x63, 0x17, 0xd6, 0x90, 0x7a, 0x03, 0xc1, 0xb3, 0xf2, 0xfe, 0xce, 0x6e, 0xda, 0xdf, 0xae, 0x00,
	0xed, 0x3e, 0x62, 0x17, 0x5f, 0x71, 0xc0, 0xfd, 0x7e, 0x12, 0x5d, 0x1c, 0x55, 0xcf, 0xe4, 0x27,
	0xd9, 0x85, 0x05, 0x9a, 0x24, 0x51, 0x7d, 0x0e, 0xf9, 0xb6, 0x0b, 0x7c, 0xad, 0x24, 0x89, 0x04,
	0x0f, 0xe2, 0xc8, 0xcf, 0x01, 0xf8, 0xff, 0x56, 0x12, 0xd1, 0x7e, 0x5c, 0x9f, 0x47, 0xae, 0x46,
	0x29, 0xd7, 0x31, 0x47, 0x08, 0xd6, 0x1a, 0x4d, 0xbf, 0x79, 0x7f, 0x27, 0x83, 0x6e, 0xb7, 0xbe,
	0x30, 0xa1, 0xbf, 0xf6, 0xa0, 0xdb, 0x95, 0xfd, 0x71, 0x1c, 0x69, 0xc1, 0x0a, 0xff, 0xdf, 0x62,
	0xdd, 0x2e, 0xb3, 0x93, 0xfa, 0x22, 0xb2, 0x5d, 0x2f, 0x67, 0x43, 0x88, 0x60, 0x86, 0x93, 0x8c,
	0xc0, 0xbb, 0x74, 0xa2, 0x20, 0xac, 0x2f, 0x4d, 0xe8, 0x72, 0x3f, 0x0a, 0x42, 0xd9, 0x25, 0xc7,
	0xf1, 0x29, 0xf2, 0xff, 0x2d, 0xcf, 0x8d, 0x93, 0xb8, 0xbe, 0x3c, 0x61, 0x8a, 0x9c, 0xeb, 0x80,
	0x23, 0xe4, 0x14, 0x9d, 0xf4, 0x9b, 0x7c, 0x08, 0xcb, 0xce, 0xa0, 0xdf, 0x63, 0x41, 0xbf, 0x5e,
	0x45, 0xe6, 0x37, 0x8a, 0xcc, 0xa2, 0x5d, 0xb0, 0xa6, 0x68, 0x3e, 0x57, 0xb7, 0x7f, 0xea, 0x9e,
	0xb8, 0x89, 0x45, 0x93, 0xb3, 0x7a, 0x6d, 0xc2, 0x5c, 0x3b, 0x02, 0xd3, 0x4a, 0xce, 0xe4, 0x5c,
	0xdd, 0x8c, 0xc0, 0x75, 0xc1, 0xa7, 0xa1, 0x15, 0xdb, 0xac, 0xcf, 0xea, 0x30, 0x41, 0x17, 0x0e,
	0x69, 0xf8, 0x94, 0x03, 0xa4, 0x2e, 0xf8, 0xf2, 0x93, 0xdc, 0x83, 0x9a, 0xcf, 0xec, 0x53, 0xda,
	0x77, 0xed, 0xb8, 0xbe, 0x32, 0x61, 0xde, 0x87, 0x29, 0x42, 0xce, 0x3b, 0xe3, 0x20, 0x9f, 0x01,
	0xf8, 0xcc, 0x71, 0x6d, 0xea, 0xb3, 0x7e, 0x52, 0x5f, 0x9d, 0x30, 0xfa, 0xc3, 0x0c, 0x22, 0x47,
	0x9f, 0xf3, 0xf0, 0x95, 0xf3, 0x83, 0x7e, 0x9c, 0xb0, 0xa8, 0xbe, 0x36, 0x61, 0xe5, 0x0e, 0x45,
	0xbb, 0x5c, 0x39, 0x89, 0x26, 0x9f, 0xc3, 0x9a, 0xfc, 0xd3, 0xea, 0x45, 0xc1, 0x20, 0xac, 0xaf,
	0x23, 0x7b, 0x73, 0x12, 0xfb, 0xe7, 0x1c, 0x24, 0x64, 0xac, 0xfa, 0x0a, 0x89, 0xbc, 0x07, 0x8b,
	0x51, 0x70, 0x12, 0x24, 0xf5, 0xcb, 0x28, 0xe0, 0xb5, 0x82, 0x80, 0x23, 0xde, 0x2a, 0x38, 0x05,
	0x92, 0x7c, 0x05, 0x24, 0x0a, 0x7a, 0x03, 0xe6, 0xb9, 0x67, 0xcc, 0xa2, 0x51, 0xe2, 0x76, 0xa9,
	0x9d, 0xd4, 0x37, 0x90, 0xff, 0xed, 0x12, 0x7e, 0x09, 0x6d, 0x49, 0xa4, 0x90, 0xb5, 0x19, 0x99,
	0x74, 0xf2, 0x14, 0x72, 0xa2, 0x95, 0x2a, 0xd4, 0x26, 0x8a, 0x7d, 0x6b, 0xb2, 0x58, 0x4d, 0xb3,
	0x36, 0x22, 0x83, 0x4c, 0x7e, 0x0a, 0xcb, 0x51, 0xe0, 0x31, 0xcb, 0x1b, 0xd6, 0x09, 0x8a, 0x7a,
	0xbd, 0x44, 0x94, 0xc7, 0x0e, 0x86, 0x42, 0xc0, 0x52, 0x84, 0x1f, 0xe4, 0x98, 0xcf, 0xd1, 0x63,
	0x56, 0xc4, 0xa8, 0x7d, 0x9a, 0x0d, 0xe6, 0xca, 0xc4, 0xc1, 0x78, 0xec, 0x88, 0x23, 0xcd, 0xc1,
	0xe8, 0x64, 0xf2, 0x33, 0xa8, 0x46, 0xc1, 0x33, 0xeb, 0x94, 0x45, 0x41, 0x7d, 0x6b, 0xc2, 0x7e,
	0x1f, 0x05, 0xcf, 0x1e, 0xb2, 0x28, 0x90, 0xfb, 0x1d, 0x89, 0x2f, 0xbe, 0x4d, 0xf1, 0x99, 0xeb,
	0x79, 0xf5, 0xab, 0x13, 0xb6, 0xe9, 0x29, 0x6f, 0x95, 0xdb, 0x84, 0x48, 0xf2, 0x31, 0x54, 0xe3,
	0x81, 0xef, 0x07, 0x7d, 0xe6, 0xd4, 0xaf, 0x4d, 0x38, 0x18, 0x4f, 0x25, 0x40, 0x1e, 0x8c, 0x14,
	0xcf, 0x07, 0x9a, 0x30, 0x3f, 0xb4, 0x4e, 0x68, 0xaf, 0xfe, 0xca, 0x84, 0x81, 0x1e, 0x33, 0x3f,
	0x6c, 0xd3, 0x9e, 0x1c, 0x68, 0x22, 0xbe, 0xb6, 0x1f, 0xc3, 0x9a, 0x66, 0x79, 0xc9, 0x06, 0xcc,
	0x9f, 0xb1, 0x8b, 0x7a, 0xe5, 0x7a, 0xe5, 0x9d, 0xda, 0x11, 0xff, 0x93, 0xbc, 0x03, 0x8b, 0xc2,
	0x74, 0xcf, 0x5d, 0xaf, 0xbc, 0xb3, 0xf2, 0x3e, 0xc9, 0x25, 0xa7, 0x9c, 0x47, 0x02, 0xf0, 0xf1,
	0xdc, 0xcf, 0x2a, 0xdb, 0x9f, 0x43, 0x2d, 0x33, 0xc9, 0xaa, 0xb0, 0x79, 0x21, 0xec, 0x47, 0xba,
	0xb0, 0xf5, 0x5c, 0x18, 0xe7, 0x52, 0x05, 0xfd, 0x02, 0xd6, 0x75, 0x2b, 0x5d, 0x22, 0xed, 0x27,
	0xba, 0xb4, 0x2b, 0xba, 0x34, 0x64, 0x35, 0xc6, 0x96, 0x99, 0xef, 0x99, 0xc6, 0xc6, 0xb9, 0x54,
	0x41, 0x4f, 0xe1, 0xb2, 0x61, 0xd0, 0x4b, 0xc4, 0xfd, 0x3f, 0x5d, 0xdc, 0x96, 0x2e, 0x4e, 0xf0,
	0x1a, 0xa3, 0xcb, 0x2c, 0xfd, 0x4c, 0xa3, 0xe3, 0x5c, 0xc6, 0xca, 0xe9, 0xc6, 0x7f, 0xa6, 0x95,
	0xcb, 0x58, 0x55, 0x91, 0x87, 0xb0, 0xaa, 0x9e, 0x95, 0x12, 0x81, 0x6f, 0xeb, 0x02, 0x37, 0x15,
	0x81, 0x82, 0xd1, 0x58, 0x3f, 0xc3, 0x49, 0xcc, 0xb4, 0x7e, 0x39, 0xaf, 0x2a, 0xf4, 0x31, 0xac,
	0x69, 0x8e, 0xa3, 0x44, 0xe4, 0x64, 0x55, 0x4e, 0x39, 0x8d, 0x75, 0xd4, 0x9d, 0xc9, 0x4c, 0xeb,
	0x98, 0xb1, 0x1a, 0x13, 0x37, 0xfc, 0xcb, 0x4c, 0x13, 0xcf, 0x79, 0x8d, 0xcd, 0x51, 0xbd, 0xce,
	0x4c, 0x9b, 0x23, 0x19, 0x55, 0x71, 0x5f, 0xc3, 0x66, 0xc1, 0x0b, 0x95, 0xc8, 0x7c, 0x57, 0x97,
	0x79, 0xad, 0x20, 0x13, 0xb9, 0x55, 0xc1, 0x1d, 0x80, 0xdc, 0x3b, 0x95, 0x48, 0xfc, 0xb1, 0x2e,
	0xf1, 0x72, 0x2e, 0x11, 0xd9, 0x54, 0x51, 0x14, 0xae, 0x95, 0x3b, 0xaa, 0x12, 0xb1, 0xef, 0xe9,
	0x62, 0x5f, 0x53, 0xc5, 0x1a, 0x22, 0xd4, 0x2e, 0x2c, 0xb8, 0x5a, 0xea, 0xb4, 0x4a, 0x7a, 0xb8,
	0xad, 0xf7, 0xb0, 0x5d, 0xd2, 0x43, 0xc9, 0x21, 0x78, 0x04, 0x2b, 0x8a, 0x2b, 0x2b, 0x11, 0xfb,
	0x96, 0x2e, 0x76, 0x43, 0x15, 0xcb, 0xf9, 0x0a, 0xa3, 0x2d, 0xf1, 0x6a, 0x33, 0x8e, 0x56, 0x97,
	0x60, 0x28, 0x99, 0xea, 0xea, 0x66, 0x52, 0x32, 0xc9, 0x68, 0xe8, 0x42, 0xee, 0x02, 0x67, 0xd2,
	0x05, 0x64, 0x33, 0xce, 0xbd, 0xe6, 0x17, 0x67, 0x3a, 0xf7, 0x29, 0xa7, 0x31, 0x55, 0xd5, 0x59,
	0xce, 0x34, 0x55, 0xc9, 0xa8, 0x88, 0x6b, 0xfe, 0x51, 0x05, 0xaa, 0xa9, 0xa7, 0x24, 0x37, 0x14,
	0xf7, 0xda, 0xde, 0x1c, 0x8f, 0x1a, 0x6b, 0x67, 0xec, 0xe2, 0xdd, 0xc0, 0x77, 0xb9, 0x43, 0x4e,
	0x2e, 0x4a, 0x8c, 0x4a, 0xad, 0x7d, 0x65, 0x3c, 0x6a, 0x5c, 0x46, 0x82, 0x02, 0x14, 0x08, 0xf2,
	0x16, 0x2c, 0x24, 0x17, 0x21, 0xab, 0xcf, 0x23, 0x92, 0x8c, 0x47, 0x8d, 0x75, 0xfe, 0xad, 0x00,
	0xb1, 0xbd, 0xe9, 0xc2, 0x02, 0x77, 0x89, 0xe4, 0x3a, 0xcc, 0x75, 0x1c, 0x31, 0x95, 0xf6, 0xc6,
	0x78, 0xd4, 0x58, 0x75, 0x1d, 0x05, 0x3b, 0xd7, 0x71, 0xc8, 0xa7, 0xb0, 0xda, 0x72, 0x86, 0xb4,
	0x6f, 0x33, 0xe7, 0x98, 0x4b, 0x9e, 0x43, 0xec, 0x6b, 0xe3, 0x51, 0xe3, 0x15, 0x2a, 0xe9, 0x96,
	0xd1, 0x85, 0xc6, 0xd0, 0xfc, 0xcd, 0x9c, 0x08, 0x01, 0x44, 0x3e, 0xf5, 0xf2, 0x0e, 0x6f, 0xc2,
	0x12, 0x4f, 0xbf, 0x3a, 0xfb, 0xb2, 0xab, 0xab, 0xe3, 0x51, 0x63, 0x13, 0x73, 0x38, 0x0d, 0x2a,
	0x41, 0xe4, 0xa7, 0x50, 0xc3, 0xdc, 0x2e, 0x9b, 0xf6, 0x7c, 0xfb, 0x95, 0xf1, 0xa8, 0x71, 0x25,
	0x23, 0x2a, 0x3c, 0x39, 0x92, 0x7c, 0x02, 0x2b, 0xf8, 0x21, 0xbb, 0x5a, 0x40, 0xc6, 0xed, 0xf1,
	0xa8, 0x71, 0x2d, 0x23, 0xeb, 0xfd, 0xa9, 0x70, 0xf2, 0x3e, 0x54, 0xf1, 0xb3, 0x3f, 0xf0, 0xeb,
	0x8b, 0xc8, 0x7a, 0x6d, 0x3c, 0x6a, 0x90, 0x94, 0xa6, 0xb0, 0x65, 0x38, 0x3e, 0x50, 0xcf, 0xf5,
	0xdd, 0x04, 0xc3, 0xc7, 0x25, 0x4c, 0x95, 0x71, 0xa0, 0x19, 0x51, 0x1d, 0x68, 0x46, 0x6c, 0xfe,
	0x7a, 0x09, 0x16, 0x78, 0x80, 0xc0, 0x57, 0xce, 0x7d, 0xc1, 0xca, 0xb9, 0xb8, 0x72, 0x1c, 0x79,
	0x30, 0x54, 0x57, 0x0e, 0xb3, 0x51, 0x6f, 0xa8, 0xae, 0x9c, 0x00, 0x91, 0xc7, 0xb0, 0xc9, 0xff,
	0xda, 0x0b, 0xfa, 0x8e, 0x9b, 0xb8, 0x41, 0xff, 0x38, 0x5f, 0xc1, 0x37, 0xc7, 0xa3, 0xc6, 0x1b,
	0xc8, 0x69, 0xa7, 0xad, 0xe6, 0x26, 0x17, 0x79, 0xc9, 0x6d, 0x58, 0x3e, 0x08, 0x7a, 0xae, 0xdd,
	0x71, 0xe4, 0x7a, 0xe2, 0xa2, 0x78, 0x9c, 0xa4, 0xaf, 0x65, 0x0a, 0x23, 0x1f, 0x40, 0x0d, 0xff,
	0x6c, 0x45, 0xbd, 0x18, 0x17, 0xb2, 0xd6, 0xae, 0x8f, 0x47, 0x8d, 0x2d, 0xc1, 0x43, 0xa3, 0x5e,
	0xac, 0x2e, 0x4a, 0x06, 0x25, 0x0f, 0x60, 0x3d, 0x0f, 0x9a, 0x70, 0xdc, 0x4b, 0xd8, 0xe1, 0xce,
	0x78, 0xd4, 0xd8, 0x56, 0xf2, 0x6f, 0x73, 0xd0, 0x06, 0x17, 0xb9, 0x03, 0x55, 0x4e, 0x39, 0x76,
	0x7d, 0x56, 0x5f, 0xce, 0x75, 0x07, 0x25, 0x24, 0xae, 0xaf, 0xb2, 0x66, 0xc0, 0x8c, 0x89, 0x77,
	0x5b, 0xcd, 0xf7, 0x51, 0x30, 0xe9, 0xfd, 0x65, 0x40, 0xf2, 0xa5, 0x38, 0x04, 0x0f, 0xdc, 0x73,
	0xe6, 0xc8, 0x4c, 0xf9, 0x0d, 0x3d, 0x02, 0xdc, 0xcd, 0xda, 0xd1, 0xcc, 0x88, 0x85, 0x40, 0x3d,
	0xec, 0x72, 0xa2, 0xba, 0x10, 0x19, 0x92, 0xb8, 0x22, 0x2a, 0x7e, 0xc2, 0x22, 0x9b, 0xf5, 0x13,
	0xda, 0x4b, 0x93, 0xe8, 0x66, 0x89, 0xec, 0x1c, 0x24, 0x3a, 0x78, 0x63, 0x3c, 0x6a, 0xbc, 0x8a,
	0x1d, 0x84, 0x59, 0x8b, 0xba, 0x56, 0x3a, 0xcf, 0xf6, 0x27, 0xa2, 0xab, 0x7c, 0x84, 0x25, 0x86,
	0x70, 0x4b, 0xb5, 0x54, 0xf3, 0xaa, 0x11, 0x6d, 0xc1, 0x95, 0x92, 0x31, 0xcc, 0x22, 0xa2, 0xf9,
	0x67, 0x15, 0x80, 0x7c, 0xff, 0xa6, 0xb0, 0x24, 0x9f, 0xc0, 0x0a, 0xef, 0xd3, 0x3d, 0x19, 0x24,
	0x2c, 0x33, 0x27, 0x78, 0xc6, 0x69, 0x4a, 0x36, 0xce, 0xb8, 0x02, 0x57, 0xb5, 0x79, 0x7e, 0x2a,
	0x6d, 0x6e, 0xfe, 0x7d, 0x05, 0x16, 0x78, 0xb8, 0x3c, 0xc5, 0x51, 0x7d, 0x0b, 0x16, 0x1c, 0x16,
	0xdb, 0xd2, 0xa2, 0xa3, 0x9d, 0xe6, 0xdf, 0xaa, 0x9d, 0xe6, 0xdf, 0xe4, 0x23, 0xc0, 0x42, 0x8d,
	0xe5, 0xbb, 0x7d, 0x57, 0x56, 0xaf, 0x5e, 0xd7, 0x63, 0x73, 0xfc, 0xe7, 0xd0, 0xed, 0xbb, 0x32,
	0x09, 0x74, 0xe4, 0x27, 0xf7, 0x83, 0x5a, 0xd3, 0x4c, 0x7e, 0x30, 0xe5, 0x54, 0xd7, 0xff, 0xcf,
	0xe7, 0xa0, 0x9a, 0xd2, 0xc9, 0x2e, 0x2c, 0xe3, 0xc0, 0xb2, 0x79, 0xa2, 0xb1, 0x91, 0x24, 0xd5,
	0xd8, 0x70, 0x52, 0xc7, 0x91, 0x4b, 0x32, 0xf7, 0x82, 0x25, 0x39, 0x84, 0x25, 0xfe, 0x89, 0xcb,
	0x6d, 0xa4, 0xbb, 0x69, 0xaf, 0xbb, 0x1d, 0x04, 0x08, 0xf5, 0xc5, 0x0e, 0x39, 0x87, 0xd1, 0xa1,
	0x10, 0x42, 0x3e, 0x02, 0xe0, 0x7f, 0x7d, 0xcd, 0xdc, 0xde, 0x69, 0x22, 0xed, 0xd1, 0xab, 0xe3,
	0x51, 0xe3, 0x2a, 0xb2, 0x3c, 0x43, 0xb2, 0xc2, 0xa6, 0x80, 0xb7, 0x3f, 0x82, 0x15, 0xa5, 0xa3,
	0x99, 0x74, 0xf4, 0xdb, 0x8a, 0xc8, 0xda, 0x44, 0x65, 0xed, 0xe5, 0x7a, 0xf0, 0x05, 0x5c, 0xce,
	0x6b, 0x77, 0x62, 0x97, 0xe7, 0xcc, 0x2a, 0x45, 0x26, 0x2f, 0xff, 0x2b, 0xdf, 0xef, 0x35, 0x47,
	0xa5, 0x6d, 0x7f, 0x03, 0xa4, 0x08, 0x2a, 0x99, 0xc1, 0x4d, 0x7d, 0xe7, 0x5f, 0x29, 0xe9, 0xcd,
	0xdc, 0xfe, 0xbf, 0xad, 0x08, 0x85, 0xca, 0x1a, 0xc9, 0xa7, 0xb0, 0xa6, 0x0c, 0x3e, 0x9b, 0x29,
	0xc6, 0x06, 0x5a, 0x83, 0x7a, 0xc4, 0xb2, 0xf1, 0x4e, 0xa5, 0x14, 0x37, 0x41, 0x2a, 0x90, 0x3c,
	0x83, 0x2f, 0xd1, 0xb2, 0x3b, 0x80, 0xfa, 0xff, 0x24, 0x0a, 0x4e, 0xe4, 0x96, 0xa3, 0x69, 0x46,
	0x86, 0x30, 0x0a, 0x4e, 0x54, 0xd3, 0x9c, 0x02, 0x9b, 0xff, 0x30, 0x07, 0xcb, 0x69, 0x89, 0xe7,
	0xe5, 0x46, 0xe5, 0x27, 0xb0, 0xc8, 0xbd, 0x40, 0x2c, 0x87, 0x8d, 0xc1, 0x18, 0x77, 0x15, 0xaa,
	0xa7, 0x12, 0x08, 0xee, 0xdd, 0x9e, 0x78, 0xf4, 0x82, 0x45, 0xf1, 0xc1, 0x50, 0x8e, 0x1f, 0x8d,
	0x7a, 0x28, 0x88, 0xba, 0x57, 0xce, 0xa1, 0x9c, 0x6f, 0x2f, 0xf0, 0x4f, 0x68, 0xb2, 0x47, 0x43,
	0x39, 0x0d, 0xe4, 0xb3, 0x91, 0x68, 0xd9, 0x34, 0x54, 0xf9, 0x32, 0x28, 0x39, 0x80, 0x0d, 0x39,
	0x0f, 0x21, 0xeb, 0x8b, 0x2c, 0x3a, 0xb9, 0x3e, 0x1e, 0x35, 0x5e, 0x97, 0x65, 0x30, 0x4b, 0x74,
	0x6f, 0xe9, 0x71, 0x4a, 0x81, 0x93, 0x74, 0xe0, 0xf2, 0x21, 0x0d, 0xdb, 0xec, 0x94, 0x0e, 0xdd,
	0x20, 0x3a, 0x8e, 0x98, 0x70, 0xb2, 0xb5, 0x76, 0x63, 0x3c, 0x6a, 0xbc, 0xe6, 0xd3, 0xd0, 0x3a,
	0x91, 0x6d, 0x56, 0x12, 0x31, 0xd5, 0x73, 0x98, 0x7c, 0xcd, 0xff, 0xae, 0x00, 0xe4, 0x49, 0xfa,
	0x14, 0x8b, 0x7c, 0x1b, 0x96, 0x5b, 0xc9, 0x99, 0x12, 0x6f, 0xa2, 0xed, 0xa5, 0xc9, 0x99, 0xe9,
	0x60, 0x53, 0x18, 0xe7, 0xd8, 0x67, 0x5d, 0x25, 0x84, 0x41, 0x0e, 0x87, 0x15, 0x5c, 0x72, 0x0a,
	0xe3, 0xab, 0xdc, 0x4a, 0xce, 0x84, 0x33, 0x51, 0x57, 0x99, 0xf7, 0x22, 0xa2, 0x07, 0xdd, 0xe5,
	0x4a, 0x28, 0xef, 0x09, 0x73, 0x8e, 0x8e, 0xa3, 0x86, 0x7e, 0x58, 0xb4, 0x33, 0xfc, 0x82, 0x84,
	0x35, 0x7f, 0xb3, 0x00, 0xd5, 0xb4, 0xa0, 0x30, 0x85, 0x4d, 0xb8, 0x0d, 0xcb, 0x87, 0x34, 0x34,
	0x27, 0xcf, 0x17, 0xdc, 0x9c, 0x8a, 0x84, 0xf1, 0x53, 0xb2, 0xd7, 0xed, 0x1d, 0xd2, 0x50, 0xc6,
	0xfd, 0x78, 0x4a, 0xec, 0x6e, 0xcf, 0xf2, 0x35, 0x55, 0x91, 0x20, 0x8c, 0x13, 0xdd, 0xfe, 0xa1,
	0x54, 0x2e, 0x09, 0x3f, 0x71, 0xfb, 0x26, 0x5c, 0x80, 0xf8, 0x42, 0x49, 0xe5, 0xe8, 0xec, 0xcb,
	0x29, 0xe3, 0x42, 0xa5, 0xfa, 0xa4, 0x4d, 0x20, 0x87, 0x92, 0x8f, 0x01, 0x0e, 0xd8, 0x90, 0x79,
	0x87, 0x34, 0xec, 0xec, 0xcb, 0x00, 0x0d, 0xbd, 0xaf, 0xc7, 0xa9, 0xbc, 0x33, 0x9d, 0x55, 0x41,
	0x73, 0xd7, 0x9d, 0xe5, 0xca, 0x9d, 0x7d, 0x19, 0x9b, 0x21, 0x73, 0x5e, 0x63, 0xd6, 0xed, 0x8a,
	0x02, 0xe7, 0xb6, 0xff, 0xf3, 0xc0, 0x73, 0x9e, 0x44, 0x41, 0xd7, 0x4d, 0xea, 0xd5, 0xdc, 0xf6,
	0xf7, 0x02, 0xcf, 0xe1, 0x86, 0xa0, 0xeb, 0x6a, 0xb6, 0x3f, 0x07, 0x93, 0x27, 0xb0, 0x79, 0xe0,
	0xf6, 0xd9, 0x21, 0x3d, 0x7f, 0xc2, 0xa2, 0x38, 0xe8, 0xc7, 0xfc, 0x10, 0xd5, 0x50, 0x42, 0x73,
	0x3c, 0x6a, 0xec, 0x78, 0x6e, 0x9f, 0x59, 0x3e, 0x3d, 0xe7, 0x31, 0x13, 0x6f, 0x36, 0x8e, 0x51,
	0x91, 0x99, 0x27, 0x50, 0x79, 0x9d, 0xa6, 0xe3, 0x60, 0x80, 0x26, 0x8d, 0x64, 0x7e, 0x95, 0xa0,
	0x4f, 0x46, 0x63, 0x68, 0xfe, 0xcf, 0x1c, 0xd4, 0xb2, 0xea, 0xd1, 0x14, 0xfa, 0x73, 0x03, 0xe6,
	0x5d, 0xe7, 0x5c, 0xea, 0x0e, 0xe6, 0x94, 0xae, 0x73, 0xae, 0xe6, 0x94, 0xae, 0x73, 0x4e, 0xee,
	0xc1, 0x2a, 0xb5, 0x13, 0x77, 0xc8, 0xac, 0x13, 0xd6, 0x73, 0xfb, 0xe8, 0x73, 0xd3, 0xe0, 0x48,
	0xa1, 0xab, 0x2b, 0x2c, 0xe8, 0x6d, 0x4e, 0xe6, 0xc9, 0x8c, 0xed, 0x46, 0xf6, 0xc0, 0xa3, 0x09,
	0xc3, 0xbb, 0x31, 0x69, 0x69, 0x33, 0xa2, 0xaa, 0x12, 0x19, 0x91, 0xec, 0xc1, 0xba, 0x43, 0x7d,
	0xda, 0x63, 0x69, 0xc8, 0x89, 0x17, 0x64, 0xf3, 0xed, 0xd7, 0xc7, 0xa3, 0x46, 0x5d, 0x6f, 0x51,
	0x04, 0xac, 0x89, 0x16, 0x19, 0x3b, 0x92, 0xf7, 0xa0, 0xea, 0x0c, 0x18, 0xc6, 0xe7, 0x52, 0xab,
	0xc4, 0x59, 0x97, 0x34, 0xf5, 0x80, 0x38, 0x03, 0x86, 0x21, 0xfb, 0xbd, 0xd4, 0xdd, 0x89, 0xdb,
	0x31, 0x25, 0xd0, 0x49, 0x6f, 0x31, 0x5f, 0x94, 0x55, 0x37, 0xff, 0xab, 0x02, 0x90, 0x6f, 0xc9,
	0x74, 0x4e, 0x02, 0x95, 0x59, 0x75, 0x12, 0xa8, 0xf5, 0xaa, 0x6c, 0x44, 0xf0, 0xdd, 0x3a, 0xbe,
	0x08, 0xa5, 0xd1, 0xc2, 0xdd, 0x4a, 0x2e, 0xd4, 0x53, 0xc8, 0x5b, 0x79, 0x8f, 0x7b, 0x69, 0x92,
	0x8a, 0x3d, 0xda, 0x5a, 0x8f, 0x7b, 0xfb, 0x69, 0xee, 0x97, 0x19, 0xa5, 0x3c, 0xf7, 0xd3, 0x1d,
	0xa5, 0x00, 0xe1, 0x00, 0x79, 0x8a, 0x29, 0x17, 0x50, 0x0c, 0x90, 0x13, 0xb4, 0x01, 0x72, 0x42,
	0xf3, 0xdf, 0x6a, 0xb0, 0x2c, 0x4b, 0x78, 0xd3, 0xc5, 0xdc, 0x12, 0xac, 0x18, 0x30, 0x54, 0xab,
	0xf4, 0xc2, 0xcb, 0x30, 0x62, 0x2a, 0x9c, 0xa7, 0xa4, 0xf2, 0xb3, 0x95, 0x24, 0xd4, 0x3e, 0x33,
	0x53, 0xd2, 0x54, 0x06, 0xc5, 0xd6, 0x42, 0x4a, 0x5a, 0xe0, 0x25, 0x77, 0xa1, 0xda, 0x4a, 0x1e,
	0xa1, 0x21, 0x96, 0x6a, 0x2a, 0x6d, 0xbc, 0x75, 0x66, 0xa1, 0xc9, 0x56, 0x23, 0x82, 0x14, 0xa9,
	0x9b, 0xf8, 0xf9, 0x29, 0x4c, 0xbc, 0xb2, 0xfc, 0x22, 0xb3, 0x7f, 0xc9, 0xf2, 0xe3, 0x2a, 0x39,
	0x1e, 0xbb, 0xe3, 0x3c, 0x75, 0x7f, 0xc5, 0x54, 0xf3, 0xe6, 0x0b, 0xb2, 0x15, 0xbb, 0xbf, 0x32,
	0x56, 0x29, 0x83, 0x93, 0x5b, 0xb0, 0x2c, 0xbd, 0xa9, 0xcc, 0x3f, 0x45, 0x28, 0x2c, 0x48, 0xea,
	0xe8, 0x24, 0x4a, 0xa4, 0xd9, 0xf6, 0xd9, 0x11, 0xed, 0xf7, 0x98, 0x34, 0x66, 0x32, 0xcd, 0xb6,
	0xcf, 0xac, 0x88, 0x53, 0xf5, 0x34, 0x5b, 0x42, 0xb9, 0xe9, 0x7a, 0x32, 0x88, 0xe2, 0x81, 0x9b,
	0x08, 0x56, 0xc8, 0xe3, 0xbb, 0x50, 0xd0, 0x0b, 0xdc, 0x1a, 0x03, 0x46, 0x24, 0x8c, 0x26, 0xa7,
	0x47, 0xac, 0x1b, 0xb1, 0xf8, 0x14, 0xf3, 0xec, 0x15, 0x25, 0x22, 0xe1, 0x6d, 0x56, 0x24, 0x1a,
	0xcd, 0xc3, 0x5b, 0xe0, 0xe4, 0x66, 0x7d, 0x2f, 0x88, 0xc2, 0x18, 0xcf, 0x74, 0x7d, 0x35, 0x37,
	0xeb, 0x36, 0x52, 0x4d, 0x01, 0x0a, 0x98, 0xe7, 0x5b, 0x87, 0xc1, 0x90, 0xd5, 0xd7, 0x90, 0x09,
	0xf3, 0x2d, 0x3f, 0x18, 0x6a, 0x75, 0x31, 0xde, 0x4e, 0xf6, 0x61, 0xad, 0xcd, 0x1e, 0xba, 0xc9,
	0x03, 0xef, 0xe2, 0x09, 0x8d, 0xa8, 0x5f, 0x5f, 0x57, 0xea, 0x0a, 0xcc, 0x3a, 0x75, 0x13, 0xab,
	0xeb, 0x5d, 0x58, 0x21, 0x6f, 0x53, 0x2d, 0x94, 0xc6, 0x84, 0xe5, 0x09, 0x76, 0xc4, 0xc2, 0x81,
	0x17, 0x33, 0x21, 0xe6, 0xb2, 0x26, 0x26, 0x12, 0x4d, 0x05, 0x31, 0x06, 0x17, 0x97, 0xb3, 0xcf,
	0xa8, 0xc3, 0x93, 0x91, 0x58, 0xec, 0xc0, 0x46, 0x2e, 0xc7, 0x61, 0xd4, 0xb1, 0x38, 0x67, 0x5c,
	0xd8, 0x04, 0x83, 0x8b, 0x7b, 0xe2, 0x34, 0x72, 0xef, 0x38, 0xf5, 0xcd, 0x5c, 0xdb, 0xb2, 0x28,
	0xdd, 0xf0, 0xc4, 0x39, 0x9a, 0x9f, 0xa0, 0x2f, 0x06, 0xfe, 0xc3, 0xb0, 0x4d, 0xa3, 0x3a, 0xc9,
	0x55, 0xa7, 0x3f, 0xf0, 0xad, 0xd3, 0xd0, 0x3a, 0xa1, 0x91, 0x7a, 0x82, 0x52, 0x24, 0x49, 0x60,
	0x03, 0xa7, 0xc0, 0x12, 0x16, 0xfd, 0x62, 0x40, 0x3d, 0x37, 0xb9, 0x90, 0xd7, 0xaf, 0x6f, 0x17,
	0x2e, 0x06, 0x76, 0x4d, 0xa4, 0xc8, 0xef, 0x30, 0xcc, 0x0c, 0xd3, 0x26, 0xeb, 0x97, 0xa2, 0x4d,
	0x55, 0x10, 0x93, 0x6f, 0x7b, 0x0f, 0xae, 0x96, 0xca, 0x9a, 0x29, 0x85, 0xfb, 0x93, 0x4a, 0x76,
	0x7f, 0x22, 0xee, 0xd8, 0x5f, 0x6e, 0xf4, 0x3e, 0x80, 0x9a, 0xe4, 0xe8, 0x38, 0x98, 0xbf, 0xc9,
	0x45, 0x4a, 0xcd, 0x95, 0x1e, 0x21, 0x65, 0x50, 0x6e, 0x35, 0x5a, 0x11, 0xa3, 0x7a, 0x76, 0x43,
	0x23, 0x46, 0x0d, 0xab, 0x21, 0x40, 0xcd, 0xd1, 0x1c, 0x2c, 0xe2, 0xd5, 0xc7, 0x14, 0x43, 0xba,
	0x0b, 0x35, 0xb1, 0xce, 0x56, 0x96, 0x61, 0x09, 0x07, 0x9d, 0x12, 0xd5, 0x6d, 0x13, 0xc4, 0x8e,
	0x43, 0x5a, 0xf2, 0x75, 0x8d, 0xc8, 0xc0, 0x5f, 0x35, 0x6e, 0x5c, 0xf2, 0xc7, 0x35, 0xe2, 0x04,
	0x71, 0xa8, 0x7a, 0x82, 0xf0, 0xc1, 0x8d, 0x62, 0x3b, 0x17, 0x66, 0xb5, 0x9d, 0x8b, 0xd3, 0xd8,
	0xce, 0xeb, 0x30, 0xe7, 0x0d, 0xa5, 0xdf, 0xc2, 0xb9, 0x6b, 0x69, 0xd4, 0x9c, 0x37, 0xdc, 0xfe,
	0xf0, 0xc5, 0x77, 0xce, 0x93, 0xb7, 0xfe, 0xaf, 0xe7, 0x60, 0xb3, 0x70, 0x09, 0x34, 0xdd, 0xfe,
	0x4b, 0x75, 0xeb, 0xa4, 0x8b, 0x8d, 0xfb, 0x2f, 0x75, 0xd6, 0xd8, 0xff, 0x0c, 0xca, 0x0d, 0x79,
	0x7a, 0x38, 0x14, 0x05, 0x28, 0x6a, 0x7a, 0x8a, 0x22, 0x0f, 0xe1, 0xf2, 0x63, 0xdb, 0x1e, 0x84,
	0x34, 0x71, 0x83, 0xfe, 0x03, 0x37, 0x8a, 0x13, 0xb9, 0xc8, 0x68, 0x11, 0x82, 0xac, 0xc9, 0xea,
	0xf2, 0x36, 0x35, 0x25, 0x33, 0xd8, 0xc8, 0xbb, 0xb0, 0x24, 0x4b, 0x23, 0x22, 0x5e, 0xd8, 0x1a,
	0x8f, 0x1a, 0x1b, 0x85, 0xaa, 0x88, 0xc4, 0xa0, 0xa2, 0x26, 0x49, 0xa4, 0xbb, 0xb7, 0x92, 0x9a,
	0xbc, 0x00, 0x35, 0xff, 0x75, 0x15, 0x36, 0xcc, 0xab, 0xae, 0x29, 0x96, 0xf1, 0x23, 0x00, 0x09,
	0xde, 0xa7, 0x17, 0x72, 0x1d, 0xd1, 0xbe, 0xa7, 0x99, 0x86, 0x43, 0x2f, 0x34, 0x2b, 0x95, 0x81,
	0xb9, 0xd6, 0xb5, 0x83, 0x38, 0xde, 0xa3, 0xa1, 0x9a, 0xfe, 0x9d, 0x04, 0x71, 0x6c, 0xa4, 0xcb,
	0x29, 0x8c, 0xdc, 0x87, 0x75, 0xfe, 0x67, 0x1a, 0x58, 0xd3, 0x34, 0x3e, 0xc0, 0xaa, 0x28, 0x32,
	0xfa, 0x59, 0x93, 0x66, 0xa2, 0x35, 0xa6, 0xbc, 0x1c, 0xb0, 0x38, 0x4d, 0x39, 0x40, 0x8e, 0xf8,
	0x60, 0x28, 0xd7, 0x51, 0xcb, 0xa3, 0xf4, 0x72, 0x40, 0x06, 0xe5, 0xc1, 0x82, 0xfc, 0x90, 0xc1,
	0x42, 0x16, 0xa9, 0xa7, 0x9c, 0x66, 0xb0, 0xa0, 0xc0, 0xc9, 0x1f, 0xc2, 0xc6, 0x11, 0x8b, 0x07,
	0x51, 0xc4, 0x6c, 0xbe, 0xfb, 0xdc, 0x2b, 0xc8, 0x67, 0x5e, 0xb7, 0x27, 0xdf, 0x4b, 0xee, 0x9a,
	0x2c, 0x8a, 0x49, 0x8e, 0x94, 0x26, 0xf4, 0x3f, 0xaa, 0x49, 0x36, 0xf9, 0xc8, 0x97, 0x70, 0xc5,
	0xa4, 0xb5, 0x1c, 0x47, 0x06, 0x21, 0x37, 0xc6, 0xa3, 0x46, 0xa3, 0x20, 0xcf, 0xa2, 0x8e, 0xaa,
	0x19, 0x65, 0xfc, 0x65, 0x62, 0x0f, 0xe9, 0xb9, 0x0c, 0x50, 0x26, 0x88, 0xf5, 0xe9, 0xf9, 0x8b,
	0xc4, 0x1e, 0xd2, 0x73, 0xf2, 0x48, 0x5f, 0x2c, 0x25, 0x5e, 0x29, 0x4e, 0xdd, 0x0c, 0x57, 0x4c,
	0x46, 0x73, 0x8c, 0x9c, 0xd6, 0xe9, 0xdb, 0x32, 0x6e, 0x29, 0x8e, 0x91, 0xcb, 0xb3, 0xdc, 0xbe,
	0x3d, 0x69, 0x8c, 0x92, 0x9f, 0x7c, 0x03, 0x5b, 0x05, 0x32, 0x9f, 0xbb, 0x08, 0x6d, 0x7e, 0x3c,
	0x1e, 0x35, 0xde, 0x2c, 0x91, 0x6b, 0xcc, 0xbe, 0x54, 0x84, 0x52, 0x40, 0x3a, 0x62, 0xcf, 0x68,
	0xc4, 0x73, 0x62, 0x19, 0x00, 0x69, 0x05, 0xa4, 0x08, 0x1b, 0x79, 0x1e, 0x5d, 0x52, 0x40, 0xca,
	0x38, 0xc9, 0x2f, 0x61, 0x4d, 0xa3, 0xc9, 0x37, 0x6a, 0x37, 0x5f, 0xa0, 0x76, 0x1a, 0x5e, 0xe8,
	0x9c, 0x48, 0x0d, 0xb5, 0x9e, 0xd5, 0xc0, 0x4b, 0xe3, 0x28, 0x4c, 0xe0, 0x6b, 0xe6, 0xe2, 0xcb,
	0xb6, 0xf2, 0x09, 0x3c, 0x63, 0xee, 0xc4, 0x09, 0x7c, 0xcd, 0xdc, 0xb2, 0x0a, 0xd8, 0xe6, 0xf7,
	0xab, 0x80, 0x91, 0x3f, 0x80, 0x6b, 0x85, 0xc7, 0x71, 0x56, 0x14, 0x04, 0xbe, 0x7c, 0xd6, 0x76,
	0xf7, 0x45, 0x67, 0xd1, 0x7c, 0x34, 0x10, 0x04, 0xe2, 0x3c, 0x1e, 0x6d, 0x45, 0x25, 0x4d, 0x3c,
	0x0a, 0x2a, 0x3d, 0xbe, 0x33, 0xdd, 0xd7, 0x7c, 0x06, 0xa4, 0xb8, 0x19, 0x33, 0x49, 0xe8, 0xc1,
	0xab, 0x13, 0x47, 0x5e, 0x22, 0xe8, 0xae, 0x5e, 0x91, 0xde, 0x79, 0xc1, 0xa3, 0x89, 0x20, 0xf0,
	0x55, 0xaf, 0xfd, 0x57, 0x73, 0xb0, 0x55, 0x86, 0x21, 0xc7, 0xb0, 0x55, 0x5c, 0xf4, 0xac, 0x78,
	0x82, 0xe5, 0x9c, 0xb2, 0x76, 0x65, 0x1f, 0x89, 0xb9, 0xc0, 0x22, 0xfe, 0xe8, 0xbc, 0xa0, 0x68,
	0x2d, 0xaa, 0x97, 0xbc, 0xff, 0x3c, 0xad, 0x47, 0x67, 0xc4, 0x77, 0xdb, 0xd2, 0x73, 0xfb, 0x14,
	0x46, 0x3e, 0x83, 0x25, 0x79, 0x46, 0x16, 0x26, 0x16, 0x28, 0xd0, 0x43, 0x17, 0x0e, 0x80, 0xe4,
	0xe3, 0xa9, 0x5a, 0xa6, 0xb8, 0xc2, 0xab, 0x67, 0x55, 0xa6, 0x5c, 0xdb, 0x75, 0xe7, 0xae, 0x31,
	0x34, 0xff, 0xb2, 0x0a, 0x4b, 0xe2, 0x1d, 0xc9, 0x6c, 0x8f, 0x02, 0x1e, 0xb2, 0x28, 0x28, 0x7d,
	0x14, 0x60, 0x5c, 0x69, 0x6b, 0x0c, 0xc4, 0xce, 0x05, 0xa0, 0x47, 0x9a, 0x37, 0x6f, 0x2d, 0xc5,
	0x50, 0x76, 0x55, 0x90, 0xb0, 0x07, 0x7a, 0x27, 0x86, 0xff, 0xd1, 0x84, 0x62, 0x59, 0x34, 0x08,
	0x2f, 0xb2, 0xeb, 0x68, 0x51, 0x16, 0x0d, 0x42, 0x23, 0x20, 0x93, 0x20, 0x0e, 0x3f, 0x18, 0xe2,
	0x74, 0x94, 0x12, 0x8a, 0x37, 0x34, 0x27, 0x22, 0x41, 0x18, 0xe8, 0xfa, 0xd4, 0xf3, 0x0e, 0x86,
	0x6a, 0x15, 0x2a, 0xe6, 0x24, 0xdd, 0x95, 0xa7, 0x30, 0x72, 0x03, 0xe6, 0xef, 0x9f, 0x87, 0x32,
	0xdb, 0xc7, 0x52, 0x0f, 0x3b, 0xd7, 0x4a, 0x3d, 0xf7, 0xcf, 0x43, 0xd2, 0x86, 0xb5, 0x7d, 0x77,
	0xe8, 0xf6, 0x31, 0x56, 0xe3, 0x70, 0x51, 0xbe, 0x14, 0x66, 0x30, 0x6b, 0xb0, 0x74, 0x4e, 0x9d,
	0x85, 0xc4, 0xb0, 0x91, 0x13, 0xa4, 0x42, 0xd4, 0xcc, 0x6b, 0x25, 0xb9, 0xc2, 0x26, 0x50, 0xf1,
	0xf4, 0x4a, 0x77, 0x05, 0xe5, 0x29, 0x74, 0xc0, 0x3b, 0x2d, 0xa4, 0x7c, 0x30, 0xa1, 0xd3, 0x1f,
	0x2a, 0xe3, 0x23, 0x77, 0xa0, 0xfa, 0x24, 0x78, 0x26, 0xae, 0x3a, 0x56, 0xf2, 0x2c, 0x27, 0xe4,
	0x34, 0xa3, 0x34, 0x9b, 0x01, 0x45, 0x1d, 0xc1, 0x0f, 0x23, 0x16, 0xc7, 0x07, 0x43, 0xbd, 0x8e,
	0x20, 0xa8, 0xfa, 0xfe, 0x29, 0x60, 0xb2, 0x07, 0x6b, 0x98, 0xb6, 0x64, 0x9d, 0x0a, 0xaf, 0x8b,
	0x41, 0xa3, 0xc8, 0x71, 0xca, 0xba, 0xd6, 0x79, 0xb6, 0x3f, 0x85, 0xcd, 0x82, 0x5e, 0xcf, 0x64,
	0x5a, 0xf7, 0xe0, 0x6a, 0xe9, 0xb6, 0xcd, 0x2a, 0xe4, 0xff, 0x9e, 0x2c, 0xff, 0xdd, 0x1c, 0x8f,
	0xf4, 0x8d, 0x77, 0xd2, 0x3f, 0xe8, 0x25, 0xda, 0x23, 0xd8, 0xf8, 0xca, 0xb5, 0x93, 0x20, 0xba,
	0xc8, 0x1e, 0x9b, 0x48, 0xab, 0x8a, 0xea, 0x32, 0x14, 0x6d, 0xf9, 0x3b, 0x15, 0x55, 0x5d, 0x4c,
	0x46, 0x7e, 0xb8, 0x1e, 0x50, 0xd7, 0xcb, 0x25, 0x2d, 0xe4, 0x87, 0xab, 0x4b, 0x5d, 0xaf, 0x54,
	0x8c, 0xce, 0x42, 0x3e, 0x06, 0x48, 0x2f, 0x73, 0xb2, 0x6a, 0xab, 0x28, 0xdd, 0xa5, 0x3f, 0x64,
	0x30, 0x8a, 0x29, 0x39, 0x1a, 0x53, 0xdd, 0x20, 0x8e, 0x31, 0x8f, 0xca, 0xab, 0xb4, 0x3c, 0xd9,
	0x30, 0x52, 0x5d, 0x04, 0x35, 0xff, 0x74, 0x89, 0x7b, 0x12, 0xf1, 0x84, 0xfc, 0xe5, 0x8b, 0x7a,
	0x07, 0xaa, 0x8f, 0x23, 0xb7, 0xe7, 0xf6, 0xb3, 0xb7, 0x0e, 0x78, 0x16, 0x02, 0xa4, 0x19, 0x19,
	0x7f, 0x0a, 0x14, 0x25, 0x08, 0x3f, 0x36, 0x4b, 0x10, 0x7e, 0x5c, 0x28, 0x41, 0x70, 0x10, 0x5e,
	0xcc, 0x45, 0x7e, 0x10, 0xe9, 0x4f, 0x7c, 0x28, 0x27, 0x19, 0xd9, 0xbd, 0x84, 0x99, 0xa5, 0xce,
	0xc5, 0xd9, 0x4a, 0x9d, 0x6a, 0xfd, 0x76, 0x69, 0xea, 0xfa, 0xed, 0xa7, 0xb0, 0xda, 0xe9, 0x27,
	0x2c, 0x1a, 0x52, 0x4f, 0x79, 0xda, 0x83, 0x9e, 0xc3, 0x95, 0x74, 0x33, 0x7c, 0xd7, 0x18, 0xd4,
	0x22, 0x46, 0x75, 0xba, 0x22, 0x86, 0x52, 0x93, 0xad, 0xcd, 0x5e, 0x93, 0x85, 0xe9, 0x6b, 0xb2,
	0x47, 0x40, 0xb0, 0x30, 0xda, 0xea, 0xbb, 0x3e, 0x35, 0x92, 0x14, 0x0c, 0x69, 0x44, 0x51, 0x95,
	0xa6, 0xcd, 0xe6, 0x44, 0x4b, 0xb8, 0xb3, 0xea, 0xe8, 0xea, 0xac, 0xd5, 0xd1, 0xb5, 0x1f, 0xa6,
	0x3a, 0xba, 0xfe, 0x7d, 0xaa, 0xa3, 0xcd, 0xff, 0x5c, 0x86, 0x45, 0xb1, 0xdf, 0x2f, 0x3f, 0x1b,
	0xf7, 0x60, 0x05, 0xa1, 0x6d, 0x1a, 0xb3, 0x2c, 0x7a, 0x43, 0x85, 0x10, 0x9b, 0x7a, 0x42, 0x63,
	0xf3, 0x42, 0x51, 0xc1, 0xf3, 0xcd, 0xc2, 0xcf, 0xaf, 0x5c, 0xf6, 0x4c, 0xde, 0xb1, 0xe2, 0x66,
	0x09, 0xe6, 0xa1, 0xcb, 0x9e, 0xa9, 0x9b, 0x95, 0x41, 0xbf, 0xc7, 0x8b, 0xb8, 0xcf, 0x60, 0xb5,
	0x13, 0x7f, 0x11, 0xf8, 0xd4, 0x13, 0x4a, 0xcf, 0xcf, 0x4b, 0x55, 0x18, 0x28, 0x37, 0xb6, 0xfa,
	0xbc, 0xa1, 0xa0, 0xf8, 0x1a, 0x07, 0x3f, 0x70, 0xf8, 0x87, 0xf4, 0xfb, 0xca, 0xbd, 0xab, 0x18,
	0x6d, 0xc1, 0x95, 0xab, 0x70, 0x72, 0x1f, 0xd6, 0x85, 0x4a, 0xf3, 0xe3, 0x10, 0x0d, 0xc2, 0x04,
	0x0f, 0x4f, 0x55, 0xf5, 0x70, 0x6e, 0xda, 0xa4, 0xee, 0x8d, 0xce, 0xc4, 0x6d, 0x51, 0x2b, 0x91,
	0xca, 0x5d, 0xcd, 0x6d, 0x11, 0x4d, 0x8a, 0xba, 0x9d, 0x01, 0xb3, 0x91, 0x1f, 0xd3, 0xa8, 0xc7,
	0x12, 0x59, 0x23, 0x50, 0x46, 0x9e, 0x20, 0xbd, 0x30, 0x72, 0x01, 0x27, 0xef, 0xc2, 0x92, 0x64,
	0x84, 0xbc, 0xa2, 0x55, 0x60, 0x91, 0x98, 0xec, 0x84, 0xef, 0xed, 0xcb, 0xb3, 0xa3, 0x9c, 0x70,
	0xbb, 0x78, 0xc2, 0xf7, 0xf6, 0x79, 0xc8, 0x2a, 0x55, 0xc2, 0x66, 0xfb, 0xd4, 0x97, 0x3f, 0x18,
	0x7b, 0xd3, 0x78, 0x89, 0xbc, 0xab, 0x62, 0x94, 0x0c, 0x36, 0x55, 0x33, 0x9b, 0x59, 0x8e, 0xa6,
	0xd5, 0x9a, 0x50, 0xf2, 0xfb, 0xb0, 0xd2, 0x4a, 0xce, 0x5a, 0x8e, 0x74, 0x4f, 0x6b, 0xe6, 0x8f,
	0xd2, 0x44, 0x1f, 0x0a, 0x44, 0x74, 0x21, 0x1f, 0xb5, 0x9d, 0x59, 0xd4, 0x29, 0xb8, 0x2f, 0x55,
	0x20, 0x57, 0x2f, 0x14, 0xd1, 0x72, 0x9c, 0xf6, 0xa0, 0xdb, 0xc5, 0x93, 0x57, 0x53, 0x47, 0x48,
	0x1d, 0xc7, 0x3a, 0x19, 0x74, 0xbb, 0x85, 0x11, 0x4a, 0x0e, 0x1e, 0xbc, 0x14, 0xa6, 0x38, 0x53,
	0xdc, 0xf1, 0x73, 0xd8, 0x30, 0xc7, 0x3f, 0x53, 0xc8, 0xf1, 0x37, 0x0b, 0x50, 0x4d, 0x9f, 0x69,
	0x4f, 0x71, 0xf2, 0xbf, 0x31, 0x6b, 0xf3, 0xfa, 0x9e, 0x49, 0x41, 0xbb, 0x19, 0x46, 0x79, 0x7c,
	0xf9, 0xb2, 0xf2, 0x3d, 0xcd, 0xee, 0x3a, 0x5b, 0x79, 0xd1, 0xfc, 0xc6, 0x64, 0xe1, 0x79, 0xf9,
	0x5c, 0xbb, 0x10, 0x35, 0xca, 0xe8, 0xaa, 0x4c, 0xc2, 0x60, 0xf5, 0xe9, 0x20, 0x1a, 0xba, 0xa9,
	0x27, 0x13, 0xe9, 0xe1, 0x8f, 0x4a, 0xfa, 0x50, 0x61, 0x4a, 0xa6, 0x14, 0x4b, 0x72, 0xc1, 0xdf,
	0xa9, 0x78, 0xee, 0x30, 0x53, 0x41, 0xa8, 0x16, 0x4a, 0xf6, 0x98, 0xfe, 0xa8, 0xac, 0xa8, 0x15,
	0x0a, 0xc3, 0xf6, 0x27, 0xb0, 0xae, 0xaf, 0xe0, 0xac, 0x2a, 0x61, 0x2e, 0xd1, 0x4c, 0xfc, 0x5c,
	0x27, 0xcd, 0xe9, 0xcf, 0xa4, 0x53, 0xff, 0x5c, 0x81, 0x65, 0xf9, 0x54, 0x7f, 0x8a, 0x07, 0x16,
	0x6d, 0x58, 0x4f, 0x7f, 0x5e, 0x67, 0x79, 0xca, 0x35, 0x3f, 0x1e, 0x23, 0xbd, 0x45, 0x5d, 0x30,
	0xf9, 0x1b, 0x3b, 0x71, 0xed, 0xff, 0x21, 0x80, 0xf8, 0x61, 0x23, 0xf2, 0x2b, 0x8f, 0xc3, 0x72,
	0xaa, 0xaa, 0x74, 0xf8, 0xbb, 0x46, 0x64, 0xbc, 0x07, 0xab, 0xe2, 0x01, 0x8b, 0x35, 0x08, 0x43,
	0x16, 0xa9, 0x2f, 0xd7, 0x55, 0xba, 0xaa, 0x50, 0x82, 0xfe, 0x25, 0x27, 0xb7, 0x1f, 0x7f, 0xfb,
	0x4f, 0x3b, 0x97, 0xfe, 0xe2, 0xf9, 0x4e, 0xe5, 0xb7, 0xcf, 0x77, 0x2a, 0xbf, 0x7b, 0xbe, 0x53,
	0xf9, 0xc7, 0xe7, 0x3b, 0x95, 0x7f, 0x79, 0xbe, 0x73, 0xe9, 0xdf, 0x9f, 0xef, 0x54, 0xfe, 0xf8,
	0xbb, 0x9d, 0x4b, 0xbf, 0xfd, 0x6e, 0xa7, 0xf2, 0xbb, 0xef, 0x76, 0x2e, 0x7d, 0xfb, 0xdd, 0xce,
	0xa5, 0xdf, 0x7b, 0xd3, 0x0e, 0xdc, 0xfe, 0xcd, 0x98, 0x45, 0x43, 0x16, 0xdd, 0xb2, 0x03, 0xbe,
	0xe1, 0xb7, 0xf4, 0xdf, 0x8c, 0x9f, 0x2c, 0xe1, 0xf7, 0x9d, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff,
	0x59, 0x71, 0xdd, 0xb0, 0x4c, 0x3e, 0x00, 0x00,
}

func init() {
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRptInt64.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTables.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolKeyValue.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolAttr.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolAttrTrans.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolBuff.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolBuffEffect.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolDrop.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolDropMini.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolDropLists.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolDropListsMini.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolDungeon.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolInhibitAtk.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMapScene.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMechanics.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMedicament.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMonster.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolMonsterGroup.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRobot.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRoguelikeArtifact.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRoguelikeDungeon.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRoguelikeDungeonRoom.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRoleLv.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRoleReachDungeon.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolRowHero.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolSkill.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolSummoned.Get().(proto.Message)
	})
	coin_server_common_msgcreate.RegisterNewMessage(func() proto.Message {
		return poolTempBag.Get().(proto.Message)
	})
}

var poolRptInt64 = &sync.Pool{New: func() interface{} { return &RptInt64{} }}

func (m *RptInt64) ReleasePool() { m.Reset(); poolRptInt64.Put(m); m = nil }

var poolTables = &sync.Pool{New: func() interface{} { return &Tables{} }}

func (m *Tables) ReleasePool() { m.Reset(); poolTables.Put(m); m = nil }

var poolKeyValue = &sync.Pool{New: func() interface{} { return &KeyValue{} }}

func (m *KeyValue) ReleasePool() { m.Reset(); poolKeyValue.Put(m); m = nil }

var poolAttr = &sync.Pool{New: func() interface{} { return &Attr{} }}

func (m *Attr) ReleasePool() { m.Reset(); poolAttr.Put(m); m = nil }

var poolAttrTrans = &sync.Pool{New: func() interface{} { return &AttrTrans{} }}

func (m *AttrTrans) ReleasePool() { m.Reset(); poolAttrTrans.Put(m); m = nil }

var poolBuff = &sync.Pool{New: func() interface{} { return &Buff{} }}

func (m *Buff) ReleasePool() { m.Reset(); poolBuff.Put(m); m = nil }

var poolBuffEffect = &sync.Pool{New: func() interface{} { return &BuffEffect{} }}

func (m *BuffEffect) ReleasePool() { m.Reset(); poolBuffEffect.Put(m); m = nil }

var poolDrop = &sync.Pool{New: func() interface{} { return &Drop{} }}

func (m *Drop) ReleasePool() { m.Reset(); poolDrop.Put(m); m = nil }

var poolDropMini = &sync.Pool{New: func() interface{} { return &DropMini{} }}

func (m *DropMini) ReleasePool() { m.Reset(); poolDropMini.Put(m); m = nil }

var poolDropLists = &sync.Pool{New: func() interface{} { return &DropLists{} }}

func (m *DropLists) ReleasePool() { m.Reset(); poolDropLists.Put(m); m = nil }

var poolDropListsMini = &sync.Pool{New: func() interface{} { return &DropListsMini{} }}

func (m *DropListsMini) ReleasePool() { m.Reset(); poolDropListsMini.Put(m); m = nil }

var poolDungeon = &sync.Pool{New: func() interface{} { return &Dungeon{} }}

func (m *Dungeon) ReleasePool() { m.Reset(); poolDungeon.Put(m); m = nil }

var poolInhibitAtk = &sync.Pool{New: func() interface{} { return &InhibitAtk{} }}

func (m *InhibitAtk) ReleasePool() { m.Reset(); poolInhibitAtk.Put(m); m = nil }

var poolMapScene = &sync.Pool{New: func() interface{} { return &MapScene{} }}

func (m *MapScene) ReleasePool() { m.Reset(); poolMapScene.Put(m); m = nil }

var poolMechanics = &sync.Pool{New: func() interface{} { return &Mechanics{} }}

func (m *Mechanics) ReleasePool() { m.Reset(); poolMechanics.Put(m); m = nil }

var poolMedicament = &sync.Pool{New: func() interface{} { return &Medicament{} }}

func (m *Medicament) ReleasePool() { m.Reset(); poolMedicament.Put(m); m = nil }

var poolMonster = &sync.Pool{New: func() interface{} { return &Monster{} }}

func (m *Monster) ReleasePool() { m.Reset(); poolMonster.Put(m); m = nil }

var poolMonsterGroup = &sync.Pool{New: func() interface{} { return &MonsterGroup{} }}

func (m *MonsterGroup) ReleasePool() { m.Reset(); poolMonsterGroup.Put(m); m = nil }

var poolRobot = &sync.Pool{New: func() interface{} { return &Robot{} }}

func (m *Robot) ReleasePool() { m.Reset(); poolRobot.Put(m); m = nil }

var poolRoguelikeArtifact = &sync.Pool{New: func() interface{} { return &RoguelikeArtifact{} }}

func (m *RoguelikeArtifact) ReleasePool() { m.Reset(); poolRoguelikeArtifact.Put(m); m = nil }

var poolRoguelikeDungeon = &sync.Pool{New: func() interface{} { return &RoguelikeDungeon{} }}

func (m *RoguelikeDungeon) ReleasePool() { m.Reset(); poolRoguelikeDungeon.Put(m); m = nil }

var poolRoguelikeDungeonRoom = &sync.Pool{New: func() interface{} { return &RoguelikeDungeonRoom{} }}

func (m *RoguelikeDungeonRoom) ReleasePool() { m.Reset(); poolRoguelikeDungeonRoom.Put(m); m = nil }

var poolRoleLv = &sync.Pool{New: func() interface{} { return &RoleLv{} }}

func (m *RoleLv) ReleasePool() { m.Reset(); poolRoleLv.Put(m); m = nil }

var poolRoleReachDungeon = &sync.Pool{New: func() interface{} { return &RoleReachDungeon{} }}

func (m *RoleReachDungeon) ReleasePool() { m.Reset(); poolRoleReachDungeon.Put(m); m = nil }

var poolRowHero = &sync.Pool{New: func() interface{} { return &RowHero{} }}

func (m *RowHero) ReleasePool() { m.Reset(); poolRowHero.Put(m); m = nil }

var poolSkill = &sync.Pool{New: func() interface{} { return &Skill{} }}

func (m *Skill) ReleasePool() { m.Reset(); poolSkill.Put(m); m = nil }

var poolSummoned = &sync.Pool{New: func() interface{} { return &Summoned{} }}

func (m *Summoned) ReleasePool() { m.Reset(); poolSummoned.Put(m); m = nil }

var poolTempBag = &sync.Pool{New: func() interface{} { return &TempBag{} }}

func (m *TempBag) ReleasePool() { m.Reset(); poolTempBag.Put(m); m = nil }
func (m *RptInt64) UnmarshalJSON(data []byte) error {
	sls := make([]int64, 0)
	err := github_com_json_iterator_go.Unmarshal(data, &sls)
	if err != nil {
		return err
	}
	m.Slice = sls
	return nil
}

func (this *RptInt64) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RptInt64)
	if !ok {
		that2, ok := that.(RptInt64)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Slice) != len(that1.Slice) {
		return false
	}
	for i := range this.Slice {
		if this.Slice[i] != that1.Slice[i] {
			return false
		}
	}
	return true
}
func (this *Tables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tables)
	if !ok {
		that2, ok := that.(Tables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.KeyValue) != len(that1.KeyValue) {
		return false
	}
	for i := range this.KeyValue {
		if !this.KeyValue[i].Equal(that1.KeyValue[i]) {
			return false
		}
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if !this.Attr[i].Equal(that1.Attr[i]) {
			return false
		}
	}
	if len(this.AttrTrans) != len(that1.AttrTrans) {
		return false
	}
	for i := range this.AttrTrans {
		if !this.AttrTrans[i].Equal(that1.AttrTrans[i]) {
			return false
		}
	}
	if len(this.Buff) != len(that1.Buff) {
		return false
	}
	for i := range this.Buff {
		if !this.Buff[i].Equal(that1.Buff[i]) {
			return false
		}
	}
	if len(this.BuffEffect) != len(that1.BuffEffect) {
		return false
	}
	for i := range this.BuffEffect {
		if !this.BuffEffect[i].Equal(that1.BuffEffect[i]) {
			return false
		}
	}
	if len(this.Drop) != len(that1.Drop) {
		return false
	}
	for i := range this.Drop {
		if !this.Drop[i].Equal(that1.Drop[i]) {
			return false
		}
	}
	if len(this.DropLists) != len(that1.DropLists) {
		return false
	}
	for i := range this.DropLists {
		if !this.DropLists[i].Equal(that1.DropLists[i]) {
			return false
		}
	}
	if len(this.Dungeon) != len(that1.Dungeon) {
		return false
	}
	for i := range this.Dungeon {
		if !this.Dungeon[i].Equal(that1.Dungeon[i]) {
			return false
		}
	}
	if len(this.InhibitAtk) != len(that1.InhibitAtk) {
		return false
	}
	for i := range this.InhibitAtk {
		if !this.InhibitAtk[i].Equal(that1.InhibitAtk[i]) {
			return false
		}
	}
	if len(this.MapScene) != len(that1.MapScene) {
		return false
	}
	for i := range this.MapScene {
		if !this.MapScene[i].Equal(that1.MapScene[i]) {
			return false
		}
	}
	if len(this.Mechanics) != len(that1.Mechanics) {
		return false
	}
	for i := range this.Mechanics {
		if !this.Mechanics[i].Equal(that1.Mechanics[i]) {
			return false
		}
	}
	if len(this.Medicament) != len(that1.Medicament) {
		return false
	}
	for i := range this.Medicament {
		if !this.Medicament[i].Equal(that1.Medicament[i]) {
			return false
		}
	}
	if len(this.Monster) != len(that1.Monster) {
		return false
	}
	for i := range this.Monster {
		if !this.Monster[i].Equal(that1.Monster[i]) {
			return false
		}
	}
	if len(this.MonsterGroup) != len(that1.MonsterGroup) {
		return false
	}
	for i := range this.MonsterGroup {
		if !this.MonsterGroup[i].Equal(that1.MonsterGroup[i]) {
			return false
		}
	}
	if len(this.Robot) != len(that1.Robot) {
		return false
	}
	for i := range this.Robot {
		if !this.Robot[i].Equal(that1.Robot[i]) {
			return false
		}
	}
	if len(this.RoguelikeArtifact) != len(that1.RoguelikeArtifact) {
		return false
	}
	for i := range this.RoguelikeArtifact {
		if !this.RoguelikeArtifact[i].Equal(that1.RoguelikeArtifact[i]) {
			return false
		}
	}
	if len(this.RoguelikeDungeon) != len(that1.RoguelikeDungeon) {
		return false
	}
	for i := range this.RoguelikeDungeon {
		if !this.RoguelikeDungeon[i].Equal(that1.RoguelikeDungeon[i]) {
			return false
		}
	}
	if len(this.RoleLv) != len(that1.RoleLv) {
		return false
	}
	for i := range this.RoleLv {
		if !this.RoleLv[i].Equal(that1.RoleLv[i]) {
			return false
		}
	}
	if len(this.RoleReachDungeon) != len(that1.RoleReachDungeon) {
		return false
	}
	for i := range this.RoleReachDungeon {
		if !this.RoleReachDungeon[i].Equal(that1.RoleReachDungeon[i]) {
			return false
		}
	}
	if len(this.RowHero) != len(that1.RowHero) {
		return false
	}
	for i := range this.RowHero {
		if !this.RowHero[i].Equal(that1.RowHero[i]) {
			return false
		}
	}
	if len(this.Skill) != len(that1.Skill) {
		return false
	}
	for i := range this.Skill {
		if !this.Skill[i].Equal(that1.Skill[i]) {
			return false
		}
	}
	if len(this.Summoned) != len(that1.Summoned) {
		return false
	}
	for i := range this.Summoned {
		if !this.Summoned[i].Equal(that1.Summoned[i]) {
			return false
		}
	}
	if len(this.TempBag) != len(that1.TempBag) {
		return false
	}
	for i := range this.TempBag {
		if !this.TempBag[i].Equal(that1.TempBag[i]) {
			return false
		}
	}
	return true
}
func (this *KeyValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyValue)
	if !ok {
		that2, ok := that.(KeyValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Attr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Attr)
	if !ok {
		that2, ok := that.(Attr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AdvancedType != that1.AdvancedType {
		return false
	}
	return true
}
func (this *AttrTrans) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrTrans)
	if !ok {
		that2, ok := that.(AttrTrans)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AttrID != that1.AttrID {
		return false
	}
	if this.Transtype != that1.Transtype {
		return false
	}
	if this.TransattrID != that1.TransattrID {
		return false
	}
	if this.Transnum != that1.Transnum {
		return false
	}
	if len(this.Limithero) != len(that1.Limithero) {
		return false
	}
	for i := range this.Limithero {
		if this.Limithero[i] != that1.Limithero[i] {
			return false
		}
	}
	return true
}
func (this *Buff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Buff)
	if !ok {
		that2, ok := that.(Buff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.BuffLv != that1.BuffLv {
		return false
	}
	if this.BuffConditionType != that1.BuffConditionType {
		return false
	}
	if this.LogicId != that1.LogicId {
		return false
	}
	if this.LogicArgs != that1.LogicArgs {
		return false
	}
	if this.BuffEffectType != that1.BuffEffectType {
		return false
	}
	if this.BuffTime != that1.BuffTime {
		return false
	}
	if len(this.BuffType) != len(that1.BuffType) {
		return false
	}
	for i := range this.BuffType {
		if this.BuffType[i] != that1.BuffType[i] {
			return false
		}
	}
	if len(this.AttrFixed) != len(that1.AttrFixed) {
		return false
	}
	for i := range this.AttrFixed {
		if this.AttrFixed[i] != that1.AttrFixed[i] {
			return false
		}
	}
	if len(this.AttrPercentage) != len(that1.AttrPercentage) {
		return false
	}
	for i := range this.AttrPercentage {
		if this.AttrPercentage[i] != that1.AttrPercentage[i] {
			return false
		}
	}
	return true
}
func (this *BuffEffect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BuffEffect)
	if !ok {
		that2, ok := that.(BuffEffect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AttributeID != that1.AttributeID {
		return false
	}
	if this.LogicId != that1.LogicId {
		return false
	}
	return true
}
func (this *Drop) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Drop)
	if !ok {
		that2, ok := that.(Drop)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if len(this.DropMini) != len(that1.DropMini) {
		return false
	}
	for i := range this.DropMini {
		if !this.DropMini[i].Equal(that1.DropMini[i]) {
			return false
		}
	}
	return true
}
func (this *DropMini) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropMini)
	if !ok {
		that2, ok := that.(DropMini)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DropId != that1.DropId {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.ItemId) != len(that1.ItemId) {
		return false
	}
	for i := range this.ItemId {
		if this.ItemId[i] != that1.ItemId[i] {
			return false
		}
	}
	if this.ItemWeight != that1.ItemWeight {
		return false
	}
	return true
}
func (this *DropLists) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropLists)
	if !ok {
		that2, ok := that.(DropLists)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.DropListsMini) != len(that1.DropListsMini) {
		return false
	}
	for i := range this.DropListsMini {
		if !this.DropListsMini[i].Equal(that1.DropListsMini[i]) {
			return false
		}
	}
	return true
}
func (this *DropListsMini) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DropListsMini)
	if !ok {
		that2, ok := that.(DropListsMini)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DropListsId != that1.DropListsId {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DropId != that1.DropId {
		return false
	}
	if this.DropProb != that1.DropProb {
		return false
	}
	return true
}
func (this *Dungeon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Dungeon)
	if !ok {
		that2, ok := that.(Dungeon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Times != that1.Times {
		return false
	}
	if this.PlayersLv != that1.PlayersLv {
		return false
	}
	if this.CombatCap != that1.CombatCap {
		return false
	}
	if this.DungeonPlayerNum != that1.DungeonPlayerNum {
		return false
	}
	if this.MapBehaviorTree != that1.MapBehaviorTree {
		return false
	}
	return true
}
func (this *InhibitAtk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InhibitAtk)
	if !ok {
		that2, ok := that.(InhibitAtk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AtkType != that1.AtkType {
		return false
	}
	if this.DefType != that1.DefType {
		return false
	}
	if this.AtkEffect != that1.AtkEffect {
		return false
	}
	if this.SkillId != that1.SkillId {
		return false
	}
	return true
}
func (this *MapScene) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MapScene)
	if !ok {
		that2, ok := that.(MapScene)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.MapType != that1.MapType {
		return false
	}
	if this.CfgMap != that1.CfgMap {
		return false
	}
	if this.BinMap != that1.BinMap {
		return false
	}
	if this.DungeonID != that1.DungeonID {
		return false
	}
	if this.LevelMapID != that1.LevelMapID {
		return false
	}
	if this.RoguelikeID != that1.RoguelikeID {
		return false
	}
	if this.GoldProfit != that1.GoldProfit {
		return false
	}
	if this.LineMaxPersonsNum != that1.LineMaxPersonsNum {
		return false
	}
	if len(this.MedicamentId) != len(that1.MedicamentId) {
		return false
	}
	for i := range this.MedicamentId {
		if this.MedicamentId[i] != that1.MedicamentId[i] {
			return false
		}
	}
	return true
}
func (this *Mechanics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Mechanics)
	if !ok {
		that2, ok := that.(Mechanics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if len(this.ActiveBegin) != len(that1.ActiveBegin) {
		return false
	}
	for i := range this.ActiveBegin {
		if this.ActiveBegin[i] != that1.ActiveBegin[i] {
			return false
		}
	}
	if len(this.Circulate) != len(that1.Circulate) {
		return false
	}
	for i := range this.Circulate {
		if this.Circulate[i] != that1.Circulate[i] {
			return false
		}
	}
	if len(this.DamagePercent) != len(that1.DamagePercent) {
		return false
	}
	for i := range this.DamagePercent {
		if this.DamagePercent[i] != that1.DamagePercent[i] {
			return false
		}
	}
	if this.DueTime != that1.DueTime {
		return false
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *Medicament) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Medicament)
	if !ok {
		that2, ok := that.(Medicament)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Typ != that1.Typ {
		return false
	}
	if this.CD != that1.CD {
		return false
	}
	if this.BuffId != that1.BuffId {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *Monster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Monster)
	if !ok {
		that2, ok := that.(Monster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.MonsterType != that1.MonsterType {
		return false
	}
	if this.MonsterAttackType != that1.MonsterAttackType {
		return false
	}
	if len(this.AtKSkill) != len(that1.AtKSkill) {
		return false
	}
	for i := range this.AtKSkill {
		if this.AtKSkill[i] != that1.AtKSkill[i] {
			return false
		}
	}
	if len(this.SkillId) != len(that1.SkillId) {
		return false
	}
	for i := range this.SkillId {
		if this.SkillId[i] != that1.SkillId[i] {
			return false
		}
	}
	if len(this.BuffId) != len(that1.BuffId) {
		return false
	}
	for i := range this.BuffId {
		if this.BuffId[i] != that1.BuffId[i] {
			return false
		}
	}
	if this.Modle3DSize != that1.Modle3DSize {
		return false
	}
	if len(this.Inhibit) != len(that1.Inhibit) {
		return false
	}
	for i := range this.Inhibit {
		if this.Inhibit[i] != that1.Inhibit[i] {
			return false
		}
	}
	if this.LockRange != that1.LockRange {
		return false
	}
	if this.PursuitRange != that1.PursuitRange {
		return false
	}
	if this.DeathRefreshTime != that1.DeathRefreshTime {
		return false
	}
	if this.CorpseTime != that1.CorpseTime {
		return false
	}
	if this.Move != that1.Move {
		return false
	}
	if this.BeHitFlyParam != that1.BeHitFlyParam {
		return false
	}
	if this.BeRepulseParam != that1.BeRepulseParam {
		return false
	}
	if this.DeadItemsRange != that1.DeadItemsRange {
		return false
	}
	if this.DropListId != that1.DropListId {
		return false
	}
	if this.NumHpBar != that1.NumHpBar {
		return false
	}
	if len(this.ParameterQuality) != len(that1.ParameterQuality) {
		return false
	}
	for i := range this.ParameterQuality {
		if this.ParameterQuality[i] != that1.ParameterQuality[i] {
			return false
		}
	}
	return true
}
func (this *MonsterGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MonsterGroup)
	if !ok {
		that2, ok := that.(MonsterGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.MonsterId) != len(that1.MonsterId) {
		return false
	}
	for i := range this.MonsterId {
		if this.MonsterId[i] != that1.MonsterId[i] {
			return false
		}
	}
	if this.AreaId != that1.AreaId {
		return false
	}
	return true
}
func (this *Robot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Robot)
	if !ok {
		that2, ok := that.(Robot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ConfigId != that1.ConfigId {
		return false
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if this.Attr[i] != that1.Attr[i] {
			return false
		}
	}
	if len(this.SkillId) != len(that1.SkillId) {
		return false
	}
	for i := range this.SkillId {
		if this.SkillId[i] != that1.SkillId[i] {
			return false
		}
	}
	if len(this.BuffId) != len(that1.BuffId) {
		return false
	}
	for i := range this.BuffId {
		if this.BuffId[i] != that1.BuffId[i] {
			return false
		}
	}
	if this.Lv != that1.Lv {
		return false
	}
	return true
}
func (this *RoguelikeArtifact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoguelikeArtifact)
	if !ok {
		that2, ok := that.(RoguelikeArtifact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.QualityId != that1.QualityId {
		return false
	}
	if this.Quality != that1.Quality {
		return false
	}
	if len(this.OccupationFirst) != len(that1.OccupationFirst) {
		return false
	}
	for i := range this.OccupationFirst {
		if this.OccupationFirst[i] != that1.OccupationFirst[i] {
			return false
		}
	}
	if this.Weight != that1.Weight {
		return false
	}
	if len(this.AttrId) != len(that1.AttrId) {
		return false
	}
	for i := range this.AttrId {
		if this.AttrId[i] != that1.AttrId[i] {
			return false
		}
	}
	return true
}
func (this *RoguelikeDungeon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoguelikeDungeon)
	if !ok {
		that2, ok := that.(RoguelikeDungeon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DungeonDay != that1.DungeonDay {
		return false
	}
	if this.BossCap != that1.BossCap {
		return false
	}
	if len(this.BossMechanical) != len(that1.BossMechanical) {
		return false
	}
	for i := range this.BossMechanical {
		if this.BossMechanical[i] != that1.BossMechanical[i] {
			return false
		}
	}
	if this.Times != that1.Times {
		return false
	}
	if len(this.DungeonLv) != len(that1.DungeonLv) {
		return false
	}
	for i := range this.DungeonLv {
		if this.DungeonLv[i] != that1.DungeonLv[i] {
			return false
		}
	}
	if len(this.DungeonSize) != len(that1.DungeonSize) {
		return false
	}
	for i := range this.DungeonSize {
		if this.DungeonSize[i] != that1.DungeonSize[i] {
			return false
		}
	}
	if len(this.ResurrectionItem) != len(that1.ResurrectionItem) {
		return false
	}
	for i := range this.ResurrectionItem {
		if this.ResurrectionItem[i] != that1.ResurrectionItem[i] {
			return false
		}
	}
	if this.ResurrectionItemAdd != that1.ResurrectionItemAdd {
		return false
	}
	if this.ResurrectionItemMax != that1.ResurrectionItemMax {
		return false
	}
	if this.ResurrectionTime != that1.ResurrectionTime {
		return false
	}
	if this.ResurrectionTimeInc != that1.ResurrectionTimeInc {
		return false
	}
	if this.ResurrectionTimeIMax != that1.ResurrectionTimeIMax {
		return false
	}
	if this.DungeonRewardPro != that1.DungeonRewardPro {
		return false
	}
	if len(this.DungeonReward) != len(that1.DungeonReward) {
		return false
	}
	for i := range this.DungeonReward {
		if this.DungeonReward[i] != that1.DungeonReward[i] {
			return false
		}
	}
	if len(this.DungeonRewardWei) != len(that1.DungeonRewardWei) {
		return false
	}
	for i := range this.DungeonRewardWei {
		if this.DungeonRewardWei[i] != that1.DungeonRewardWei[i] {
			return false
		}
	}
	if this.MapBehaviorTree != that1.MapBehaviorTree {
		return false
	}
	if len(this.RoguelikeDungeonRoom) != len(that1.RoguelikeDungeonRoom) {
		return false
	}
	for i := range this.RoguelikeDungeonRoom {
		if !this.RoguelikeDungeonRoom[i].Equal(that1.RoguelikeDungeonRoom[i]) {
			return false
		}
	}
	return true
}
func (this *RoguelikeDungeonRoom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoguelikeDungeonRoom)
	if !ok {
		that2, ok := that.(RoguelikeDungeonRoom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoguelikeDungeonId != that1.RoguelikeDungeonId {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.RoomTyp != that1.RoomTyp {
		return false
	}
	if len(this.Reward) != len(that1.Reward) {
		return false
	}
	for i := range this.Reward {
		if !this.Reward[i].Equal(that1.Reward[i]) {
			return false
		}
	}
	if len(this.RewardWeight) != len(that1.RewardWeight) {
		return false
	}
	for i := range this.RewardWeight {
		if this.RewardWeight[i] != that1.RewardWeight[i] {
			return false
		}
	}
	return true
}
func (this *RoleLv) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleLv)
	if !ok {
		that2, ok := that.(RoleLv)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AdvancedHero != that1.AdvancedHero {
		return false
	}
	if len(this.AdvancedItem) != len(that1.AdvancedItem) {
		return false
	}
	for i := range this.AdvancedItem {
		if this.AdvancedItem[i] != that1.AdvancedItem[i] {
			return false
		}
	}
	if this.CopyId != that1.CopyId {
		return false
	}
	if this.LvHero != that1.LvHero {
		return false
	}
	if this.SmallLv != that1.SmallLv {
		return false
	}
	if this.Exp != that1.Exp {
		return false
	}
	if this.DivinationExp != that1.DivinationExp {
		return false
	}
	if len(this.DivinationWeight) != len(that1.DivinationWeight) {
		return false
	}
	for i := range this.DivinationWeight {
		if this.DivinationWeight[i] != that1.DivinationWeight[i] {
			return false
		}
	}
	if len(this.ParameterQuality) != len(that1.ParameterQuality) {
		return false
	}
	for i := range this.ParameterQuality {
		if this.ParameterQuality[i] != that1.ParameterQuality[i] {
			return false
		}
	}
	if this.PowerNum != that1.PowerNum {
		return false
	}
	if this.CompressLv != that1.CompressLv {
		return false
	}
	if this.SkillPowerNum != that1.SkillPowerNum {
		return false
	}
	return true
}
func (this *RoleReachDungeon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleReachDungeon)
	if !ok {
		that2, ok := that.(RoleReachDungeon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Times != that1.Times {
		return false
	}
	if this.VictoryCondition != that1.VictoryCondition {
		return false
	}
	if this.FailCondition != that1.FailCondition {
		return false
	}
	if this.MapSceneId != that1.MapSceneId {
		return false
	}
	if this.BossId != that1.BossId {
		return false
	}
	return true
}
func (this *RowHero) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowHero)
	if !ok {
		that2, ok := that.(RowHero)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.OriginID != that1.OriginID {
		return false
	}
	if this.ArmsId != that1.ArmsId {
		return false
	}
	if this.ArmorId != that1.ArmorId {
		return false
	}
	if this.Modle3DSize != that1.Modle3DSize {
		return false
	}
	if len(this.AtKSkill) != len(that1.AtKSkill) {
		return false
	}
	for i := range this.AtKSkill {
		if this.AtKSkill[i] != that1.AtKSkill[i] {
			return false
		}
	}
	if this.IntervalTime != that1.IntervalTime {
		return false
	}
	if len(this.SkillId) != len(that1.SkillId) {
		return false
	}
	for i := range this.SkillId {
		if this.SkillId[i] != that1.SkillId[i] {
			return false
		}
	}
	if len(this.Inhibit) != len(that1.Inhibit) {
		return false
	}
	for i := range this.Inhibit {
		if this.Inhibit[i] != that1.Inhibit[i] {
			return false
		}
	}
	if this.LockRange != that1.LockRange {
		return false
	}
	if this.DeathAnimationTime != that1.DeathAnimationTime {
		return false
	}
	if this.Move != that1.Move {
		return false
	}
	if this.BeHitFlyParam != that1.BeHitFlyParam {
		return false
	}
	if this.BeRepulseParam != that1.BeRepulseParam {
		return false
	}
	return true
}
func (this *Skill) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Skill)
	if !ok {
		that2, ok := that.(Skill)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.SkillBaseId != that1.SkillBaseId {
		return false
	}
	if this.SkillView != that1.SkillView {
		return false
	}
	if this.LogicId != that1.LogicId {
		return false
	}
	if this.IsNomalSkill != that1.IsNomalSkill {
		return false
	}
	if this.SkillWeight != that1.SkillWeight {
		return false
	}
	if this.SkillInterrupt != that1.SkillInterrupt {
		return false
	}
	if this.AtkRange != that1.AtkRange {
		return false
	}
	if this.SkillTarget != that1.SkillTarget {
		return false
	}
	if this.Target != that1.Target {
		return false
	}
	if this.SkillCD != that1.SkillCD {
		return false
	}
	if len(this.SkillBaceDam) != len(that1.SkillBaceDam) {
		return false
	}
	for i := range this.SkillBaceDam {
		if this.SkillBaceDam[i] != that1.SkillBaceDam[i] {
			return false
		}
	}
	if len(this.AtkAddition) != len(that1.AtkAddition) {
		return false
	}
	for i := range this.AtkAddition {
		if this.AtkAddition[i] != that1.AtkAddition[i] {
			return false
		}
	}
	if this.SkillAddBuff != that1.SkillAddBuff {
		return false
	}
	return true
}
func (this *Summoned) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Summoned)
	if !ok {
		that2, ok := that.(Summoned)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.MonsterId) != len(that1.MonsterId) {
		return false
	}
	for i := range this.MonsterId {
		if this.MonsterId[i] != that1.MonsterId[i] {
			return false
		}
	}
	if len(this.MonsterAttr) != len(that1.MonsterAttr) {
		return false
	}
	for i := range this.MonsterAttr {
		if this.MonsterAttr[i] != that1.MonsterAttr[i] {
			return false
		}
	}
	if len(this.SurvivalTime) != len(that1.SurvivalTime) {
		return false
	}
	for i := range this.SurvivalTime {
		if this.SurvivalTime[i] != that1.SurvivalTime[i] {
			return false
		}
	}
	if len(this.SummonedBuff) != len(that1.SummonedBuff) {
		return false
	}
	for i := range this.SummonedBuff {
		if this.SummonedBuff[i] != that1.SummonedBuff[i] {
			return false
		}
	}
	return true
}
func (this *TempBag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TempBag)
	if !ok {
		that2, ok := that.(TempBag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.TempBagLevel != that1.TempBagLevel {
		return false
	}
	if this.RoleLevel != that1.RoleLevel {
		return false
	}
	if this.ProfitUpper != that1.ProfitUpper {
		return false
	}
	return true
}
func (m *RptInt64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RptInt64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RptInt64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Slice) > 0 {
		dAtA2 := make([]byte, len(m.Slice)*10)
		var j1 int
		for _, num1 := range m.Slice {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintOut(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tables) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TempBag) > 0 {
		for k := range m.TempBag {
			v := m.TempBag[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.Summoned) > 0 {
		for k := range m.Summoned {
			v := m.Summoned[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Skill) > 0 {
		for k := range m.Skill {
			v := m.Skill[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.RowHero) > 0 {
		for k := range m.RowHero {
			v := m.RowHero[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RoleReachDungeon) > 0 {
		for k := range m.RoleReachDungeon {
			v := m.RoleReachDungeon[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.RoleLv) > 0 {
		for k := range m.RoleLv {
			v := m.RoleLv[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.RoguelikeDungeon) > 0 {
		for k := range m.RoguelikeDungeon {
			v := m.RoguelikeDungeon[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.RoguelikeArtifact) > 0 {
		for k := range m.RoguelikeArtifact {
			v := m.RoguelikeArtifact[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Robot) > 0 {
		for k := range m.Robot {
			v := m.Robot[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.MonsterGroup) > 0 {
		for k := range m.MonsterGroup {
			v := m.MonsterGroup[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Monster) > 0 {
		for k := range m.Monster {
			v := m.Monster[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Medicament) > 0 {
		for k := range m.Medicament {
			v := m.Medicament[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Mechanics) > 0 {
		for k := range m.Mechanics {
			v := m.Mechanics[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.MapScene) > 0 {
		for k := range m.MapScene {
			v := m.MapScene[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.InhibitAtk) > 0 {
		for k := range m.InhibitAtk {
			v := m.InhibitAtk[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Dungeon) > 0 {
		for k := range m.Dungeon {
			v := m.Dungeon[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DropLists) > 0 {
		for k := range m.DropLists {
			v := m.DropLists[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Drop) > 0 {
		for k := range m.Drop {
			v := m.Drop[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BuffEffect) > 0 {
		for k := range m.BuffEffect {
			v := m.BuffEffect[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Buff) > 0 {
		for k := range m.Buff {
			v := m.Buff[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AttrTrans) > 0 {
		for k := range m.AttrTrans {
			v := m.AttrTrans[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Attr) > 0 {
		for k := range m.Attr {
			v := m.Attr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeyValue) > 0 {
		for k := range m.KeyValue {
			v := m.KeyValue[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOut(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOut(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintOut(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintOut(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Attr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvancedType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AdvancedType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttrTrans) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrTrans) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrTrans) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Limithero) > 0 {
		dAtA27 := make([]byte, len(m.Limithero)*10)
		var j26 int
		for _, num1 := range m.Limithero {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintOut(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x32
	}
	if m.Transnum != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Transnum))
		i--
		dAtA[i] = 0x28
	}
	if m.TransattrID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.TransattrID))
		i--
		dAtA[i] = 0x20
	}
	if m.Transtype != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Transtype))
		i--
		dAtA[i] = 0x18
	}
	if m.AttrID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AttrID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Buff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Buff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Buff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttrPercentage) > 0 {
		for k := range m.AttrPercentage {
			v := m.AttrPercentage[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AttrFixed) > 0 {
		for k := range m.AttrFixed {
			v := m.AttrFixed[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.BuffType) > 0 {
		dAtA29 := make([]byte, len(m.BuffType)*10)
		var j28 int
		for _, num1 := range m.BuffType {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintOut(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x42
	}
	if m.BuffTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BuffTime))
		i--
		dAtA[i] = 0x38
	}
	if m.BuffEffectType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BuffEffectType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LogicArgs) > 0 {
		i -= len(m.LogicArgs)
		copy(dAtA[i:], m.LogicArgs)
		i = encodeVarintOut(dAtA, i, uint64(len(m.LogicArgs)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LogicId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LogicId))
		i--
		dAtA[i] = 0x20
	}
	if m.BuffConditionType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BuffConditionType))
		i--
		dAtA[i] = 0x18
	}
	if m.BuffLv != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BuffLv))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuffEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffEffect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuffEffect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogicId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LogicId))
		i--
		dAtA[i] = 0x18
	}
	if m.AttributeID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AttributeID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Drop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Drop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Drop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DropMini) > 0 {
		for k := range m.DropMini {
			v := m.DropMini[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintOut(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropMini) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMini) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropMini) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ItemWeight != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ItemWeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ItemId) > 0 {
		for k := range m.ItemId {
			v := m.ItemId[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.DropId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DropId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropLists) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropLists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropLists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DropListsMini) > 0 {
		for k := range m.DropListsMini {
			v := m.DropListsMini[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropListsMini) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropListsMini) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropListsMini) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropProb != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DropProb))
		i--
		dAtA[i] = 0x20
	}
	if m.DropId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DropId))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.DropListsId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DropListsId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dungeon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dungeon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dungeon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MapBehaviorTree) > 0 {
		i -= len(m.MapBehaviorTree)
		copy(dAtA[i:], m.MapBehaviorTree)
		i = encodeVarintOut(dAtA, i, uint64(len(m.MapBehaviorTree)))
		i--
		dAtA[i] = 0x32
	}
	if m.DungeonPlayerNum != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DungeonPlayerNum))
		i--
		dAtA[i] = 0x28
	}
	if m.CombatCap != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.CombatCap))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayersLv != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.PlayersLv))
		i--
		dAtA[i] = 0x18
	}
	if m.Times != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InhibitAtk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InhibitAtk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InhibitAtk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SkillId))
		i--
		dAtA[i] = 0x28
	}
	if m.AtkEffect != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AtkEffect))
		i--
		dAtA[i] = 0x20
	}
	if m.DefType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DefType))
		i--
		dAtA[i] = 0x18
	}
	if m.AtkType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AtkType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MapScene) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapScene) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapScene) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MedicamentId) > 0 {
		dAtA33 := make([]byte, len(m.MedicamentId)*10)
		var j32 int
		for _, num1 := range m.MedicamentId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintOut(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0x52
	}
	if m.LineMaxPersonsNum != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LineMaxPersonsNum))
		i--
		dAtA[i] = 0x48
	}
	if m.GoldProfit != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.GoldProfit))
		i--
		dAtA[i] = 0x40
	}
	if m.RoguelikeID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.RoguelikeID))
		i--
		dAtA[i] = 0x38
	}
	if m.LevelMapID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LevelMapID))
		i--
		dAtA[i] = 0x30
	}
	if m.DungeonID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DungeonID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BinMap) > 0 {
		i -= len(m.BinMap)
		copy(dAtA[i:], m.BinMap)
		i = encodeVarintOut(dAtA, i, uint64(len(m.BinMap)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CfgMap) > 0 {
		i -= len(m.CfgMap)
		copy(dAtA[i:], m.CfgMap)
		i = encodeVarintOut(dAtA, i, uint64(len(m.CfgMap)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MapType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.MapType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mechanics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mechanics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mechanics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOut(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DueTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DueTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DamagePercent) > 0 {
		dAtA35 := make([]byte, len(m.DamagePercent)*10)
		var j34 int
		for _, num1 := range m.DamagePercent {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintOut(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Circulate) > 0 {
		dAtA37 := make([]byte, len(m.Circulate)*10)
		var j36 int
		for _, num1 := range m.Circulate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintOut(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ActiveBegin) > 0 {
		dAtA39 := make([]byte, len(m.ActiveBegin)*10)
		var j38 int
		for _, num1 := range m.ActiveBegin {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintOut(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x1a
	}
	if m.Idx != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Medicament) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Medicament) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Medicament) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.BuffId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BuffId))
		i--
		dAtA[i] = 0x28
	}
	if m.CD != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.CD))
		i--
		dAtA[i] = 0x20
	}
	if m.Typ != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Monster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Monster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Monster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParameterQuality) > 0 {
		for k := range m.ParameterQuality {
			v := m.ParameterQuality[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.NumHpBar != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.NumHpBar))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.DropListId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DropListId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.DeadItemsRange != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DeadItemsRange))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.BeRepulseParam != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BeRepulseParam))
		i--
		dAtA[i] = 0x78
	}
	if m.BeHitFlyParam != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BeHitFlyParam))
		i--
		dAtA[i] = 0x70
	}
	if m.Move != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Move))
		i--
		dAtA[i] = 0x68
	}
	if m.CorpseTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.CorpseTime))
		i--
		dAtA[i] = 0x60
	}
	if m.DeathRefreshTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DeathRefreshTime))
		i--
		dAtA[i] = 0x58
	}
	if m.PursuitRange != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.PursuitRange))
		i--
		dAtA[i] = 0x50
	}
	if m.LockRange != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LockRange))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Inhibit) > 0 {
		dAtA41 := make([]byte, len(m.Inhibit)*10)
		var j40 int
		for _, num1 := range m.Inhibit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintOut(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0x42
	}
	if m.Modle3DSize != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Modle3DSize))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BuffId) > 0 {
		dAtA43 := make([]byte, len(m.BuffId)*10)
		var j42 int
		for _, num1 := range m.BuffId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintOut(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SkillId) > 0 {
		dAtA45 := make([]byte, len(m.SkillId)*10)
		var j44 int
		for _, num1 := range m.SkillId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintOut(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AtKSkill) > 0 {
		dAtA47 := make([]byte, len(m.AtKSkill)*10)
		var j46 int
		for _, num1 := range m.AtKSkill {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintOut(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x22
	}
	if m.MonsterAttackType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.MonsterAttackType))
		i--
		dAtA[i] = 0x18
	}
	if m.MonsterType != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.MonsterType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MonsterGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonsterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonsterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AreaId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AreaId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MonsterId) > 0 {
		dAtA49 := make([]byte, len(m.MonsterId)*10)
		var j48 int
		for _, num1 := range m.MonsterId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintOut(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Robot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Robot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Robot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BuffId) > 0 {
		dAtA51 := make([]byte, len(m.BuffId)*10)
		var j50 int
		for _, num1 := range m.BuffId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA51[:j50])
		i = encodeVarintOut(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SkillId) > 0 {
		dAtA53 := make([]byte, len(m.SkillId)*10)
		var j52 int
		for _, num1 := range m.SkillId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintOut(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Attr) > 0 {
		for k := range m.Attr {
			v := m.Attr[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ConfigId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ConfigId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoguelikeArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoguelikeArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoguelikeArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttrId) > 0 {
		dAtA55 := make([]byte, len(m.AttrId)*10)
		var j54 int
		for _, num1 := range m.AttrId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		i -= j54
		copy(dAtA[i:], dAtA55[:j54])
		i = encodeVarintOut(dAtA, i, uint64(j54))
		i--
		dAtA[i] = 0x32
	}
	if m.Weight != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OccupationFirst) > 0 {
		dAtA57 := make([]byte, len(m.OccupationFirst)*10)
		var j56 int
		for _, num1 := range m.OccupationFirst {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		i -= j56
		copy(dAtA[i:], dAtA57[:j56])
		i = encodeVarintOut(dAtA, i, uint64(j56))
		i--
		dAtA[i] = 0x22
	}
	if m.Quality != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x18
	}
	if m.QualityId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.QualityId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoguelikeDungeon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoguelikeDungeon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoguelikeDungeon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoguelikeDungeonRoom) > 0 {
		for k := range m.RoguelikeDungeonRoom {
			v := m.RoguelikeDungeonRoom[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintOut(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapBehaviorTree) > 0 {
		i -= len(m.MapBehaviorTree)
		copy(dAtA[i:], m.MapBehaviorTree)
		i = encodeVarintOut(dAtA, i, uint64(len(m.MapBehaviorTree)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.DungeonRewardWei) > 0 {
		dAtA60 := make([]byte, len(m.DungeonRewardWei)*10)
		var j59 int
		for _, num1 := range m.DungeonRewardWei {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintOut(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DungeonReward) > 0 {
		for k := range m.DungeonReward {
			v := m.DungeonReward[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.DungeonRewardPro != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DungeonRewardPro))
		i--
		dAtA[i] = 0x70
	}
	if m.ResurrectionTimeIMax != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ResurrectionTimeIMax))
		i--
		dAtA[i] = 0x68
	}
	if m.ResurrectionTimeInc != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ResurrectionTimeInc))
		i--
		dAtA[i] = 0x60
	}
	if m.ResurrectionTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ResurrectionTime))
		i--
		dAtA[i] = 0x58
	}
	if m.ResurrectionItemMax != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ResurrectionItemMax))
		i--
		dAtA[i] = 0x50
	}
	if m.ResurrectionItemAdd != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ResurrectionItemAdd))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ResurrectionItem) > 0 {
		for k := range m.ResurrectionItem {
			v := m.ResurrectionItem[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DungeonSize) > 0 {
		dAtA62 := make([]byte, len(m.DungeonSize)*10)
		var j61 int
		for _, num1 := range m.DungeonSize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintOut(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DungeonLv) > 0 {
		dAtA64 := make([]byte, len(m.DungeonLv)*10)
		var j63 int
		for _, num1 := range m.DungeonLv {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		i -= j63
		copy(dAtA[i:], dAtA64[:j63])
		i = encodeVarintOut(dAtA, i, uint64(j63))
		i--
		dAtA[i] = 0x32
	}
	if m.Times != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BossMechanical) > 0 {
		dAtA66 := make([]byte, len(m.BossMechanical)*10)
		var j65 int
		for _, num1 := range m.BossMechanical {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintOut(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x22
	}
	if m.BossCap != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BossCap))
		i--
		dAtA[i] = 0x18
	}
	if m.DungeonDay != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DungeonDay))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoguelikeDungeonRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoguelikeDungeonRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoguelikeDungeonRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardWeight) > 0 {
		dAtA68 := make([]byte, len(m.RewardWeight)*10)
		var j67 int
		for _, num1 := range m.RewardWeight {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		i -= j67
		copy(dAtA[i:], dAtA68[:j67])
		i = encodeVarintOut(dAtA, i, uint64(j67))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOut(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.RoomTyp != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.RoomTyp))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.RoguelikeDungeonId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.RoguelikeDungeonId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleLv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleLv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleLv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkillPowerNum != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SkillPowerNum))
		i--
		dAtA[i] = 0x68
	}
	if m.CompressLv != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.CompressLv))
		i--
		dAtA[i] = 0x60
	}
	if m.PowerNum != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.PowerNum))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ParameterQuality) > 0 {
		for k := range m.ParameterQuality {
			v := m.ParameterQuality[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.DivinationWeight) > 0 {
		for k := range m.DivinationWeight {
			v := m.DivinationWeight[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DivinationExp != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DivinationExp))
		i--
		dAtA[i] = 0x40
	}
	if m.Exp != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x38
	}
	if m.SmallLv != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SmallLv))
		i--
		dAtA[i] = 0x30
	}
	if m.LvHero != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LvHero))
		i--
		dAtA[i] = 0x28
	}
	if m.CopyId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.CopyId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AdvancedItem) > 0 {
		for k := range m.AdvancedItem {
			v := m.AdvancedItem[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AdvancedHero != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AdvancedHero))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleReachDungeon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleReachDungeon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleReachDungeon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BossId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BossId))
		i--
		dAtA[i] = 0x30
	}
	if m.MapSceneId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.MapSceneId))
		i--
		dAtA[i] = 0x28
	}
	if m.FailCondition != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.FailCondition))
		i--
		dAtA[i] = 0x20
	}
	if m.VictoryCondition != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.VictoryCondition))
		i--
		dAtA[i] = 0x18
	}
	if m.Times != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowHero) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowHero) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowHero) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BeRepulseParam != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BeRepulseParam))
		i--
		dAtA[i] = 0x70
	}
	if m.BeHitFlyParam != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.BeHitFlyParam))
		i--
		dAtA[i] = 0x68
	}
	if m.Move != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Move))
		i--
		dAtA[i] = 0x60
	}
	if m.DeathAnimationTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.DeathAnimationTime))
		i--
		dAtA[i] = 0x58
	}
	if m.LockRange != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LockRange))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Inhibit) > 0 {
		dAtA70 := make([]byte, len(m.Inhibit)*10)
		var j69 int
		for _, num1 := range m.Inhibit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintOut(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SkillId) > 0 {
		dAtA72 := make([]byte, len(m.SkillId)*10)
		var j71 int
		for _, num1 := range m.SkillId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintOut(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x42
	}
	if m.IntervalTime != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.IntervalTime))
		i--
		dAtA[i] = 0x38
	}
	if len(m.AtKSkill) > 0 {
		dAtA74 := make([]byte, len(m.AtKSkill)*10)
		var j73 int
		for _, num1 := range m.AtKSkill {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA74[j73] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j73++
			}
			dAtA74[j73] = uint8(num)
			j73++
		}
		i -= j73
		copy(dAtA[i:], dAtA74[:j73])
		i = encodeVarintOut(dAtA, i, uint64(j73))
		i--
		dAtA[i] = 0x32
	}
	if m.Modle3DSize != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Modle3DSize))
		i--
		dAtA[i] = 0x28
	}
	if m.ArmorId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ArmorId))
		i--
		dAtA[i] = 0x20
	}
	if m.ArmsId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ArmsId))
		i--
		dAtA[i] = 0x18
	}
	if m.OriginID != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.OriginID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Skill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Skill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Skill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SkillAddBuff) > 0 {
		i -= len(m.SkillAddBuff)
		copy(dAtA[i:], m.SkillAddBuff)
		i = encodeVarintOut(dAtA, i, uint64(len(m.SkillAddBuff)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.AtkAddition) > 0 {
		for k := range m.AtkAddition {
			v := m.AtkAddition[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.SkillBaceDam) > 0 {
		for k := range m.SkillBaceDam {
			v := m.SkillBaceDam[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SkillCD != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SkillCD))
		i--
		dAtA[i] = 0x58
	}
	if m.Target != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x50
	}
	if m.SkillTarget != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SkillTarget))
		i--
		dAtA[i] = 0x48
	}
	if m.AtkRange != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.AtkRange))
		i--
		dAtA[i] = 0x40
	}
	if m.SkillInterrupt {
		i--
		if m.SkillInterrupt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SkillWeight != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SkillWeight))
		i--
		dAtA[i] = 0x30
	}
	if m.IsNomalSkill {
		i--
		if m.IsNomalSkill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.LogicId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.LogicId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SkillView) > 0 {
		i -= len(m.SkillView)
		copy(dAtA[i:], m.SkillView)
		i = encodeVarintOut(dAtA, i, uint64(len(m.SkillView)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SkillBaseId != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.SkillBaseId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Summoned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Summoned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Summoned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SummonedBuff) > 0 {
		dAtA76 := make([]byte, len(m.SummonedBuff)*10)
		var j75 int
		for _, num1 := range m.SummonedBuff {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA76[j75] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j75++
			}
			dAtA76[j75] = uint8(num)
			j75++
		}
		i -= j75
		copy(dAtA[i:], dAtA76[:j75])
		i = encodeVarintOut(dAtA, i, uint64(j75))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SurvivalTime) > 0 {
		for k := range m.SurvivalTime {
			v := m.SurvivalTime[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MonsterAttr) > 0 {
		for k := range m.MonsterAttr {
			v := m.MonsterAttr[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MonsterId) > 0 {
		for k := range m.MonsterId {
			v := m.MonsterId[k]
			baseI := i
			i = encodeVarintOut(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintOut(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintOut(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TempBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TempBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TempBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProfitUpper != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.ProfitUpper))
		i--
		dAtA[i] = 0x20
	}
	if m.RoleLevel != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.RoleLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.TempBagLevel != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.TempBagLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOut(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOut(dAtA []byte, offset int, v uint64) int {
	offset -= sovOut(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

var _ = coin_server_common_proto_jsonany.Any{}

func (m *RptInt64) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("slice")
	w.RawByte('"')
	w.RawByte(':')
	if m.Slice == nil {
		w.RawString("null")
	} else if len(m.Slice) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Slice {
			w.Int64(int64(v))
			if i != len(m.Slice)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Tables) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	w.RawByte('"')
	w.RawString("key_value")
	w.RawByte('"')
	w.RawByte(':')
	if m.KeyValue == nil {
		w.RawString("null")
	} else if len(m.KeyValue) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlKeyValue := len(m.KeyValue)
		for k, v := range m.KeyValue {
			w.RawByte('"')
			w.RawString(k)
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlKeyValue--
			if mlKeyValue != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("attr")
	w.RawByte('"')
	w.RawByte(':')
	if m.Attr == nil {
		w.RawString("null")
	} else if len(m.Attr) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttr := len(m.Attr)
		for k, v := range m.Attr {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlAttr--
			if mlAttr != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("attr_trans")
	w.RawByte('"')
	w.RawByte(':')
	if m.AttrTrans == nil {
		w.RawString("null")
	} else if len(m.AttrTrans) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttrTrans := len(m.AttrTrans)
		for k, v := range m.AttrTrans {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlAttrTrans--
			if mlAttrTrans != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("buff")
	w.RawByte('"')
	w.RawByte(':')
	if m.Buff == nil {
		w.RawString("null")
	} else if len(m.Buff) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlBuff := len(m.Buff)
		for k, v := range m.Buff {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlBuff--
			if mlBuff != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("buff_effect")
	w.RawByte('"')
	w.RawByte(':')
	if m.BuffEffect == nil {
		w.RawString("null")
	} else if len(m.BuffEffect) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlBuffEffect := len(m.BuffEffect)
		for k, v := range m.BuffEffect {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlBuffEffect--
			if mlBuffEffect != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("drop")
	w.RawByte('"')
	w.RawByte(':')
	if m.Drop == nil {
		w.RawString("null")
	} else if len(m.Drop) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDrop := len(m.Drop)
		for k, v := range m.Drop {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlDrop--
			if mlDrop != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("drop_lists")
	w.RawByte('"')
	w.RawByte(':')
	if m.DropLists == nil {
		w.RawString("null")
	} else if len(m.DropLists) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDropLists := len(m.DropLists)
		for k, v := range m.DropLists {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlDropLists--
			if mlDropLists != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("dungeon")
	w.RawByte('"')
	w.RawByte(':')
	if m.Dungeon == nil {
		w.RawString("null")
	} else if len(m.Dungeon) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDungeon := len(m.Dungeon)
		for k, v := range m.Dungeon {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlDungeon--
			if mlDungeon != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("inhibit_atk")
	w.RawByte('"')
	w.RawByte(':')
	if m.InhibitAtk == nil {
		w.RawString("null")
	} else if len(m.InhibitAtk) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlInhibitAtk := len(m.InhibitAtk)
		for k, v := range m.InhibitAtk {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlInhibitAtk--
			if mlInhibitAtk != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("map_scene")
	w.RawByte('"')
	w.RawByte(':')
	if m.MapScene == nil {
		w.RawString("null")
	} else if len(m.MapScene) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMapScene := len(m.MapScene)
		for k, v := range m.MapScene {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlMapScene--
			if mlMapScene != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("mechanics")
	w.RawByte('"')
	w.RawByte(':')
	if m.Mechanics == nil {
		w.RawString("null")
	} else if len(m.Mechanics) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMechanics := len(m.Mechanics)
		for k, v := range m.Mechanics {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlMechanics--
			if mlMechanics != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("medicament")
	w.RawByte('"')
	w.RawByte(':')
	if m.Medicament == nil {
		w.RawString("null")
	} else if len(m.Medicament) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMedicament := len(m.Medicament)
		for k, v := range m.Medicament {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlMedicament--
			if mlMedicament != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("monster")
	w.RawByte('"')
	w.RawByte(':')
	if m.Monster == nil {
		w.RawString("null")
	} else if len(m.Monster) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMonster := len(m.Monster)
		for k, v := range m.Monster {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlMonster--
			if mlMonster != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("monster_group")
	w.RawByte('"')
	w.RawByte(':')
	if m.MonsterGroup == nil {
		w.RawString("null")
	} else if len(m.MonsterGroup) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMonsterGroup := len(m.MonsterGroup)
		for k, v := range m.MonsterGroup {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlMonsterGroup--
			if mlMonsterGroup != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("robot")
	w.RawByte('"')
	w.RawByte(':')
	if m.Robot == nil {
		w.RawString("null")
	} else if len(m.Robot) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRobot := len(m.Robot)
		for k, v := range m.Robot {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRobot--
			if mlRobot != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("roguelike_artifact")
	w.RawByte('"')
	w.RawByte(':')
	if m.RoguelikeArtifact == nil {
		w.RawString("null")
	} else if len(m.RoguelikeArtifact) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRoguelikeArtifact := len(m.RoguelikeArtifact)
		for k, v := range m.RoguelikeArtifact {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRoguelikeArtifact--
			if mlRoguelikeArtifact != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("roguelike_dungeon")
	w.RawByte('"')
	w.RawByte(':')
	if m.RoguelikeDungeon == nil {
		w.RawString("null")
	} else if len(m.RoguelikeDungeon) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRoguelikeDungeon := len(m.RoguelikeDungeon)
		for k, v := range m.RoguelikeDungeon {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRoguelikeDungeon--
			if mlRoguelikeDungeon != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("role_lv")
	w.RawByte('"')
	w.RawByte(':')
	if m.RoleLv == nil {
		w.RawString("null")
	} else if len(m.RoleLv) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRoleLv := len(m.RoleLv)
		for k, v := range m.RoleLv {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRoleLv--
			if mlRoleLv != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("role_reach_dungeon")
	w.RawByte('"')
	w.RawByte(':')
	if m.RoleReachDungeon == nil {
		w.RawString("null")
	} else if len(m.RoleReachDungeon) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRoleReachDungeon := len(m.RoleReachDungeon)
		for k, v := range m.RoleReachDungeon {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRoleReachDungeon--
			if mlRoleReachDungeon != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("row_hero")
	w.RawByte('"')
	w.RawByte(':')
	if m.RowHero == nil {
		w.RawString("null")
	} else if len(m.RowHero) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRowHero := len(m.RowHero)
		for k, v := range m.RowHero {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRowHero--
			if mlRowHero != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("skill")
	w.RawByte('"')
	w.RawByte(':')
	if m.Skill == nil {
		w.RawString("null")
	} else if len(m.Skill) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlSkill := len(m.Skill)
		for k, v := range m.Skill {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlSkill--
			if mlSkill != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("summoned")
	w.RawByte('"')
	w.RawByte(':')
	if m.Summoned == nil {
		w.RawString("null")
	} else if len(m.Summoned) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlSummoned := len(m.Summoned)
		for k, v := range m.Summoned {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlSummoned--
			if mlSummoned != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("temp_bag")
	w.RawByte('"')
	w.RawByte(':')
	if m.TempBag == nil {
		w.RawString("null")
	} else if len(m.TempBag) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlTempBag := len(m.TempBag)
		for k, v := range m.TempBag {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlTempBag--
			if mlTempBag != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *KeyValue) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Key != "" {
		w.RawByte('"')
		w.RawString("key")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Key)
		needWriteComma = true
	}
	if m.Value != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("value")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Value)
		needWriteComma = true
	}
	if m.Type != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("type")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Type)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Attr) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.AdvancedType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AdvancedType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AdvancedType))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *AttrTrans) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.AttrID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("attrID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AttrID))
		needWriteComma = true
	}
	if m.Transtype != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("transtype")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Transtype))
		needWriteComma = true
	}
	if m.TransattrID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("transattrID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.TransattrID))
		needWriteComma = true
	}
	if m.Transnum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("transnum")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Transnum))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("limithero")
	w.RawByte('"')
	w.RawByte(':')
	if m.Limithero == nil {
		w.RawString("null")
	} else if len(m.Limithero) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Limithero {
			w.Int64(int64(v))
			if i != len(m.Limithero)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Buff) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.BuffLv != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BuffLv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuffLv))
		needWriteComma = true
	}
	if m.BuffConditionType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BuffConditionType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuffConditionType))
		needWriteComma = true
	}
	if m.LogicId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LogicId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LogicId))
		needWriteComma = true
	}
	if m.LogicArgs != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LogicArgs")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.LogicArgs)
		needWriteComma = true
	}
	if m.BuffEffectType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BuffEffectType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuffEffectType))
		needWriteComma = true
	}
	if m.BuffTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BuffTime")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuffTime))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("BuffType")
	w.RawByte('"')
	w.RawByte(':')
	if m.BuffType == nil {
		w.RawString("null")
	} else if len(m.BuffType) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.BuffType {
			w.Int64(int64(v))
			if i != len(m.BuffType)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AttrFixed")
	w.RawByte('"')
	w.RawByte(':')
	if m.AttrFixed == nil {
		w.RawString("null")
	} else if len(m.AttrFixed) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttrFixed := len(m.AttrFixed)
		for k, v := range m.AttrFixed {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAttrFixed--
			if mlAttrFixed != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AttrPercentage")
	w.RawByte('"')
	w.RawByte(':')
	if m.AttrPercentage == nil {
		w.RawString("null")
	} else if len(m.AttrPercentage) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttrPercentage := len(m.AttrPercentage)
		for k, v := range m.AttrPercentage {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAttrPercentage--
			if mlAttrPercentage != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *BuffEffect) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.AttributeID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AttributeID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AttributeID))
		needWriteComma = true
	}
	if m.LogicId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LogicId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LogicId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Drop) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Desc != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("desc")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.Desc)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("drop_mini")
	w.RawByte('"')
	w.RawByte(':')
	if m.DropMini == nil {
		w.RawString("null")
	} else if len(m.DropMini) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDropMini := len(m.DropMini)
		for k, v := range m.DropMini {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlDropMini--
			if mlDropMini != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *DropMini) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.DropId != 0 {
		w.RawByte('"')
		w.RawString("drop_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DropId))
		needWriteComma = true
	}
	if m.Id != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("itemId")
	w.RawByte('"')
	w.RawByte(':')
	if m.ItemId == nil {
		w.RawString("null")
	} else if len(m.ItemId) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlItemId := len(m.ItemId)
		for k, v := range m.ItemId {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlItemId--
			if mlItemId != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.ItemWeight != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("itemWeight")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ItemWeight))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *DropLists) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("drop_lists_mini")
	w.RawByte('"')
	w.RawByte(':')
	if m.DropListsMini == nil {
		w.RawString("null")
	} else if len(m.DropListsMini) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDropListsMini := len(m.DropListsMini)
		for k, v := range m.DropListsMini {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlDropListsMini--
			if mlDropListsMini != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *DropListsMini) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.DropListsId != 0 {
		w.RawByte('"')
		w.RawString("drop_lists_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DropListsId))
		needWriteComma = true
	}
	if m.Id != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.DropId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("dropId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DropId))
		needWriteComma = true
	}
	if m.DropProb != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("dropProb")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DropProb))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Dungeon) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Times != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Times))
		needWriteComma = true
	}
	if m.PlayersLv != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("PlayersLv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PlayersLv))
		needWriteComma = true
	}
	if m.CombatCap != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("CombatCap")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CombatCap))
		needWriteComma = true
	}
	if m.DungeonPlayerNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DungeonPlayerNum")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DungeonPlayerNum))
		needWriteComma = true
	}
	if m.MapBehaviorTree != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("MapBehaviorTree")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.MapBehaviorTree)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *InhibitAtk) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.AtkType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AtkType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AtkType))
		needWriteComma = true
	}
	if m.DefType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DefType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DefType))
		needWriteComma = true
	}
	if m.AtkEffect != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AtkEffect")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AtkEffect))
		needWriteComma = true
	}
	if m.SkillId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SkillId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MapScene) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.MapType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("MapType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MapType))
		needWriteComma = true
	}
	if m.CfgMap != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("CfgMap")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.CfgMap)
		needWriteComma = true
	}
	if m.BinMap != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BinMap")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.BinMap)
		needWriteComma = true
	}
	if m.DungeonID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DungeonID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DungeonID))
		needWriteComma = true
	}
	if m.LevelMapID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LevelMapID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LevelMapID))
		needWriteComma = true
	}
	if m.RoguelikeID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("RoguelikeID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RoguelikeID))
		needWriteComma = true
	}
	if m.GoldProfit != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("GoldProfit")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.GoldProfit))
		needWriteComma = true
	}
	if m.LineMaxPersonsNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LineMaxPersonsNum")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LineMaxPersonsNum))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("MedicamentId")
	w.RawByte('"')
	w.RawByte(':')
	if m.MedicamentId == nil {
		w.RawString("null")
	} else if len(m.MedicamentId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.MedicamentId {
			w.Int64(int64(v))
			if i != len(m.MedicamentId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Mechanics) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Idx != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("idx")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Idx))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("active_begin")
	w.RawByte('"')
	w.RawByte(':')
	if m.ActiveBegin == nil {
		w.RawString("null")
	} else if len(m.ActiveBegin) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.ActiveBegin {
			w.Int64(int64(v))
			if i != len(m.ActiveBegin)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("circulate")
	w.RawByte('"')
	w.RawByte(':')
	if m.Circulate == nil {
		w.RawString("null")
	} else if len(m.Circulate) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Circulate {
			w.Int64(int64(v))
			if i != len(m.Circulate)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("damage_percent")
	w.RawByte('"')
	w.RawByte(':')
	if m.DamagePercent == nil {
		w.RawString("null")
	} else if len(m.DamagePercent) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.DamagePercent {
			w.Int64(int64(v))
			if i != len(m.DamagePercent)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.DueTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("due_time")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DueTime))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("value")
	w.RawByte('"')
	w.RawByte(':')
	if m.Value == nil {
		w.RawString("null")
	} else if len(m.Value) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Value {
			v.JsonBytes(w)
			if i != len(m.Value)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Medicament) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Level != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Level))
		needWriteComma = true
	}
	if m.Typ != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Typ")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Typ))
		needWriteComma = true
	}
	if m.CD != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("CD")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CD))
		needWriteComma = true
	}
	if m.BuffId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BuffId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BuffId))
		needWriteComma = true
	}
	if m.Limit != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Limit")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Limit))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Monster) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.MonsterType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("MonsterType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MonsterType))
		needWriteComma = true
	}
	if m.MonsterAttackType != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("MonsterAttackType")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MonsterAttackType))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AtKSkill")
	w.RawByte('"')
	w.RawByte(':')
	if m.AtKSkill == nil {
		w.RawString("null")
	} else if len(m.AtKSkill) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.AtKSkill {
			w.Int64(int64(v))
			if i != len(m.AtKSkill)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("SkillId")
	w.RawByte('"')
	w.RawByte(':')
	if m.SkillId == nil {
		w.RawString("null")
	} else if len(m.SkillId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.SkillId {
			w.Int64(int64(v))
			if i != len(m.SkillId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("BuffId")
	w.RawByte('"')
	w.RawByte(':')
	if m.BuffId == nil {
		w.RawString("null")
	} else if len(m.BuffId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.BuffId {
			w.Int64(int64(v))
			if i != len(m.BuffId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Modle3DSize != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Modle3dSize")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Modle3DSize))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("Inhibit")
	w.RawByte('"')
	w.RawByte(':')
	if m.Inhibit == nil {
		w.RawString("null")
	} else if len(m.Inhibit) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Inhibit {
			w.Int64(int64(v))
			if i != len(m.Inhibit)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.LockRange != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LockRange")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LockRange))
		needWriteComma = true
	}
	if m.PursuitRange != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("PursuitRange")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PursuitRange))
		needWriteComma = true
	}
	if m.DeathRefreshTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DeathRefreshTime")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DeathRefreshTime))
		needWriteComma = true
	}
	if m.CorpseTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("CorpseTime")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CorpseTime))
		needWriteComma = true
	}
	if m.Move != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Move")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Move))
		needWriteComma = true
	}
	if m.BeHitFlyParam != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BeHitFlyParam")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BeHitFlyParam))
		needWriteComma = true
	}
	if m.BeRepulseParam != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BeRepulseParam")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BeRepulseParam))
		needWriteComma = true
	}
	if m.DeadItemsRange != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DeadItemsRange")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DeadItemsRange))
		needWriteComma = true
	}
	if m.DropListId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DropListId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DropListId))
		needWriteComma = true
	}
	if m.NumHpBar != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("NumHpBar")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.NumHpBar))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("ParameterQuality")
	w.RawByte('"')
	w.RawByte(':')
	if m.ParameterQuality == nil {
		w.RawString("null")
	} else if len(m.ParameterQuality) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlParameterQuality := len(m.ParameterQuality)
		for k, v := range m.ParameterQuality {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlParameterQuality--
			if mlParameterQuality != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *MonsterGroup) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("MonsterId")
	w.RawByte('"')
	w.RawByte(':')
	if m.MonsterId == nil {
		w.RawString("null")
	} else if len(m.MonsterId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.MonsterId {
			w.Int64(int64(v))
			if i != len(m.MonsterId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.AreaId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AreaId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AreaId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Robot) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.ConfigId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("config_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ConfigId))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("attr")
	w.RawByte('"')
	w.RawByte(':')
	if m.Attr == nil {
		w.RawString("null")
	} else if len(m.Attr) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAttr := len(m.Attr)
		for k, v := range m.Attr {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAttr--
			if mlAttr != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("SkillId")
	w.RawByte('"')
	w.RawByte(':')
	if m.SkillId == nil {
		w.RawString("null")
	} else if len(m.SkillId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.SkillId {
			w.Int64(int64(v))
			if i != len(m.SkillId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("BuffId")
	w.RawByte('"')
	w.RawByte(':')
	if m.BuffId == nil {
		w.RawString("null")
	} else if len(m.BuffId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.BuffId {
			w.Int64(int64(v))
			if i != len(m.BuffId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Lv != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("lv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Lv))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RoguelikeArtifact) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.QualityId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("QualityId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.QualityId))
		needWriteComma = true
	}
	if m.Quality != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Quality")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Quality))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("OccupationFirst")
	w.RawByte('"')
	w.RawByte(':')
	if m.OccupationFirst == nil {
		w.RawString("null")
	} else if len(m.OccupationFirst) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.OccupationFirst {
			w.Int64(int64(v))
			if i != len(m.OccupationFirst)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Weight != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Weight")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Weight))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AttrId")
	w.RawByte('"')
	w.RawByte(':')
	if m.AttrId == nil {
		w.RawString("null")
	} else if len(m.AttrId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.AttrId {
			w.Int64(int64(v))
			if i != len(m.AttrId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RoguelikeDungeon) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.DungeonDay != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DungeonDay")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DungeonDay))
		needWriteComma = true
	}
	if m.BossCap != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BossCap")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BossCap))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("BossMechanical")
	w.RawByte('"')
	w.RawByte(':')
	if m.BossMechanical == nil {
		w.RawString("null")
	} else if len(m.BossMechanical) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.BossMechanical {
			w.Int64(int64(v))
			if i != len(m.BossMechanical)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.Times != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Times))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("DungeonLv")
	w.RawByte('"')
	w.RawByte(':')
	if m.DungeonLv == nil {
		w.RawString("null")
	} else if len(m.DungeonLv) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.DungeonLv {
			w.Int64(int64(v))
			if i != len(m.DungeonLv)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("DungeonSize")
	w.RawByte('"')
	w.RawByte(':')
	if m.DungeonSize == nil {
		w.RawString("null")
	} else if len(m.DungeonSize) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.DungeonSize {
			w.Int64(int64(v))
			if i != len(m.DungeonSize)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("ResurrectionItem")
	w.RawByte('"')
	w.RawByte(':')
	if m.ResurrectionItem == nil {
		w.RawString("null")
	} else if len(m.ResurrectionItem) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlResurrectionItem := len(m.ResurrectionItem)
		for k, v := range m.ResurrectionItem {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlResurrectionItem--
			if mlResurrectionItem != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.ResurrectionItemAdd != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ResurrectionItemAdd")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ResurrectionItemAdd))
		needWriteComma = true
	}
	if m.ResurrectionItemMax != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ResurrectionItemMax")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ResurrectionItemMax))
		needWriteComma = true
	}
	if m.ResurrectionTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ResurrectionTime")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ResurrectionTime))
		needWriteComma = true
	}
	if m.ResurrectionTimeInc != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ResurrectionTimeInc")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ResurrectionTimeInc))
		needWriteComma = true
	}
	if m.ResurrectionTimeIMax != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ResurrectionTimeIMax")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ResurrectionTimeIMax))
		needWriteComma = true
	}
	if m.DungeonRewardPro != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DungeonRewardPro")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DungeonRewardPro))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("DungeonReward")
	w.RawByte('"')
	w.RawByte(':')
	if m.DungeonReward == nil {
		w.RawString("null")
	} else if len(m.DungeonReward) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDungeonReward := len(m.DungeonReward)
		for k, v := range m.DungeonReward {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlDungeonReward--
			if mlDungeonReward != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("DungeonRewardWei")
	w.RawByte('"')
	w.RawByte(':')
	if m.DungeonRewardWei == nil {
		w.RawString("null")
	} else if len(m.DungeonRewardWei) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.DungeonRewardWei {
			w.Int64(int64(v))
			if i != len(m.DungeonRewardWei)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.MapBehaviorTree != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("MapBehaviorTree")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.MapBehaviorTree)
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("roguelike_dungeon_room")
	w.RawByte('"')
	w.RawByte(':')
	if m.RoguelikeDungeonRoom == nil {
		w.RawString("null")
	} else if len(m.RoguelikeDungeonRoom) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlRoguelikeDungeonRoom := len(m.RoguelikeDungeonRoom)
		for k, v := range m.RoguelikeDungeonRoom {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			v.JsonBytes(w)
			mlRoguelikeDungeonRoom--
			if mlRoguelikeDungeonRoom != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RoguelikeDungeonRoom) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.RoguelikeDungeonId != 0 {
		w.RawByte('"')
		w.RawString("roguelike_dungeon_id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RoguelikeDungeonId))
		needWriteComma = true
	}
	if m.Id != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.RoomTyp != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("RoomTyp")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RoomTyp))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("Reward")
	w.RawByte('"')
	w.RawByte(':')
	if m.Reward == nil {
		w.RawString("null")
	} else if len(m.Reward) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Reward {
			v.JsonBytes(w)
			if i != len(m.Reward)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("RewardWeight")
	w.RawByte('"')
	w.RawByte(':')
	if m.RewardWeight == nil {
		w.RawString("null")
	} else if len(m.RewardWeight) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.RewardWeight {
			w.Int64(int64(v))
			if i != len(m.RewardWeight)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RoleLv) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.AdvancedHero != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AdvancedHero")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AdvancedHero))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AdvancedItem")
	w.RawByte('"')
	w.RawByte(':')
	if m.AdvancedItem == nil {
		w.RawString("null")
	} else if len(m.AdvancedItem) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAdvancedItem := len(m.AdvancedItem)
		for k, v := range m.AdvancedItem {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAdvancedItem--
			if mlAdvancedItem != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.CopyId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("CopyId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CopyId))
		needWriteComma = true
	}
	if m.LvHero != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LvHero")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LvHero))
		needWriteComma = true
	}
	if m.SmallLv != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SmallLv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SmallLv))
		needWriteComma = true
	}
	if m.Exp != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Exp")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Exp))
		needWriteComma = true
	}
	if m.DivinationExp != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DivinationExp")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DivinationExp))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("DivinationWeight")
	w.RawByte('"')
	w.RawByte(':')
	if m.DivinationWeight == nil {
		w.RawString("null")
	} else if len(m.DivinationWeight) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlDivinationWeight := len(m.DivinationWeight)
		for k, v := range m.DivinationWeight {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlDivinationWeight--
			if mlDivinationWeight != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("ParameterQuality")
	w.RawByte('"')
	w.RawByte(':')
	if m.ParameterQuality == nil {
		w.RawString("null")
	} else if len(m.ParameterQuality) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlParameterQuality := len(m.ParameterQuality)
		for k, v := range m.ParameterQuality {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlParameterQuality--
			if mlParameterQuality != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.PowerNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("PowerNum")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.PowerNum))
		needWriteComma = true
	}
	if m.CompressLv != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("CompressLv")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.CompressLv))
		needWriteComma = true
	}
	if m.SkillPowerNum != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillPowerNum")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SkillPowerNum))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RoleReachDungeon) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.Times != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Times")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Times))
		needWriteComma = true
	}
	if m.VictoryCondition != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("VictoryCondition")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.VictoryCondition))
		needWriteComma = true
	}
	if m.FailCondition != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("FailCondition")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.FailCondition))
		needWriteComma = true
	}
	if m.MapSceneId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("MapSceneId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.MapSceneId))
		needWriteComma = true
	}
	if m.BossId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BossId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BossId))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RowHero) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.OriginID != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("OriginID")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.OriginID))
		needWriteComma = true
	}
	if m.ArmsId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ArmsId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ArmsId))
		needWriteComma = true
	}
	if m.ArmorId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("ArmorId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ArmorId))
		needWriteComma = true
	}
	if m.Modle3DSize != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Modle3dSize")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Modle3DSize))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AtKSkill")
	w.RawByte('"')
	w.RawByte(':')
	if m.AtKSkill == nil {
		w.RawString("null")
	} else if len(m.AtKSkill) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.AtKSkill {
			w.Int64(int64(v))
			if i != len(m.AtKSkill)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.IntervalTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("IntervalTime")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.IntervalTime))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("SkillId")
	w.RawByte('"')
	w.RawByte(':')
	if m.SkillId == nil {
		w.RawString("null")
	} else if len(m.SkillId) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.SkillId {
			w.Int64(int64(v))
			if i != len(m.SkillId)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("Inhibit")
	w.RawByte('"')
	w.RawByte(':')
	if m.Inhibit == nil {
		w.RawString("null")
	} else if len(m.Inhibit) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.Inhibit {
			w.Int64(int64(v))
			if i != len(m.Inhibit)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	if m.LockRange != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LockRange")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LockRange))
		needWriteComma = true
	}
	if m.DeathAnimationTime != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("DeathAnimationTime")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.DeathAnimationTime))
		needWriteComma = true
	}
	if m.Move != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Move")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Move))
		needWriteComma = true
	}
	if m.BeHitFlyParam != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BeHitFlyParam")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BeHitFlyParam))
		needWriteComma = true
	}
	if m.BeRepulseParam != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("BeRepulseParam")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.BeRepulseParam))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Skill) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.SkillBaseId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillBaseId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SkillBaseId))
		needWriteComma = true
	}
	if m.SkillView != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillView")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.SkillView)
		needWriteComma = true
	}
	if m.LogicId != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("LogicId")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.LogicId))
		needWriteComma = true
	}
	if m.IsNomalSkill {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("IsNomalSkill")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.IsNomalSkill)
		needWriteComma = true
	}
	if m.SkillWeight != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillWeight")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SkillWeight))
		needWriteComma = true
	}
	if m.SkillInterrupt {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillInterrupt")
		w.RawByte('"')
		w.RawByte(':')
		w.Bool(m.SkillInterrupt)
		needWriteComma = true
	}
	if m.AtkRange != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("AtkRange")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.AtkRange))
		needWriteComma = true
	}
	if m.SkillTarget != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillTarget")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SkillTarget))
		needWriteComma = true
	}
	if m.Target != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("Target")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Target))
		needWriteComma = true
	}
	if m.SkillCD != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillCD")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.SkillCD))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("SkillBaceDam")
	w.RawByte('"')
	w.RawByte(':')
	if m.SkillBaceDam == nil {
		w.RawString("null")
	} else if len(m.SkillBaceDam) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlSkillBaceDam := len(m.SkillBaceDam)
		for k, v := range m.SkillBaceDam {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlSkillBaceDam--
			if mlSkillBaceDam != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("AtkAddition")
	w.RawByte('"')
	w.RawByte(':')
	if m.AtkAddition == nil {
		w.RawString("null")
	} else if len(m.AtkAddition) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlAtkAddition := len(m.AtkAddition)
		for k, v := range m.AtkAddition {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlAtkAddition--
			if mlAtkAddition != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if m.SkillAddBuff != "" {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("SkillAddBuff")
		w.RawByte('"')
		w.RawByte(':')
		w.String(m.SkillAddBuff)
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *Summoned) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("Id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("MonsterId")
	w.RawByte('"')
	w.RawByte(':')
	if m.MonsterId == nil {
		w.RawString("null")
	} else if len(m.MonsterId) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMonsterId := len(m.MonsterId)
		for k, v := range m.MonsterId {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlMonsterId--
			if mlMonsterId != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("MonsterAttr")
	w.RawByte('"')
	w.RawByte(':')
	if m.MonsterAttr == nil {
		w.RawString("null")
	} else if len(m.MonsterAttr) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlMonsterAttr := len(m.MonsterAttr)
		for k, v := range m.MonsterAttr {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlMonsterAttr--
			if mlMonsterAttr != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("SurvivalTime")
	w.RawByte('"')
	w.RawByte(':')
	if m.SurvivalTime == nil {
		w.RawString("null")
	} else if len(m.SurvivalTime) == 0 {
		w.RawString("{}")
	} else {
		w.RawByte('{')
		mlSurvivalTime := len(m.SurvivalTime)
		for k, v := range m.SurvivalTime {
			w.RawByte('"')
			w.Int64(int64(k))
			w.RawByte('"')
			w.RawByte(':')
			w.Int64(int64(v))
			mlSurvivalTime--
			if mlSurvivalTime != 0 {
				w.RawByte(',')
			}
		}
		w.RawByte('}')
	}
	needWriteComma = true
	if needWriteComma {
		w.RawByte(',')
	}
	w.RawByte('"')
	w.RawString("SummonedBuff")
	w.RawByte('"')
	w.RawByte(':')
	if m.SummonedBuff == nil {
		w.RawString("null")
	} else if len(m.SummonedBuff) == 0 {
		w.RawString("[]")
	} else {
		w.RawByte('[')
		for i, v := range m.SummonedBuff {
			w.Int64(int64(v))
			if i != len(m.SummonedBuff)-1 {
				w.RawByte(',')
			}
		}
		w.RawByte(']')
	}
	needWriteComma = true
	_ = needWriteComma
	w.RawByte('}')

}

func (m *TempBag) JsonBytes(w *coin_server_common_jwriter.Writer) {
	if m == nil {
		w.RawString("null")
		return
	}

	w.RawByte('{')
	needWriteComma := false
	if m.Id != 0 {
		w.RawByte('"')
		w.RawString("id")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.Id))
		needWriteComma = true
	}
	if m.TempBagLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("temp_bag_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.TempBagLevel))
		needWriteComma = true
	}
	if m.RoleLevel != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("role_level")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.RoleLevel))
		needWriteComma = true
	}
	if m.ProfitUpper != 0 {
		if needWriteComma {
			w.RawByte(',')
		}
		w.RawByte('"')
		w.RawString("profit_upper")
		w.RawByte('"')
		w.RawByte(':')
		w.Int64(int64(m.ProfitUpper))
		needWriteComma = true
	}
	_ = needWriteComma
	w.RawByte('}')

}

func (m *RptInt64) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RptInt64) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RptInt64) GoString() string {
	return m.String()
}

func (m *Tables) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Tables) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Tables) GoString() string {
	return m.String()
}

func (m *KeyValue) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *KeyValue) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *KeyValue) GoString() string {
	return m.String()
}

func (m *Attr) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Attr) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Attr) GoString() string {
	return m.String()
}

func (m *AttrTrans) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *AttrTrans) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *AttrTrans) GoString() string {
	return m.String()
}

func (m *Buff) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Buff) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Buff) GoString() string {
	return m.String()
}

func (m *BuffEffect) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *BuffEffect) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *BuffEffect) GoString() string {
	return m.String()
}

func (m *Drop) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Drop) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Drop) GoString() string {
	return m.String()
}

func (m *DropMini) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *DropMini) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *DropMini) GoString() string {
	return m.String()
}

func (m *DropLists) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *DropLists) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *DropLists) GoString() string {
	return m.String()
}

func (m *DropListsMini) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *DropListsMini) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *DropListsMini) GoString() string {
	return m.String()
}

func (m *Dungeon) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Dungeon) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Dungeon) GoString() string {
	return m.String()
}

func (m *InhibitAtk) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *InhibitAtk) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *InhibitAtk) GoString() string {
	return m.String()
}

func (m *MapScene) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MapScene) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MapScene) GoString() string {
	return m.String()
}

func (m *Mechanics) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Mechanics) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Mechanics) GoString() string {
	return m.String()
}

func (m *Medicament) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Medicament) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Medicament) GoString() string {
	return m.String()
}

func (m *Monster) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Monster) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Monster) GoString() string {
	return m.String()
}

func (m *MonsterGroup) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *MonsterGroup) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *MonsterGroup) GoString() string {
	return m.String()
}

func (m *Robot) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Robot) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Robot) GoString() string {
	return m.String()
}

func (m *RoguelikeArtifact) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RoguelikeArtifact) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RoguelikeArtifact) GoString() string {
	return m.String()
}

func (m *RoguelikeDungeon) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RoguelikeDungeon) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RoguelikeDungeon) GoString() string {
	return m.String()
}

func (m *RoguelikeDungeonRoom) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RoguelikeDungeonRoom) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RoguelikeDungeonRoom) GoString() string {
	return m.String()
}

func (m *RoleLv) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RoleLv) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RoleLv) GoString() string {
	return m.String()
}

func (m *RoleReachDungeon) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RoleReachDungeon) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RoleReachDungeon) GoString() string {
	return m.String()
}

func (m *RowHero) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *RowHero) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *RowHero) GoString() string {
	return m.String()
}

func (m *Skill) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Skill) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Skill) GoString() string {
	return m.String()
}

func (m *Summoned) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *Summoned) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *Summoned) GoString() string {
	return m.String()
}

func (m *TempBag) MarshalJSON() ([]byte, error) {
	w := coin_server_common_jwriter.Writer{Buffer: coin_server_common_buffer.Buffer{Buf: make([]byte, 0, 2048)}}
	m.JsonBytes(&w)
	return w.BuildBytes()
}
func (m *TempBag) String() string {
	d, _ := m.MarshalJSON()
	return *(*string)(unsafe.Pointer(&d))
}
func (m *TempBag) GoString() string {
	return m.String()
}

func (m *RptInt64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Slice) > 0 {
		l = 0
		for _, e := range m.Slice {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	return n
}

func (m *Tables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeyValue) > 0 {
		for k, v := range m.KeyValue {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOut(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.AttrTrans) > 0 {
		for k, v := range m.AttrTrans {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Buff) > 0 {
		for k, v := range m.Buff {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.BuffEffect) > 0 {
		for k, v := range m.BuffEffect {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Drop) > 0 {
		for k, v := range m.Drop {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.DropLists) > 0 {
		for k, v := range m.DropLists {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Dungeon) > 0 {
		for k, v := range m.Dungeon {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.InhibitAtk) > 0 {
		for k, v := range m.InhibitAtk {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.MapScene) > 0 {
		for k, v := range m.MapScene {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Mechanics) > 0 {
		for k, v := range m.Mechanics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Medicament) > 0 {
		for k, v := range m.Medicament {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Monster) > 0 {
		for k, v := range m.Monster {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.MonsterGroup) > 0 {
		for k, v := range m.MonsterGroup {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Robot) > 0 {
		for k, v := range m.Robot {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.RoguelikeArtifact) > 0 {
		for k, v := range m.RoguelikeArtifact {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.RoguelikeDungeon) > 0 {
		for k, v := range m.RoguelikeDungeon {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.RoleLv) > 0 {
		for k, v := range m.RoleLv {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.RoleReachDungeon) > 0 {
		for k, v := range m.RoleReachDungeon {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.RowHero) > 0 {
		for k, v := range m.RowHero {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Skill) > 0 {
		for k, v := range m.Skill {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.Summoned) > 0 {
		for k, v := range m.Summoned {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.TempBag) > 0 {
		for k, v := range m.TempBag {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	return n
}

func (m *Attr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.AdvancedType != 0 {
		n += 1 + sovOut(uint64(m.AdvancedType))
	}
	return n
}

func (m *AttrTrans) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.AttrID != 0 {
		n += 1 + sovOut(uint64(m.AttrID))
	}
	if m.Transtype != 0 {
		n += 1 + sovOut(uint64(m.Transtype))
	}
	if m.TransattrID != 0 {
		n += 1 + sovOut(uint64(m.TransattrID))
	}
	if m.Transnum != 0 {
		n += 1 + sovOut(uint64(m.Transnum))
	}
	if len(m.Limithero) > 0 {
		l = 0
		for _, e := range m.Limithero {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	return n
}

func (m *Buff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.BuffLv != 0 {
		n += 1 + sovOut(uint64(m.BuffLv))
	}
	if m.BuffConditionType != 0 {
		n += 1 + sovOut(uint64(m.BuffConditionType))
	}
	if m.LogicId != 0 {
		n += 1 + sovOut(uint64(m.LogicId))
	}
	l = len(m.LogicArgs)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	if m.BuffEffectType != 0 {
		n += 1 + sovOut(uint64(m.BuffEffectType))
	}
	if m.BuffTime != 0 {
		n += 1 + sovOut(uint64(m.BuffTime))
	}
	if len(m.BuffType) > 0 {
		l = 0
		for _, e := range m.BuffType {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.AttrFixed) > 0 {
		for k, v := range m.AttrFixed {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.AttrPercentage) > 0 {
		for k, v := range m.AttrPercentage {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BuffEffect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.AttributeID != 0 {
		n += 1 + sovOut(uint64(m.AttributeID))
	}
	if m.LogicId != 0 {
		n += 1 + sovOut(uint64(m.LogicId))
	}
	return n
}

func (m *Drop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	if len(m.DropMini) > 0 {
		for k, v := range m.DropMini {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DropMini) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropId != 0 {
		n += 1 + sovOut(uint64(m.DropId))
	}
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if len(m.ItemId) > 0 {
		for k, v := range m.ItemId {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if m.ItemWeight != 0 {
		n += 1 + sovOut(uint64(m.ItemWeight))
	}
	return n
}

func (m *DropLists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if len(m.DropListsMini) > 0 {
		for k, v := range m.DropListsMini {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DropListsMini) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropListsId != 0 {
		n += 1 + sovOut(uint64(m.DropListsId))
	}
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.DropId != 0 {
		n += 1 + sovOut(uint64(m.DropId))
	}
	if m.DropProb != 0 {
		n += 1 + sovOut(uint64(m.DropProb))
	}
	return n
}

func (m *Dungeon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.Times != 0 {
		n += 1 + sovOut(uint64(m.Times))
	}
	if m.PlayersLv != 0 {
		n += 1 + sovOut(uint64(m.PlayersLv))
	}
	if m.CombatCap != 0 {
		n += 1 + sovOut(uint64(m.CombatCap))
	}
	if m.DungeonPlayerNum != 0 {
		n += 1 + sovOut(uint64(m.DungeonPlayerNum))
	}
	l = len(m.MapBehaviorTree)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	return n
}

func (m *InhibitAtk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.AtkType != 0 {
		n += 1 + sovOut(uint64(m.AtkType))
	}
	if m.DefType != 0 {
		n += 1 + sovOut(uint64(m.DefType))
	}
	if m.AtkEffect != 0 {
		n += 1 + sovOut(uint64(m.AtkEffect))
	}
	if m.SkillId != 0 {
		n += 1 + sovOut(uint64(m.SkillId))
	}
	return n
}

func (m *MapScene) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.MapType != 0 {
		n += 1 + sovOut(uint64(m.MapType))
	}
	l = len(m.CfgMap)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	l = len(m.BinMap)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	if m.DungeonID != 0 {
		n += 1 + sovOut(uint64(m.DungeonID))
	}
	if m.LevelMapID != 0 {
		n += 1 + sovOut(uint64(m.LevelMapID))
	}
	if m.RoguelikeID != 0 {
		n += 1 + sovOut(uint64(m.RoguelikeID))
	}
	if m.GoldProfit != 0 {
		n += 1 + sovOut(uint64(m.GoldProfit))
	}
	if m.LineMaxPersonsNum != 0 {
		n += 1 + sovOut(uint64(m.LineMaxPersonsNum))
	}
	if len(m.MedicamentId) > 0 {
		l = 0
		for _, e := range m.MedicamentId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	return n
}

func (m *Mechanics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.Idx != 0 {
		n += 1 + sovOut(uint64(m.Idx))
	}
	if len(m.ActiveBegin) > 0 {
		l = 0
		for _, e := range m.ActiveBegin {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.Circulate) > 0 {
		l = 0
		for _, e := range m.Circulate {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.DamagePercent) > 0 {
		l = 0
		for _, e := range m.DamagePercent {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.DueTime != 0 {
		n += 1 + sovOut(uint64(m.DueTime))
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovOut(uint64(l))
		}
	}
	return n
}

func (m *Medicament) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovOut(uint64(m.Level))
	}
	if m.Typ != 0 {
		n += 1 + sovOut(uint64(m.Typ))
	}
	if m.CD != 0 {
		n += 1 + sovOut(uint64(m.CD))
	}
	if m.BuffId != 0 {
		n += 1 + sovOut(uint64(m.BuffId))
	}
	if m.Limit != 0 {
		n += 1 + sovOut(uint64(m.Limit))
	}
	return n
}

func (m *Monster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.MonsterType != 0 {
		n += 1 + sovOut(uint64(m.MonsterType))
	}
	if m.MonsterAttackType != 0 {
		n += 1 + sovOut(uint64(m.MonsterAttackType))
	}
	if len(m.AtKSkill) > 0 {
		l = 0
		for _, e := range m.AtKSkill {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.SkillId) > 0 {
		l = 0
		for _, e := range m.SkillId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.BuffId) > 0 {
		l = 0
		for _, e := range m.BuffId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.Modle3DSize != 0 {
		n += 1 + sovOut(uint64(m.Modle3DSize))
	}
	if len(m.Inhibit) > 0 {
		l = 0
		for _, e := range m.Inhibit {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.LockRange != 0 {
		n += 1 + sovOut(uint64(m.LockRange))
	}
	if m.PursuitRange != 0 {
		n += 1 + sovOut(uint64(m.PursuitRange))
	}
	if m.DeathRefreshTime != 0 {
		n += 1 + sovOut(uint64(m.DeathRefreshTime))
	}
	if m.CorpseTime != 0 {
		n += 1 + sovOut(uint64(m.CorpseTime))
	}
	if m.Move != 0 {
		n += 1 + sovOut(uint64(m.Move))
	}
	if m.BeHitFlyParam != 0 {
		n += 1 + sovOut(uint64(m.BeHitFlyParam))
	}
	if m.BeRepulseParam != 0 {
		n += 1 + sovOut(uint64(m.BeRepulseParam))
	}
	if m.DeadItemsRange != 0 {
		n += 2 + sovOut(uint64(m.DeadItemsRange))
	}
	if m.DropListId != 0 {
		n += 2 + sovOut(uint64(m.DropListId))
	}
	if m.NumHpBar != 0 {
		n += 2 + sovOut(uint64(m.NumHpBar))
	}
	if len(m.ParameterQuality) > 0 {
		for k, v := range m.ParameterQuality {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MonsterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if len(m.MonsterId) > 0 {
		l = 0
		for _, e := range m.MonsterId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.AreaId != 0 {
		n += 1 + sovOut(uint64(m.AreaId))
	}
	return n
}

func (m *Robot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.ConfigId != 0 {
		n += 1 + sovOut(uint64(m.ConfigId))
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.SkillId) > 0 {
		l = 0
		for _, e := range m.SkillId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.BuffId) > 0 {
		l = 0
		for _, e := range m.BuffId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.Lv != 0 {
		n += 1 + sovOut(uint64(m.Lv))
	}
	return n
}

func (m *RoguelikeArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.QualityId != 0 {
		n += 1 + sovOut(uint64(m.QualityId))
	}
	if m.Quality != 0 {
		n += 1 + sovOut(uint64(m.Quality))
	}
	if len(m.OccupationFirst) > 0 {
		l = 0
		for _, e := range m.OccupationFirst {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.Weight != 0 {
		n += 1 + sovOut(uint64(m.Weight))
	}
	if len(m.AttrId) > 0 {
		l = 0
		for _, e := range m.AttrId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	return n
}

func (m *RoguelikeDungeon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.DungeonDay != 0 {
		n += 1 + sovOut(uint64(m.DungeonDay))
	}
	if m.BossCap != 0 {
		n += 1 + sovOut(uint64(m.BossCap))
	}
	if len(m.BossMechanical) > 0 {
		l = 0
		for _, e := range m.BossMechanical {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.Times != 0 {
		n += 1 + sovOut(uint64(m.Times))
	}
	if len(m.DungeonLv) > 0 {
		l = 0
		for _, e := range m.DungeonLv {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.DungeonSize) > 0 {
		l = 0
		for _, e := range m.DungeonSize {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.ResurrectionItem) > 0 {
		for k, v := range m.ResurrectionItem {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if m.ResurrectionItemAdd != 0 {
		n += 1 + sovOut(uint64(m.ResurrectionItemAdd))
	}
	if m.ResurrectionItemMax != 0 {
		n += 1 + sovOut(uint64(m.ResurrectionItemMax))
	}
	if m.ResurrectionTime != 0 {
		n += 1 + sovOut(uint64(m.ResurrectionTime))
	}
	if m.ResurrectionTimeInc != 0 {
		n += 1 + sovOut(uint64(m.ResurrectionTimeInc))
	}
	if m.ResurrectionTimeIMax != 0 {
		n += 1 + sovOut(uint64(m.ResurrectionTimeIMax))
	}
	if m.DungeonRewardPro != 0 {
		n += 1 + sovOut(uint64(m.DungeonRewardPro))
	}
	if len(m.DungeonReward) > 0 {
		for k, v := range m.DungeonReward {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.DungeonRewardWei) > 0 {
		l = 0
		for _, e := range m.DungeonRewardWei {
			l += sovOut(uint64(e))
		}
		n += 2 + sovOut(uint64(l)) + l
	}
	l = len(m.MapBehaviorTree)
	if l > 0 {
		n += 2 + l + sovOut(uint64(l))
	}
	if len(m.RoguelikeDungeonRoom) > 0 {
		for k, v := range m.RoguelikeDungeonRoom {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOut(uint64(l))
			}
			mapEntrySize := 1 + sovOut(uint64(k)) + l
			n += mapEntrySize + 2 + sovOut(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RoguelikeDungeonRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoguelikeDungeonId != 0 {
		n += 1 + sovOut(uint64(m.RoguelikeDungeonId))
	}
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.RoomTyp != 0 {
		n += 1 + sovOut(uint64(m.RoomTyp))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovOut(uint64(l))
		}
	}
	if len(m.RewardWeight) > 0 {
		l = 0
		for _, e := range m.RewardWeight {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	return n
}

func (m *RoleLv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.AdvancedHero != 0 {
		n += 1 + sovOut(uint64(m.AdvancedHero))
	}
	if len(m.AdvancedItem) > 0 {
		for k, v := range m.AdvancedItem {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if m.CopyId != 0 {
		n += 1 + sovOut(uint64(m.CopyId))
	}
	if m.LvHero != 0 {
		n += 1 + sovOut(uint64(m.LvHero))
	}
	if m.SmallLv != 0 {
		n += 1 + sovOut(uint64(m.SmallLv))
	}
	if m.Exp != 0 {
		n += 1 + sovOut(uint64(m.Exp))
	}
	if m.DivinationExp != 0 {
		n += 1 + sovOut(uint64(m.DivinationExp))
	}
	if len(m.DivinationWeight) > 0 {
		for k, v := range m.DivinationWeight {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.ParameterQuality) > 0 {
		for k, v := range m.ParameterQuality {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if m.PowerNum != 0 {
		n += 1 + sovOut(uint64(m.PowerNum))
	}
	if m.CompressLv != 0 {
		n += 1 + sovOut(uint64(m.CompressLv))
	}
	if m.SkillPowerNum != 0 {
		n += 1 + sovOut(uint64(m.SkillPowerNum))
	}
	return n
}

func (m *RoleReachDungeon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.Times != 0 {
		n += 1 + sovOut(uint64(m.Times))
	}
	if m.VictoryCondition != 0 {
		n += 1 + sovOut(uint64(m.VictoryCondition))
	}
	if m.FailCondition != 0 {
		n += 1 + sovOut(uint64(m.FailCondition))
	}
	if m.MapSceneId != 0 {
		n += 1 + sovOut(uint64(m.MapSceneId))
	}
	if m.BossId != 0 {
		n += 1 + sovOut(uint64(m.BossId))
	}
	return n
}

func (m *RowHero) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.OriginID != 0 {
		n += 1 + sovOut(uint64(m.OriginID))
	}
	if m.ArmsId != 0 {
		n += 1 + sovOut(uint64(m.ArmsId))
	}
	if m.ArmorId != 0 {
		n += 1 + sovOut(uint64(m.ArmorId))
	}
	if m.Modle3DSize != 0 {
		n += 1 + sovOut(uint64(m.Modle3DSize))
	}
	if len(m.AtKSkill) > 0 {
		l = 0
		for _, e := range m.AtKSkill {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.IntervalTime != 0 {
		n += 1 + sovOut(uint64(m.IntervalTime))
	}
	if len(m.SkillId) > 0 {
		l = 0
		for _, e := range m.SkillId {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if len(m.Inhibit) > 0 {
		l = 0
		for _, e := range m.Inhibit {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	if m.LockRange != 0 {
		n += 1 + sovOut(uint64(m.LockRange))
	}
	if m.DeathAnimationTime != 0 {
		n += 1 + sovOut(uint64(m.DeathAnimationTime))
	}
	if m.Move != 0 {
		n += 1 + sovOut(uint64(m.Move))
	}
	if m.BeHitFlyParam != 0 {
		n += 1 + sovOut(uint64(m.BeHitFlyParam))
	}
	if m.BeRepulseParam != 0 {
		n += 1 + sovOut(uint64(m.BeRepulseParam))
	}
	return n
}

func (m *Skill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.SkillBaseId != 0 {
		n += 1 + sovOut(uint64(m.SkillBaseId))
	}
	l = len(m.SkillView)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	if m.LogicId != 0 {
		n += 1 + sovOut(uint64(m.LogicId))
	}
	if m.IsNomalSkill {
		n += 2
	}
	if m.SkillWeight != 0 {
		n += 1 + sovOut(uint64(m.SkillWeight))
	}
	if m.SkillInterrupt {
		n += 2
	}
	if m.AtkRange != 0 {
		n += 1 + sovOut(uint64(m.AtkRange))
	}
	if m.SkillTarget != 0 {
		n += 1 + sovOut(uint64(m.SkillTarget))
	}
	if m.Target != 0 {
		n += 1 + sovOut(uint64(m.Target))
	}
	if m.SkillCD != 0 {
		n += 1 + sovOut(uint64(m.SkillCD))
	}
	if len(m.SkillBaceDam) > 0 {
		for k, v := range m.SkillBaceDam {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.AtkAddition) > 0 {
		for k, v := range m.AtkAddition {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	l = len(m.SkillAddBuff)
	if l > 0 {
		n += 1 + l + sovOut(uint64(l))
	}
	return n
}

func (m *Summoned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if len(m.MonsterId) > 0 {
		for k, v := range m.MonsterId {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.MonsterAttr) > 0 {
		for k, v := range m.MonsterAttr {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.SurvivalTime) > 0 {
		for k, v := range m.SurvivalTime {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOut(uint64(k)) + 1 + sovOut(uint64(v))
			n += mapEntrySize + 1 + sovOut(uint64(mapEntrySize))
		}
	}
	if len(m.SummonedBuff) > 0 {
		l = 0
		for _, e := range m.SummonedBuff {
			l += sovOut(uint64(e))
		}
		n += 1 + sovOut(uint64(l)) + l
	}
	return n
}

func (m *TempBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOut(uint64(m.Id))
	}
	if m.TempBagLevel != 0 {
		n += 1 + sovOut(uint64(m.TempBagLevel))
	}
	if m.RoleLevel != 0 {
		n += 1 + sovOut(uint64(m.RoleLevel))
	}
	if m.ProfitUpper != 0 {
		n += 1 + sovOut(uint64(m.ProfitUpper))
	}
	return n
}

func sovOut(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOut(x uint64) (n int) {
	return sovOut(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RptInt64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RptInt64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RptInt64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Slice = append(m.Slice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Slice) == 0 {
					m.Slice = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Slice = append(m.Slice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Slice", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyValue == nil {
				m.KeyValue = make(map[string]*KeyValue)
			}
			var mapkey string
			var mapvalue *KeyValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOut
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOut
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KeyValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KeyValue[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[int64]*Attr)
			}
			var mapkey int64
			var mapvalue *Attr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Attr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrTrans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttrTrans == nil {
				m.AttrTrans = make(map[int64]*AttrTrans)
			}
			var mapkey int64
			var mapvalue *AttrTrans
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttrTrans{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AttrTrans[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buff == nil {
				m.Buff = make(map[int64]*Buff)
			}
			var mapkey int64
			var mapvalue *Buff
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Buff{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Buff[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffEffect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuffEffect == nil {
				m.BuffEffect = make(map[int64]*BuffEffect)
			}
			var mapkey int64
			var mapvalue *BuffEffect
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BuffEffect{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuffEffect[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Drop == nil {
				m.Drop = make(map[int64]*Drop)
			}
			var mapkey int64
			var mapvalue *Drop
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Drop{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Drop[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropLists == nil {
				m.DropLists = make(map[int64]*DropLists)
			}
			var mapkey int64
			var mapvalue *DropLists
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DropLists{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DropLists[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dungeon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dungeon == nil {
				m.Dungeon = make(map[int64]*Dungeon)
			}
			var mapkey int64
			var mapvalue *Dungeon
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Dungeon{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Dungeon[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InhibitAtk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InhibitAtk == nil {
				m.InhibitAtk = make(map[int64]*InhibitAtk)
			}
			var mapkey int64
			var mapvalue *InhibitAtk
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &InhibitAtk{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InhibitAtk[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapScene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapScene == nil {
				m.MapScene = make(map[int64]*MapScene)
			}
			var mapkey int64
			var mapvalue *MapScene
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MapScene{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapScene[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechanics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mechanics == nil {
				m.Mechanics = make(map[int64]*Mechanics)
			}
			var mapkey int64
			var mapvalue *Mechanics
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Mechanics{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mechanics[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medicament", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Medicament == nil {
				m.Medicament = make(map[int64]*Medicament)
			}
			var mapkey int64
			var mapvalue *Medicament
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Medicament{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Medicament[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monster == nil {
				m.Monster = make(map[int64]*Monster)
			}
			var mapkey int64
			var mapvalue *Monster
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Monster{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Monster[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonsterGroup == nil {
				m.MonsterGroup = make(map[int64]*MonsterGroup)
			}
			var mapkey int64
			var mapvalue *MonsterGroup
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MonsterGroup{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MonsterGroup[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Robot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Robot == nil {
				m.Robot = make(map[int64]*Robot)
			}
			var mapkey int64
			var mapvalue *Robot
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Robot{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Robot[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoguelikeArtifact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoguelikeArtifact == nil {
				m.RoguelikeArtifact = make(map[int64]*RoguelikeArtifact)
			}
			var mapkey int64
			var mapvalue *RoguelikeArtifact
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoguelikeArtifact{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoguelikeArtifact[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoguelikeDungeon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoguelikeDungeon == nil {
				m.RoguelikeDungeon = make(map[int64]*RoguelikeDungeon)
			}
			var mapkey int64
			var mapvalue *RoguelikeDungeon
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoguelikeDungeon{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoguelikeDungeon[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleLv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleLv == nil {
				m.RoleLv = make(map[int64]*RoleLv)
			}
			var mapkey int64
			var mapvalue *RoleLv
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoleLv{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoleLv[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleReachDungeon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleReachDungeon == nil {
				m.RoleReachDungeon = make(map[int64]*RoleReachDungeon)
			}
			var mapkey int64
			var mapvalue *RoleReachDungeon
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoleReachDungeon{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoleReachDungeon[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowHero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowHero == nil {
				m.RowHero = make(map[int64]*RowHero)
			}
			var mapkey int64
			var mapvalue *RowHero
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RowHero{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RowHero[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skill == nil {
				m.Skill = make(map[int64]*Skill)
			}
			var mapkey int64
			var mapvalue *Skill
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Skill{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Skill[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summoned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summoned == nil {
				m.Summoned = make(map[int64]*Summoned)
			}
			var mapkey int64
			var mapvalue *Summoned
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Summoned{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Summoned[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempBag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TempBag == nil {
				m.TempBag = make(map[int64]*TempBag)
			}
			var mapkey int64
			var mapvalue *TempBag
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TempBag{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TempBag[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedType", wireType)
			}
			m.AdvancedType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvancedType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrTrans) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrTrans: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrTrans: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrID", wireType)
			}
			m.AttrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transtype", wireType)
			}
			m.Transtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Transtype |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransattrID", wireType)
			}
			m.TransattrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransattrID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transnum", wireType)
			}
			m.Transnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Transnum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Limithero = append(m.Limithero, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Limithero) == 0 {
					m.Limithero = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Limithero = append(m.Limithero, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Limithero", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Buff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Buff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Buff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffLv", wireType)
			}
			m.BuffLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffLv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffConditionType", wireType)
			}
			m.BuffConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffConditionType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicId", wireType)
			}
			m.LogicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicArgs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffEffectType", wireType)
			}
			m.BuffEffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffEffectType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffTime", wireType)
			}
			m.BuffTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffType = append(m.BuffType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffType) == 0 {
					m.BuffType = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffType = append(m.BuffType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffType", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrFixed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttrFixed == nil {
				m.AttrFixed = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AttrFixed[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttrPercentage == nil {
				m.AttrPercentage = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AttrPercentage[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeID", wireType)
			}
			m.AttributeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicId", wireType)
			}
			m.LogicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Drop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Drop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Drop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMini", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropMini == nil {
				m.DropMini = make(map[int64]*DropMini)
			}
			var mapkey int64
			var mapvalue *DropMini
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DropMini{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DropMini[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMini) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMini: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMini: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropId", wireType)
			}
			m.DropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemId == nil {
				m.ItemId = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ItemId[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemWeight", wireType)
			}
			m.ItemWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemWeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropLists) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropLists: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropLists: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropListsMini", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DropListsMini == nil {
				m.DropListsMini = make(map[int64]*DropListsMini)
			}
			var mapkey int64
			var mapvalue *DropListsMini
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DropListsMini{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DropListsMini[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropListsMini) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropListsMini: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropListsMini: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropListsId", wireType)
			}
			m.DropListsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropListsId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropId", wireType)
			}
			m.DropId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropProb", wireType)
			}
			m.DropProb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropProb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dungeon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dungeon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dungeon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayersLv", wireType)
			}
			m.PlayersLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayersLv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombatCap", wireType)
			}
			m.CombatCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CombatCap |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonPlayerNum", wireType)
			}
			m.DungeonPlayerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DungeonPlayerNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBehaviorTree", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapBehaviorTree = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InhibitAtk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InhibitAtk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InhibitAtk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkType", wireType)
			}
			m.AtkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefType", wireType)
			}
			m.DefType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkEffect", wireType)
			}
			m.AtkEffect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkEffect |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapScene) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapScene: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapScene: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapType", wireType)
			}
			m.MapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgMap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfgMap = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinMap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinMap = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonID", wireType)
			}
			m.DungeonID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DungeonID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelMapID", wireType)
			}
			m.LevelMapID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelMapID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoguelikeID", wireType)
			}
			m.RoguelikeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoguelikeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldProfit", wireType)
			}
			m.GoldProfit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldProfit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineMaxPersonsNum", wireType)
			}
			m.LineMaxPersonsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LineMaxPersonsNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MedicamentId = append(m.MedicamentId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MedicamentId) == 0 {
					m.MedicamentId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MedicamentId = append(m.MedicamentId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MedicamentId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mechanics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mechanics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mechanics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActiveBegin = append(m.ActiveBegin, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActiveBegin) == 0 {
					m.ActiveBegin = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActiveBegin = append(m.ActiveBegin, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveBegin", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Circulate = append(m.Circulate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Circulate) == 0 {
					m.Circulate = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Circulate = append(m.Circulate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Circulate", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DamagePercent = append(m.DamagePercent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DamagePercent) == 0 {
					m.DamagePercent = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DamagePercent = append(m.DamagePercent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DamagePercent", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DueTime", wireType)
			}
			m.DueTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DueTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &RptInt64{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Medicament) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Medicament: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Medicament: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CD", wireType)
			}
			m.CD = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CD |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Monster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Monster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Monster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterType", wireType)
			}
			m.MonsterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterAttackType", wireType)
			}
			m.MonsterAttackType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonsterAttackType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtKSkill = append(m.AtKSkill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AtKSkill) == 0 {
					m.AtKSkill = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtKSkill = append(m.AtKSkill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtKSkill", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkillId = append(m.SkillId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillId) == 0 {
					m.SkillId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkillId = append(m.SkillId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffId = append(m.BuffId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffId) == 0 {
					m.BuffId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffId = append(m.BuffId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modle3DSize", wireType)
			}
			m.Modle3DSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modle3DSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Inhibit = append(m.Inhibit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Inhibit) == 0 {
					m.Inhibit = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Inhibit = append(m.Inhibit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Inhibit", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockRange", wireType)
			}
			m.LockRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PursuitRange", wireType)
			}
			m.PursuitRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PursuitRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeathRefreshTime", wireType)
			}
			m.DeathRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeathRefreshTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorpseTime", wireType)
			}
			m.CorpseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CorpseTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Move", wireType)
			}
			m.Move = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Move |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeHitFlyParam", wireType)
			}
			m.BeHitFlyParam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeHitFlyParam |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeRepulseParam", wireType)
			}
			m.BeRepulseParam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeRepulseParam |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadItemsRange", wireType)
			}
			m.DeadItemsRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadItemsRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropListId", wireType)
			}
			m.DropListId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropListId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHpBar", wireType)
			}
			m.NumHpBar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumHpBar |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterQuality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParameterQuality == nil {
				m.ParameterQuality = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParameterQuality[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonsterGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonsterGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonsterGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MonsterId = append(m.MonsterId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MonsterId) == 0 {
					m.MonsterId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MonsterId = append(m.MonsterId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Robot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Robot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Robot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigId", wireType)
			}
			m.ConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkillId = append(m.SkillId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillId) == 0 {
					m.SkillId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkillId = append(m.SkillId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffId = append(m.BuffId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffId) == 0 {
					m.BuffId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffId = append(m.BuffId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoguelikeArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoguelikeArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoguelikeArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityId", wireType)
			}
			m.QualityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QualityId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OccupationFirst = append(m.OccupationFirst, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OccupationFirst) == 0 {
					m.OccupationFirst = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OccupationFirst = append(m.OccupationFirst, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OccupationFirst", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttrId = append(m.AttrId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttrId) == 0 {
					m.AttrId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttrId = append(m.AttrId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoguelikeDungeon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoguelikeDungeon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoguelikeDungeon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonDay", wireType)
			}
			m.DungeonDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DungeonDay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossCap", wireType)
			}
			m.BossCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossCap |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BossMechanical = append(m.BossMechanical, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BossMechanical) == 0 {
					m.BossMechanical = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BossMechanical = append(m.BossMechanical, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BossMechanical", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DungeonLv = append(m.DungeonLv, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DungeonLv) == 0 {
					m.DungeonLv = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DungeonLv = append(m.DungeonLv, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonLv", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DungeonSize = append(m.DungeonSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DungeonSize) == 0 {
					m.DungeonSize = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DungeonSize = append(m.DungeonSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonSize", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResurrectionItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResurrectionItem == nil {
				m.ResurrectionItem = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResurrectionItem[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResurrectionItemAdd", wireType)
			}
			m.ResurrectionItemAdd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResurrectionItemAdd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResurrectionItemMax", wireType)
			}
			m.ResurrectionItemMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResurrectionItemMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResurrectionTime", wireType)
			}
			m.ResurrectionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResurrectionTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResurrectionTimeInc", wireType)
			}
			m.ResurrectionTimeInc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResurrectionTimeInc |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResurrectionTimeIMax", wireType)
			}
			m.ResurrectionTimeIMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResurrectionTimeIMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonRewardPro", wireType)
			}
			m.DungeonRewardPro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DungeonRewardPro |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DungeonReward == nil {
				m.DungeonReward = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DungeonReward[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DungeonRewardWei = append(m.DungeonRewardWei, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DungeonRewardWei) == 0 {
					m.DungeonRewardWei = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DungeonRewardWei = append(m.DungeonRewardWei, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DungeonRewardWei", wireType)
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBehaviorTree", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapBehaviorTree = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoguelikeDungeonRoom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoguelikeDungeonRoom == nil {
				m.RoguelikeDungeonRoom = make(map[int64]*RoguelikeDungeonRoom)
			}
			var mapkey int64
			var mapvalue *RoguelikeDungeonRoom
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOut
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthOut
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoguelikeDungeonRoom{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoguelikeDungeonRoom[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoguelikeDungeonRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoguelikeDungeonRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoguelikeDungeonRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoguelikeDungeonId", wireType)
			}
			m.RoguelikeDungeonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoguelikeDungeonId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomTyp", wireType)
			}
			m.RoomTyp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomTyp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, &RptInt64{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RewardWeight = append(m.RewardWeight, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RewardWeight) == 0 {
					m.RewardWeight = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RewardWeight = append(m.RewardWeight, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardWeight", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleLv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleLv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleLv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedHero", wireType)
			}
			m.AdvancedHero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvancedHero |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvancedItem == nil {
				m.AdvancedItem = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdvancedItem[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyId", wireType)
			}
			m.CopyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LvHero", wireType)
			}
			m.LvHero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LvHero |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallLv", wireType)
			}
			m.SmallLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmallLv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivinationExp", wireType)
			}
			m.DivinationExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DivinationExp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivinationWeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DivinationWeight == nil {
				m.DivinationWeight = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DivinationWeight[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterQuality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParameterQuality == nil {
				m.ParameterQuality = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParameterQuality[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerNum", wireType)
			}
			m.PowerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressLv", wireType)
			}
			m.CompressLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressLv |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillPowerNum", wireType)
			}
			m.SkillPowerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillPowerNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleReachDungeon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleReachDungeon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleReachDungeon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VictoryCondition", wireType)
			}
			m.VictoryCondition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VictoryCondition |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailCondition", wireType)
			}
			m.FailCondition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailCondition |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSceneId", wireType)
			}
			m.MapSceneId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapSceneId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossId", wireType)
			}
			m.BossId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowHero) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowHero: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowHero: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginID", wireType)
			}
			m.OriginID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArmsId", wireType)
			}
			m.ArmsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArmsId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArmorId", wireType)
			}
			m.ArmorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArmorId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modle3DSize", wireType)
			}
			m.Modle3DSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modle3DSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AtKSkill = append(m.AtKSkill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AtKSkill) == 0 {
					m.AtKSkill = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AtKSkill = append(m.AtKSkill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtKSkill", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalTime", wireType)
			}
			m.IntervalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkillId = append(m.SkillId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillId) == 0 {
					m.SkillId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkillId = append(m.SkillId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Inhibit = append(m.Inhibit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Inhibit) == 0 {
					m.Inhibit = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Inhibit = append(m.Inhibit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Inhibit", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockRange", wireType)
			}
			m.LockRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeathAnimationTime", wireType)
			}
			m.DeathAnimationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeathAnimationTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Move", wireType)
			}
			m.Move = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Move |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeHitFlyParam", wireType)
			}
			m.BeHitFlyParam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeHitFlyParam |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeRepulseParam", wireType)
			}
			m.BeRepulseParam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeRepulseParam |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Skill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Skill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Skill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBaseId", wireType)
			}
			m.SkillBaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillBaseId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillView", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillView = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicId", wireType)
			}
			m.LogicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNomalSkill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNomalSkill = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillWeight", wireType)
			}
			m.SkillWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillWeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillInterrupt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkillInterrupt = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkRange", wireType)
			}
			m.AtkRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AtkRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillTarget", wireType)
			}
			m.SkillTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillTarget |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillCD", wireType)
			}
			m.SkillCD = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillCD |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillBaceDam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillBaceDam == nil {
				m.SkillBaceDam = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillBaceDam[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkAddition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AtkAddition == nil {
				m.AtkAddition = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AtkAddition[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillAddBuff", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillAddBuff = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Summoned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Summoned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Summoned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonsterId == nil {
				m.MonsterId = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MonsterId[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterAttr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MonsterAttr == nil {
				m.MonsterAttr = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MonsterAttr[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SurvivalTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOut
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOut
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SurvivalTime == nil {
				m.SurvivalTime = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOut(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOut
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SurvivalTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SummonedBuff = append(m.SummonedBuff, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOut
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOut
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOut
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SummonedBuff) == 0 {
					m.SummonedBuff = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOut
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SummonedBuff = append(m.SummonedBuff, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SummonedBuff", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TempBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOut
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TempBag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TempBag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempBagLevel", wireType)
			}
			m.TempBagLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempBagLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleLevel", wireType)
			}
			m.RoleLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfitUpper", wireType)
			}
			m.ProfitUpper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOut
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProfitUpper |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOut(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOut
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOut(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOut
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOut
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOut
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOut
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOut
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOut
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOut        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOut          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOut = fmt.Errorf("proto: unexpected end of group")
)
